{$EDIT CE_START}
{========================================================================
------- Master file for the classical electrophysioly protocols ---------
========================================================================}

Const
   ProtocolCount = 11 ; 
   CONTINUOUS_TIMER = 0.5 ; 

var  { ========= COMMON VARIABLES ============ }
   protocol_choice : integer; 
   amplifier, comments, PathOfTheDay, root_dir : string ; 
   MainDialog, dialog : Tdialog ;{ two dialogs for buttons and protocols}
   stim, SAVING : boolean ; 
   ProtocolName:array[1..protocolCount] of string; ProtoNames:string;
   DB:Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; {variables to fetch the date and time }
   gain1,gain2,f_acq : real; gain1_int,gain2_int,clamp_int:integer;cont_choice:boolean;  
   dll_load : string ;
   detector : Tdetector; // detector use througout the protocols in cqse of continuous mode for online analysis


{ ============================================================================
 ---- Protocol names and graphical settings ----------------------------------
 ============================================================================= }
 
 
procedure SetProtocolNames;
var          
  i:integer;
begin
  ProtocolName[1]:= 'Passive_Recording';
  ProtocolName[2]:= 'Seal_Test';
  ProtocolName[3]:= 'VC-Membrane_Test'; 
  ProtocolName[4]:= 'perforing_monitor';
  ProtocolName[5]:= 'IC-Membrane_Test';
  ProtocolName[6]:= 'I-V_curve'; 
  ProtocolName[7]:= 'Sinusoids_Stim'; 
  ProtocolName[8]:= 'Pulses_Stim'; 
  ProtocolName[9]:= 'Stochastic_Stim'; 
  ProtocolName[10]:= 'fancy_Ramps-Pulses'; 
  ProtocolName[11]:= 'F-I curve'; 
  ProtoNames:=ProtocolName[1];
  for i:=2 to ProtocolCount do ProtoNames:=ProtoNames+'|'+ProtocolName[i];
end;    

procedure init_windows;
var ii:integer;
begin
  deleteallpages('default');
  for ii:=1 to ProtocolCount do 
  begin
  InsertPage(ii,ProtocolName[ii]);
  Definewindow(ii, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(ii, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(ii, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DivideWindow(ii,3,4,1);
  Page:=ii; color:=cl_gray;
  end;
end;

{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments+Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }


procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  //DB.clone(TDBrecord('PG0.global'));        
  DB.s:=''+CRLF;                                     
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,TDBrecord('PG0.global').count+jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_choice];
  DB.Comments := comments ; {comments is a global variable }
end;

procedure save_metadata_as_txt;
var jj:integer; st, st2:string;
begin
   openText(1,acquisition.genericFilename+'.json',false);
   writelnText(1,'{');
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    st2:=TDBrecord('PG0.global').Valstring[jj] ;
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    st2:=TDBrecord('PG0.Exp_params').Valstring[jj];
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;        
  for jj:=1 to ChannelCount do WriteLnText(1, '"DY'+Istr(jj)+'" : "'+Rstr(v[jj].dY)+'",');
  writelnText(1,'"lastline":"no_value"');
  writelnText(1,'}');
  closeText(1);                                                              
end;

procedure my_initprocess0;
var Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; PathOfTheDay, sep, protocol  : string ; {variables to fetch the date and time }
begin
  PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ;
  protocol := TDBrecord('PG0.Exp_params').exp_type ;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
  acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+  '_'+protocol ;
  FillDBinfo(DB); 
  if acquisition.saving then
     begin
	    acquisition.writeDBfileinfo(DB);
	    save_metadata_as_txt;
     end;
end;

{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }


{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }


procedure Init_AcqChannels_DEMO; { setting the channels for the RTneuron-simulation mode}
var 
   gain1, gain2, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   Clamp_int, max_ep_num :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 2; // for the whole classic_electrophy protocols
   {we load the informations from the global TDBrecord }
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   stim:=TDBrecord('PG0.global').stim;
   Continu:=TDBrecord('PG0.global').cont_choice;
   {we delete previous graphical display}
   ClearObjects(1,1);
   ClearObjects(1,2);

   { see the documentation, for the details of the acquisition and RTneuron functions }
   RTneuron.ResetParams;
    
   acquisition.Fcontinuous:=True; {continuous by force with RTneuron, else only one episode}
   acquisition.PeriodPerChannel:= 0.1 ; {in ms}

    if stim then acquisition.Fstimulate := True
    else acquisition.Fstimulate:=False;  { we stimulate or not }
    
    acquisition.TriggerMode:= TM_internal;
    
    acquisition.Channels[1].ChannelType:= TI_Neuron; { here we set that we read the acquisition from NEURON }
    acquisition.Channels[2].ChannelType:= TI_Neuron;
    acquisition.Channels[3].ChannelType:= TI_Neuron; { we also set up here the visualisation of the command }
    acquisition.Channels[1].DownSamplingFactor:=1;
    acquisition.Channels[2].DownSamplingFactor:=1;
    acquisition.Channels[3].DownSamplingFactor:=1;

    RTneuron.execute('create soma') ;
    RTneuron.execute('soma insert pas');
    RTneuron.execute('soma insert hh_hippoc');
    RTneuron.execute('objref stim');
   
    if Clamp_int=1 then { IF CURRENT-CLAMP }
    begin { we link the analogous signal to the NEURON variables with the right gain }
       RTneuron.execute('stim = new myIClamp(.5)');
       acquisition.Channels[1].NrnSymbolName:='soma.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
       acquisition.Channels[2].NrnSymbolName:='stim.Ipico'; acquisition.Channels[2].unitY:='pA' ;
       v1.cpx:=1 ; v2.cpx:=1 ; v1.cpy := 1 ; v2.cpy:= 2; {we set the coupling value -> to couple to future analysis}
       addObject(1,1,v1);
       addObject(1,2,v2);
    end;                         
                                                                                   
    if Clamp_int=2 then { IF VOLTAGE CLAMP }
    begin
       RTneuron.execute('stim = new myVClamp(.5)');
       acquisition.Channels[1].NrnSymbolName:='stim.Ipico'; acquisition.Channels[1].unitY:='pA' ;
       acquisition.Channels[2].NrnSymbolName:='soma.v(.5)'; acquisition.Channels[2].unitY:='mV' ;
       v1.cpx:=1 ; v2.cpx:=1 ; v1.cpy := 1 ; v2.cpy:= 2;  {we set the coupling value -> to couple to future analysis}
       addObject(1,1,v1);
       addObject(1,2,v2);
    end; { we will call this function each time we modify a gain }

    if continu then begin detector.create; detector.InitTimer(v1, CONTINUOUS_TIMER); end;  // period between analysis to adjust !!
end;


procedure Init_AcqChannels; { setting the channels for the RTneuron-simulation mode}
var 
   gain1, gain2, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   Clamp_int, max_ep_num :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 3; // for the whole classic_electrophy protocols

   {we load the informations from the global TDBrecord }
   Continu:=TDBrecord('PG0.global').cont_choice;
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   stim:=TDBrecord('PG0.global').stim;
   max_ep_num := TDBrecord('PG0.global').max_EP_num ;
   f_acq := TDBrecord('PG0.global').f_acq ;
   epdur := TDBrecord('PG0.global').episode_duration;
   {we delete previous graphical display}
   ClearObjects(1,1);
   ClearObjects(1,2);

   { see the documentation, for the details of the acquisition and RTneuron functions }
   RTneuron.ResetParams;
    
   acquisition.Fcontinuous:=Continu; {boolean true ->continuous acquisition, False -> episode mode}
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

    if stim then acquisition.Fstimulate := True
    else acquisition.Fstimulate:=False;  { we stimulate or not }
    
    acquisition.MaxEpCount := max_ep_num ;
    acquisition.EpDuration := epdur ;
    
    acquisition.TriggerMode:= TM_internal;
    acquisition.Channels[1].ChannelType:= TI_Neuron; { here we set that we read the acquisition from NEURON }
    acquisition.Channels[2].ChannelType:= TI_Neuron;
    acquisition.Channels[1].DownSamplingFactor:=1;
    acquisition.Channels[2].DownSamplingFactor:=1;
    
    if Clamp_int=1 then { IF CURRENT-CLAMP }
    begin { we link the analogous signal to the NEURON variables with the right gain }
      RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='Vm';    // primary     
      RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='Vm_filtered'; // primary filtered
      RTneuron.AdcChan[2].setScale(0,32767,0,20000.0/gain2); RTneuron.AdcChan[2].NrnSymbolName:='Iinj'; // secondary 
      acquisition.Channels[1].NrnSymbolName:='Vm'; acquisition.Channels[1].unitY:='mV' ;
      acquisition.Channels[2].NrnSymbolName:='Iinj'; acquisition.Channels[2].unitY:='pA' ;
    end;                                                                                                        
    if Clamp_int=2 then { IF VOLTAGE CLAMP }
    begin
      RTneuron.AdcChan[0].setScale(0,32767,0,20000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='Iinj';         
      RTneuron.AdcChan[1].setScale(0,32767,0,20000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='Iinj_filtered';         
      RTneuron.AdcChan[2].setScale(0,32767,0,1000.0/gain2); RTneuron.AdcChan[2].NrnSymbolName:='Vm';  
      acquisition.Channels[1].NrnSymbolName:='Iinj'; acquisition.Channels[1].unitY:='pA' ;
      acquisition.Channels[2].NrnSymbolName:='Vm'; acquisition.Channels[2].unitY:='mV' ;
    end; { we will call this function each time we modify a gain }
    
    
    {then graphical options}
    v1.cpx:=1 ; v2.cpx:=1 ; v1.cpy := 1 ; v2.cpy:= 2; {we set the coupling value -> to couple to future analysis}
    addObject(1,1,v1);
    addObject(1,2,v2);
    // then in case of continuous mode we create the detector  
    //if continu then begin detector.create; detector.InitTimer(v1, CONTINUOUS_TIMER); end;  // period between analysis to adjust !!
    
end;

{ ==============================================================================
--------- Setting the Stimulation channels -------------------------------------
================================================================================ }

procedure Init_StimChannels_DEMO; { initializa the stimulator object, see doc}
var Continu, fadvanceon :boolean;Clamp_int:integer; acquisitionISI : real;
begin { We link the Elphy stimulation to the NEURON variable, then the NEURON variable to the analogous command }
                                           
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   acquisitionISI := TDBrecord('PG0.global').acquisitionISI ;  
   stimulator.ChannelCount:=1;
   stimulator.setByProg:=true; { mais on met le build ep plus loin }
   stimulator.Channels[1].ChannelType:=TO_Neuron;
   fadvanceon := True ; // to make NEURON calculate or not !
   //if not Continu then acquisition.ISI := acquisitionISI;
  
   if Clamp_int=1 then { IF CURRENT CLAMP }
   begin
      stimulator.Channels[1].NrnSymbolName:='stim.Ipico';
   end;
   if Clamp_int=2 then { IF VOLTAGE CLAMP }
   begin
      stimulator.Channels[1].NrnSymbolName:='stim.Vamp';
   end;
end;


procedure Init_StimChannels; { crucial function as well }
var Continu, fadvanceON :boolean;Clamp_int:integer; acquisitionISI : real;
begin { We link the Elphy stimulation to the NEURON variable, then the NEURON variable to the analogous command }

   Continu:=TDBrecord('PG0.global').cont_choice;
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   acquisitionISI := TDBrecord('PG0.global').acquisitionISI ;  
   
   stimulator.ChannelCount:=1;
   stimulator.setByProg:=true; { mais on met le build ep plus loin }
   {stimulation on neuron}
   stimulator.Channels[1].ChannelType:=TO_Neuron;
   acquisition.Channels[3].ChannelType:= TI_Neuron; { we also set up here the visualisation of the command }
   acquisition.Channels[3].DownSamplingFactor:=1;
   if not Continu then acquisition.ISI := acquisitionISI;
   fadvanceon := TDBrecord('PG0.global').FadvanceON ; // to make NEURON calculate or not !
  
  if Clamp_int=1 then { IF CURRENT CLAMP }
  begin
    RTneuron.DacChan[0].NrnSymbolName:='Ith'; RTneuron.DacChan[0].setScale(0,32767,0,4000.0); // command -> I clamp
    stimulator.Channels[1].NrnSymbolName:='Ith';
    acquisition.Channels[3].NrnSymbolName:='Ith'; acquisition.Channels[3].unitY:='pA';
  end;
  if Clamp_int=2 then { IF VOLTAGE CLAMP }
  begin
    RTneuron.DacChan[0].NrnSymbolName:='Vth'; RTneuron.DacChan[0].setScale(0,32767,0,200.0); // command -> V clamp
    stimulator.Channels[1].NrnSymbolName:='Vth';
    acquisition.Channels[3].NrnSymbolName:='Vth'; acquisition.Channels[3].unitY:='mV';
  end;

  addObject(1,2,v3); {on ajoute aussi l'affichage de la stimulation sur le meme grap que la voie 2 }
  v3.cpx:=1 ; v3.cpy:= 2; v3.color := CL_red ; {we couple this channel to v2 }
end;


{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
var Gain1_int:integer;
begin
    gain1_int:=TDBrecord('PG0.global').Gain1_int;
    case Gain1_int of
    1: TDBrecord('PG0.global').Gain1 := 1.0; 2: TDBrecord('PG0.global').Gain1 := 2.0;
    3: TDBrecord('PG0.global').Gain1 := 5.0; 4: TDBrecord('PG0.global').Gain1 := 10.0;
    5: TDBrecord('PG0.global').Gain1 := 20.0; 6: TDBrecord('PG0.global').Gain1 := 50.0;
    7: TDBrecord('PG0.global').Gain1 := 100.0; 8: TDBrecord('PG0.global').Gain1 := 200.0;
    9: TDBrecord('PG0.global').Gain1 := 500.0; 10: TDBrecord('PG0.global').Gain1 := 1000.0;
    11: TDBrecord('PG0.global').Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure SetGain2;
var Gain2_int:integer;
begin
    gain2_int:=TDBrecord('PG0.global').Gain2_int;
    case Gain2_int of
    1: TDBrecord('PG0.global').Gain2 := 1.0;   2: TDBrecord('PG0.global').Gain2 := 2.0; 
    3: TDBrecord('PG0.global').Gain2 := 5.0;  4: TDBrecord('PG0.global').Gain2 := 10.0;
    5: TDBrecord('PG0.global').Gain2 := 20.0;   6: TDBrecord('PG0.global').Gain2 := 50.0; 
    7: TDBrecord('PG0.global').Gain2 := 100.0;
    end;
end;   {SetGain2}


procedure InitializeChannels;
var amplifier : string ;
begin
  amplifier := TDBrecord('PG0.global').amplifier ;
  if amplifier='nrn_simulation' then
  begin
    Init_AcqChannels_DEMO;
    if acquisition.Fstimulate then Init_StimChannels_DEMO;
  end;
  if amplifier='multiclamp' then
  begin
    Init_AcqChannels;
    if acquisition.Fstimulate then Init_StimChannels;
  end;
end;


procedure Build_Set0(seq:longint;var vec:Tvector); 
begin  
vec.fill(0); 
end;
 
procedure set_dac_to_zero;
begin
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True; 
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);
    stimulator.setValue(0,0,1,0);
    stimulator.setValue(0,1,0,0);
end;
if (acquisition.Fcontinuous=True) and (acquisition.Fstimulate=True) then  // well... i think there is no other way to set the output to 0.... ;(
begin   // if continuous qnd not pqssive recording
acquisition.Fcontinuous :=False;
acquisition.MaxEpCount :=1;
stimulator.Channels[1].BuildEp := Build_Set0 ; 
TDBrecord('PG0.global').max_EP_num :=1;
stimulator.initVectors;
acquisition.start;
end;    
end;

ProcessCont  { COMMON to all continuous processes }
begin
detector.update(v1.Iend);
end;

procedure passive_recording_init;
begin
DestroyAllWindows(1);
Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
TDBrecord('PG0.global').cont_choice:=True;
TDBrecord('PG0.global').stim:=False;
TDBrecord('PG0.Exp_params').exp_type :='passive-recording' ;
InitializeChannels;
detector.create;
acquisition.InstallProcess(my_initprocess0, nil, nil, nil);
addObject(1,1,v1);
addObject(1,2,v2);
end;


{$EDIT seal_test}
{ ==============================================================================
--------------- BUILDING THE SEAL TEST PROCEDURE AND DIALOG --------------------
================================================================================ }

var 
  tseal_vec : Tvector ; rseal_vec : Tvector ; iseal_vec : Tvector ; 
  { vectors to monitor the evolution of the ileak and resistance of the seal in time } 
  seal_memo : Tmemo ;   rseal_graph : Tgraph ; iseal_graph : Tgraph ;
  i_baseline : real ; i_jump : real ; Rseal : real ; t0_seal : real ;
  seal_dialog : Tdialog ; amp_seal, del_seal, dur_seal : real ;

procedure Build_SealPulse(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  vec.fill(0); vec.fill1(amp_seal,del_seal+vec.Istart,del_seal+dur_seal+vec.Istart);
end;

procedure seal_process;
var tt : Tvector ;
begin
    DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}

    tt.create; Vcopy(v1,tt) ; i_baseline := tt.mean(1,del_seal-1); {constantes a ajuster en fonction des parametres du pulse}
    i_jump := tt.mean(del_seal+20,del_seal+dur_seal-5);
    if (i_jump-i_baseline)<>0 then Rseal := amp_seal/(i_jump-i_baseline)*1000 else Rseal:=0 ; 

    rseal_vec.addtolist(Rseal); iseal_vec.addtolist(i_baseline);
    tseal_vec.addtolist(60*Hour + Minute + Second/60 + MilliSecond/60/1000-t0_seal);
    rseal_vec.refresh;iseal_vec.refresh;tseal_vec.refresh;
    
    
    rseal_graph.modify(tseal_vec,rseal_vec,tseal_vec.Istart,tseal_vec.Iend);
    rseal_graph.refresh; rseal_graph.SetWorld(tseal_vec.Ymin,rseal_vec.Ymin,tseal_vec.Ymax,rseal_vec.Ymax);
    iseal_graph.modify(tseal_vec,iseal_vec,tseal_vec.Istart,tseal_vec.Iend);
    iseal_graph.refresh; iseal_graph.SetWorld(tseal_vec.Ymin,iseal_vec.Ymin,tseal_vec.Ymax,iseal_vec.Ymax);
    
    seal_memo.lines[3]:='Rseal= '+Rstr(Rseal,6,3)+' Mohm';
    seal_memo.lines[5]:='I baseline= '+Rstr(i_baseline,6,3)+' pA';
    seal_memo.refresh;
end;

procedure Prepare_SealTest;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 2 ; // Voltage Clamp
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_seal+dur_seal ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:=0.5 ;  // small beak between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='seal_test';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_seal;
         TDBrecord('PG0.Exp_params').start_at:=del_seal;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_seal;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_SealPulse ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, seal_process, set_dac_to_zero);
end;

procedure SealTest_Event(n:integer);
var amplifier : string ; 
begin    
   seal_dialog.updatevar;
   case n of 
   201 : Prepare_SealTest ;
   end;
end;

procedure SealTest_Init; 
begin {when we modify the dialog, we adjust the stimulation params}

  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), Round(PageWidth/3), PageHeight);
  Definewindow(1, Round(PageWidth/3), Round(PageHeight*2/3), Round(2*PageWidth/3), PageHeight);
  Definewindow(1, Round(2*PageWidth/3), Round(PageHeight*2/3), Round(5*PageWidth/6), PageHeight);
  Definewindow(1, Round(5*PageWidth/6), Round(PageHeight*2/3), PageWidth, PageHeight);
  color:=cl_gray;

  amp_seal :=-5; del_seal :=25 ; dur_seal := 100;  {pulse parameters}
  {then we display the channels}
  addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);
  {then memo to display the values}
  seal_memo.create(''); seal_memo.font.name:='Times New Roman'; seal_memo.font.size:=13;
  seal_memo.font.color:=rgb(0,0,0);  seal_memo.font.style:=fs_bold;
  seal_memo.lines[3]:='Rseal= '+Rstr(Rseal,6,3)+' Mohm';
  seal_memo.lines[5]:='I baseline= '+Rstr(i_baseline,6,3)+' pA';
  addObject(1,5,seal_memo);
  {then the graph to display the time evolution of the parameters}
  tseal_vec.create(t_single,0,-1);iseal_vec.create(t_single,0,-1);rseal_vec.create(t_single,0,-1);
  rseal_graph.create(tseal_vec,rseal_vec,0,0); rseal_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
  iseal_graph.create(tseal_vec,iseal_vec,0,0); iseal_graph.Mode := DM_LINE_DIAMOND ;
  addobject(1,3,rseal_graph);  {then we plot the vector}
  addobject(1,4,iseal_graph);  {then we plot the vector} 
  
  {finally the small dialog fot the parameters and the initialisation}
  seal_dialog.create ;
  seal_dialog.getRealA(' Pulse size (mV)',amp_seal,3,1,99);
  seal_dialog.getRealA(' onset (ms)',del_seal,3,1,99);
  seal_dialog.getRealA(' duration (ms)',dur_seal,3,1,99);
  seal_dialog.getCommandA('  init() ',0,999);
  seal_dialog.OnEvent:=SealTest_event ;
  AddDialog(1,6,seal_dialog); 
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
  t0_seal := 60*Hour + Minute + Second/60 + MilliSecond/60/1000;
  Prepare_SealTest ; // first initialization
end;

      
{$EDIT VC_membrane_test}
{ ==============================================================================
--------------- BUILDING THE MEMBRANE TEST IN VOLTAGE CLAMP --------------------
================================================================================ }

{ Membrane Test procedure : Voltage Clamp test }
var
  VCMT_fit : TcurveFitting;  VCMT_memo:Tmemo;  lVer:TlineVer;  lHor:TlineHor;
  VCMT_moy : Taverage; VCMT_dialog : Tdialog ;  rs_vec : Tvector ; tmem_vec : Tvector ; 
  t0_mem : real ; rs_graph : Tgraph ;  mt_dialog : Tdialog ; 
  mt_cursor : Tcursor ; VCMT_interStim : real ;
  VCMT_amp, VCMT_t1, VCMT_t2, VCMT_t3, VCMT_t4 : real ; {this will define the coltage s}


procedure Build_VCMTstim(seq:longint;var vec:Tvector); 
begin
   vec.fill(0);
   vec.fill1(-VCMT_amp/2,vec.Istart+VCMT_t1,vec.Istart+VCMT_t2);
   vec.fill1(VCMT_amp/2,vec.Istart+VCMT_t2,vec.Istart+VCMT_t3);
   vec.fill1(-VCMT_amp/2,vec.Istart+VCMT_t3,vec.Istart+VCMT_t4);
end;
  
var
  rm,rs,cm,rs2:real;

 //old version,  implemented by gerard, not based on the surface...
procedure RsCm2(var vec:Tvector;var rm,rs,cm,rs2:real;cursor : Boolean); 
  var
    I0,Im1,Is,Ip,tau:real;
    x0:real;
    x,xa,xb:real;
    xorg:real;
  begin
    I0:=vec.mean(1,VCMT_t1-2);
    Im1:=mini(vec,VCMT_t1-5,VCMT_t1+5)-I0;
    Ip:=Im1; x0:=miniX(vec,VCMT_t1,VCMT_t1+5);
    xorg:=FirstCrossing(vec,VCMT_t1-5,VCMT_t1+5,I0+Im1/2,false);
    VCMT_fit.Xorigin:=xorg;
    if cursor then begin VCMT_fit.xstartFit:=mt_cursor.position[1]; VCMT_fit.XendFit:=mt_cursor.position[2]; end 
    else begin VCMT_fit.xstartFit:=x0+v1.convX(1); VCMT_fit.XendFit:=VCMT_t2-1;end;
    VCMT_fit.execute; VCMT_fit.refresh ;
    tau:=VCMT_fit.Param['a2'];
    if tau<0 then tau:=-1/tau else tau:=1E9;
    Is:=VCMT_fit.Param['a3']-I0;
    Im1:=VCMT_fit.Param['a1']+Is;
    if Im1<>0 then rs:=VCMT_amp/Im1*1000 else rs:=1E6; 
    if Ip<>0 then rs2:=VCMT_amp/Ip*1000 else rs2:=1E6;
    if Is<>0 then Rm:=VCMT_amp/Is*1000-Rs else Rm:=1E6;
    Cm:=tau*(Rs+Rm)/(Rm*Rs)*1000;       
    lHor.y:=Is+I0;
    lVer.x:=xOrg;
    with VCMT_memo do
    begin
      lines[3]:='tau='+Rstr(tau,12,3)+' ms';
      lines[4]:='rs= '+Rstr(rs,12,3)+' Mohm';
      lines[5]:='rm= '+Rstr(rm,12,3)+' Mohm';
      lines[6]:='Cm= '+Rstr(Cm,12,3)+' pF';
      lines[7]:='Rs2='+Rstr(rs2,12,3)+' Mohm';
    end;
    VCMT_memo.refresh;                     
  end;


procedure RsCm(var vec_arg:Tvector;var rm,rs,cm,rs2:real;cursor : Boolean); 
  var
    Ibase,Iend,integral_response,DI,Ijump,tau:real;
    integral_resist,integral_capa : real ;
    x0,x,xa,xb,Tint:real;
    xorg:real;

  begin
    Ibase:= vec_arg.mean(VCMT_t2-11,VCMT_t2-1); {mean over 10ms}
    Iend:= vec_arg.mean(VCMT_t3-11,VCMT_t3-1);  {mean over 10ms}
    DI := Iend-Ibase ; {DI positif ou negatif}
    if DI = 0 then DI:=1e-9 ; 
    if DI<0 then 
       begin
          Ijump:=mini(vec_arg,VCMT_t2-5,VCMT_t2+5)-Ibase;
          x0:=miniX(vec_arg,VCMT_t2,VCMT_t2+5);
          xorg:=FirstCrossing(vec_arg,VCMT_t2-5,VCMT_t2+5,Ibase+Ijump/2,false); {false for downward}
       end;
    if DI>0 then 
       begin
          Ijump:=maxi(vec_arg,VCMT_t2-5,VCMT_t2+5)-Ibase;
          x0:=maxiX(vec_arg,VCMT_t2,VCMT_t2+5);
          xorg:=FirstCrossing(vec_arg,VCMT_t2-5,VCMT_t2+5,Ibase+Ijump/2,true); {true for upward}
       end;

    VCMT_fit.Xorigin:=xorg;

    if cursor then begin VCMT_fit.xstartFit:=mt_cursor.position[1]; VCMT_fit.XendFit:=mt_cursor.position[2]; end 
    else begin VCMT_fit.xstartFit:=x0+v1.convX(1); VCMT_fit.XendFit:=VCMT_t3-1;end;

    VCMT_fit.execute; VCMT_fit.refresh ;

    tau:=VCMT_fit.Param['a2']; {in the fit we only use the time constant value}
    if tau<0 then tau:=-1/tau else tau:=1E9;

    Tint := VCMT_t3-VCMT_t2 ; {length of the integral} 
    integral_response := Integral(vec_arg,VCMT_t2,VCMT_t2+Tint,VCMT_t2-20,VCMT_t2-1);
    integral_resist := DI*(Tint+Tau*(exp(-Tint/tau)-1)); {theoretical value given tau and Di, do the calculus}
    integral_capa := integral_response  - integral_resist ;
    {then we can deduce all the parameters :}
    if integral_capa<>0 then rs:=tau*VCMT_amp/integral_capa*1000.0 else RS:=1E6;   { ms*mV / ms*pA *1000 -> Mohm } 
    if DI<>0 then Rm:=VCMT_amp/DI*1000-Rs else Rm:=1E6;  { mV/pA*1000 -> Mohm  }
    Cm:=tau*(Rs+Rm)/(Rm*Rs)*1000; {ms/Mohm*1000-> pF }
    
    lHor.y:=Iend;
    lVer.x:=xOrg;
    with VCMT_memo do
    begin
      lines[3]:='tau='+Rstr(tau,12,3)+' ms';
      lines[4]:='rs= '+Rstr(RS,12,3)+' Mohm';
      lines[5]:='rm= '+Rstr(rm,12,3)+' Mohm';
      lines[6]:='Cm= '+Rstr(Cm,12,3)+' pF';
    end;
    VCMT_memo.refresh;
end;


{ ------------- then, Procedures of the Acquisition Processes (see doc) ----------}   

procedure mt_initprocess;
begin
  VCMT_moy.create(t_single,v1.Istart,v1.Iend);
  VCMT_moy.cpx:=1;  VCMT_moy.cpy:=1;  VCMT_moy.color:=cl_blue;
  VCMT_moy.setWorld(VCMT_t2-5,v1.Ymin,VCMT_t2+5,v1.Ymax);
  addObject(1,1,VCMT_moy);

  VCMT_fit.create('');
  VCMT_fit.standardModel:=fm_expC1 {fm_poly5};
  VCMT_fit.initialize:=true;  VCMT_fit.reset;  VCMT_fit.setYdata(VCMT_moy);  VCMT_fit.MaxIt:=30;

  VCMT_fit.setWorld(VCMT_moy.xmin,VCMT_moy.ymin,VCMT_moy.xmax,VCMT_moy.ymax);
  VCMT_fit.cpx:=1;  VCMT_fit.cpy:=1;  VCMT_fit.matchVector(v1);  VCMT_fit.color:=cl_red;
  addObject(1,1,VCMT_fit);
end;

procedure mt_process;
begin
     VCMT_moy.add(v1); {we add each episode result to the average}
end;

procedure mt_endprocess;
begin
  rsCm(VCMT_moy,rm,rs,cm,rs2,False); { and we process the analysis}
  rs_vec.addtolist(rs); rs_vec.refresh;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
  tmem_vec.addtolist(0.001*(1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond -t0_mem)); tmem_vec.refresh;
  rs_graph.modify(tmem_vec,rs_vec,rs_vec.Istart,rs_vec.Iend); rs_graph.refresh ;
  set_dac_to_zero;
end;


procedure prepare_mt;
begin
   {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 2 ;
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  VCMT_t1+VCMT_t4 ;
         TDBrecord('PG0.global').max_EP_num := 10 ; // 10 episodes !!
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= VCMT_interStim ;  // small break between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='VC_MembraneTest';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=VCMT_amp;
         TDBrecord('PG0.Exp_params').t1:=VCMT_t1;
         TDBrecord('PG0.Exp_params').t2:=VCMT_t2;
         TDBrecord('PG0.Exp_params').t3:=VCMT_t3;
         TDBrecord('PG0.Exp_params').t4:=VCMT_t4;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_VCMTstim ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, mt_initprocess, mt_process, mt_endprocess);
end;
         

procedure Set_global_RsRmCm;
begin
     TDBrecord('PG0.Exp_Params').Rs := Rs ;
     TDBrecord('PG0.Exp_Params').Rm := Rm ;
     TDBrecord('PG0.Exp_Params').Cm := Cm ;
end;

procedure VCMT_Event(n:integer);
var amplifier : string ; 
begin    
   mt_dialog.updatevar;
   case n of 
   999 : prepare_mt ; 
   998 : rsCm(VCMT_moy,rm,rs,cm,rs2,True);
   997 : Set_global_RsRmCm;
   end;
end;


procedure VCMembTest_Init; {executed only when ze choose the protocol }
begin
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

   VCMT_amp:=-5; VCMT_t1:=20; VCMT_t2:=40; VCMT_t3:=60; VCMT_t4:=80;  // values charlotte
   VCMT_interStim := 0.25 ;
   TDBrecord('PG0.global').clamp_int := 2 ;
   {then we display the channels}
   addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);

   rs_vec.create(t_single,0,-1) ; tmem_vec.create(t_single,0,-1) ; { we initialize the vector of the rs values }
   rs_graph.create(tmem_vec,rs_vec,0,0); rs_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
   //addobject(1,3,rs_graph);

   lVer.create('',0,cl_black,0); lHor.create('',0,cl_black,0);
   addObject(1,1,lVer); addObject(1,1,lHor);

   VCMT_memo.create(''); VCMT_memo.font.name:='Times New Roman'; VCMT_memo.font.size:=11;
   VCMT_memo.font.color:=rgb(0,0,0);  VCMT_memo.font.style:=fs_bold;
   addObject(1,4,VCMT_memo);

   mt_dialog.create ;
   mt_dialog.getRealA(' Pulse size (mV)',VCMT_amp,3,1,99);
   mt_dialog.getRealA('t1',VCMT_t1,3,1,99);
   mt_dialog.getRealA('t2',VCMT_t2,3,1,99);
   mt_dialog.getRealA('t3',VCMT_t3,3,1,99);
   mt_dialog.getRealA('t4',VCMT_t4,3,1,99);
   mt_dialog.getRealA('inter-Stim-interval (s)',VCMT_interStim,3,1,99);
   mt_dialog.getCommandA('  init() ',0,999);
   mt_dialog.setText('');
   mt_dialog.getCommandA(' Fit "Tau" with cursors ',0,998);
   mt_dialog.getCommandA(' Set Global Rs, Rm & Cm ',0,997);
   mt_dialog.OnEvent:=VCMT_event ;
   AddDialog(1,5,mt_dialog); 

   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
   t0_mem := 1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond;

   mt_cursor.create ; mt_cursor.DoubleCursor:=True ; mt_cursor.style:=cs_X ;
   mt_cursor.position[1]:=VCMT_t2 ; mt_cursor.position[2]:=VCMT_t2+3 ; 
   mt_cursor.InstallSource(v1);  mt_cursor.visible:=True ; 
   prepare_mt ; // first initialisation !!! 
end;


{$EDIT IC_membrane_test}
{ ==============================================================================
--------------- BUILDING THE MEMBRANE TEST IN CURRENT CLAMP --------------------
================================================================================ }

{ Membrane Test procedure : Voltage Clamp test }
var
  rm_vec : Tvector ; rm_graph : Tgraph ; 
  ICMT_amp, ICMT_t1, ICMT_t2, ICMT_interStim : real ;
  ICMT_dialog : Tdialog ; ICMT_moy : Taverage ; ICMT_fit : TcurveFitting ;
  ICMT_cursor : Tcursor ; ICMT_memo : Tmemo ;
  bridge, El, holding : real ;
  

procedure Build_ICMTstim(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin 
  vec.fill(0); vec.fill1(ICMT_amp,ICMT_t1+vec.Istart,ICMT_t2+vec.Istart);
end;
  

{procedure to calculate rm and cm, from the average voltage response...}  
procedure IC_RmCm(var vec:Tvector;var rm,cm:real;with_cursor : Boolean); 
  var
    V0,Vjump,Vs,Vbase,tau:real;
    x0:real; x,xa,xb:real; xorg:real; 
    {version valable uniquement pour un pulse n?gatif }
  begin
    V0:=vec.mean(1,ICMT_t1-2);  El :=V0 ;
    ICMT_fit.Xorigin:=ICMT_t1;

    if with_cursor then begin ICMT_fit.xstartFit:=ICMT_cursor.position[1]; ICMT_fit.XendFit:=ICMT_cursor.position[2]; end 
    else begin ICMT_fit.xstartFit:=ICMT_t1; ICMT_fit.XendFit:=ICMT_t2;end;

    ICMT_fit.execute; ICMT_fit.refresh ;
    {Model : a1*exp(a2*x)+a3 ---> a1=-Rm*I0, a3=El+Rm*I0, a2=-1/(Rm*Cm)}
    tau:=ICMT_fit.Param['a2'];  if tau<0 then tau:=-1/tau else tau:=1E9;
    Vs:=ICMT_fit.Param['a1'];
    if Vs<>0 then Rm:=-Vs/ICMT_amp*1000 else Rm:=1e9;
    Cm:=tau/Rm*1000; { pF }

    with ICMT_memo do
    begin
      lines[3]:='tau='+Rstr(tau,12,3)+' ms';
      lines[5]:='rm= '+Rstr(rm,12,3)+' Mohm';
      lines[6]:='Cm= '+Rstr(Cm,12,3)+' pF';
      lines[8]:='El= '+Rstr(El,12,3)+' mV';
    end;
    ICMT_memo.refresh;
  end;                                           


{ ------------- then, Procedures of the Acquisition Processes (see doc) ----------}   
 

procedure mtic_initprocess;
begin
  ICMT_moy.create(t_single,v1.Istart,v1.Iend);
  ICMT_moy.cpx:=1;  ICMT_moy.cpy:=1;  ICMT_moy.color:=cl_blue;
  
  ICMT_fit.create('');
  ICMT_fit.standardModel:=fm_expC1 {fm_poly5};
  ICMT_fit.initialize:=true;  ICMT_fit.reset;  ICMT_fit.setYdata(ICMT_moy);  ICMT_fit.MaxIt:=30;

  { ICMT_fit.setWorld(ICMT_moy.xmin,ICMT_moy.ymin,ICMT_moy.xmax,ICMT_moy.ymax); }
  ICMT_fit.cpx:=1;  ICMT_fit.cpy:=1;  ICMT_fit.matchVector(v1);  ICMT_fit.color:=cl_red;
  addObject(1,1,ICMT_fit);

end;

procedure mtic_process;
begin
     ICMT_moy.add(v1); {we add each episode result to the average}
end;

procedure mtic_endprocess;
begin
  addObject(1,1,ICMT_moy);
 
  IC_RmCm(ICMT_moy,rm,cm,False); { and we process the analysis}
  rm_vec.addtolist(rs); rm_vec.refresh;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
  tmem_vec.addtolist(0.001*(1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond -t0_mem)); tmem_vec.refresh;
  rm_graph.modify(tmem_vec,rm_vec,rm_vec.Istart,rm_vec.Iend); rm_graph.refresh ;
  set_dac_to_zero;
end;


procedure prepare_icmt;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 1 ; 
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  ICMT_t1+ICMT_t2 ;
         TDBrecord('PG0.global').max_EP_num :=10 ; // 10 episodes !!
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= ICMT_interStim ;  // small beak between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='IC_MembraneTest';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=ICMT_amp;
         TDBrecord('PG0.Exp_params').t1:=ICMT_t1;
         TDBrecord('PG0.Exp_params').t2:=ICMT_t2;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_ICMTstim ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, mtic_initprocess, mtic_process, mtic_endprocess);
end;

var vec_params : Tvector;

// writing the membrane parameters as a Tvector that will be loaded by other programs
procedure Set_global_RmCm;
begin
     vec_params.create(t_single,0,-1); // YOU SHOULD REMMEBER THE ORDER FOR THE OTHER PROTOCOLS
     vec_params.Addtolist(f_acq);
     TDBrecord('PG0.global').Rm := Rm ; vec_params.Addtolist(Rm) ;
     TDBrecord('PG0.global').Cm := Cm ; vec_params.Addtolist(Cm) ;
     TDBrecord('PG0.global').El := El ; vec_params.Addtolist(El) ;
     TDBrecord('PG0.global').Bridge := Bridge ;  vec_params.Addtolist(Bridge) ;
     TDBrecord('PG0.global').Holding := Holding ; vec_params.Addtolist(Holding) ;
     vec_params.Addtolist(gain1_int) ; vec_params.Addtolist(gain1) ;
     vec_params.Addtolist(gain2_int) ; vec_params.Addtolist(gain2) ;
     // now the time at which they have been calculated !
     vec_params.Addtolist(Hour);vec_params.Addtolist(Minute);vec_params.Addtolist(Second) ;
     vec_params.SaveAsObject(PathOfTheDay+'cell_params');
end;               
         
procedure ICMT_Event(n:integer);
var amplifier : string ; 
begin    
   ICMT_dialog.updatevar;
   case n of 
   999 : prepare_icmt;
   998 :IC_RmCm(ICMT_moy,rm,cm,True);
   997 :Set_global_RmCm;   
   end;
end;



procedure ICMembTest_Init; {executed only when ze choose the protocol }
begin
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

   ICMT_amp:=20; ICMT_t1:=200; ICMT_t2:=500; ICMT_interStim:=1 ; // params
   {then we display the channels}
   addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);   
   
   rm_vec.create(t_single,0,-1) ; tmem_vec.create(t_single,0,-1) ; { we initialize the vector of the rs values }
   rm_graph.create(tmem_vec,rm_vec,0,0); rm_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
   addobject(1,3,rm_graph);

   ICMT_memo.create(''); ICMT_memo.font.name:='Times New Roman'; ICMT_memo.font.size:=11;
   ICMT_memo.font.color:=rgb(0,0,0);  ICMT_memo.font.style:=fs_bold;
   addObject(1,4,ICMT_memo);

   ICMT_amp := ICMT_amp;
   ICMT_dialog.create ;
   ICMT_dialog.getRealA(' Pulse size (pA)',ICMT_amp,3,1,99);
   ICMT_dialog.getRealA(' Interstim (s)  ',ICMT_interstim,3,1,99);
   ICMT_dialog.getRealA(' t1  ',ICMT_t1,3,1,99);
   ICMT_dialog.getRealA(' t2  ',ICMT_t2,3,1,99);
   ICMT_dialog.getCommandA('  init() ',0,999);
   ICMT_dialog.setText('');
   ICMT_dialog.getCommandA(' Fit with cursors ',0,998);
   ICMT_dialog.setText('');
   ICMT_dialog.getRealA(' Bridge  (Mohm) ',bridge,3,1,99);
   ICMT_dialog.getRealA(' Holding (pA) ',holding,3,1,99);
   ICMT_dialog.getCommandA(' Write membrane parameters ',0,997);
   ICMT_dialog.OnEvent:=ICMT_event ;
   AddDialog(1,5,ICMT_dialog); 

   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
   t0_mem := 1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond;

   ICMT_cursor.create ; ICMT_cursor.Doublecursor:=True ; ICMT_cursor.style:=cs_X ;
   ICMT_cursor.position[1]:=ICMT_t1 ; ICMT_cursor.position[2]:=ICMT_t2 ; 
   ICMT_cursor.InstallSource(v1);  ICMT_cursor.visible:=True ; 
   prepare_icmt ; // first init
end;

{$EDIT perforing_monitor}
{ ==============================================================================
---------- BUILDING THE PERFORING MONITOR FOR PERFORATED PATCH -----------------
================================================================================ }

{uses the functions and the variables from the VC membrane test}

var i_pm : integer ; // integer to reset the mean every 10 measurements
 
{ ------------- then, Procedures of the Acquisition Processes (see doc) ----------}   

procedure pm_process;
begin
  VCMT_moy.add(v1); {we add each episode result to the average}
  {then we increment}
  i_pm := i_pm + 1 ;
  if i_pm>10 then 
  begin 
     i_pm := 0 ; 
     rsCm(VCMT_moy,rm,rs,cm,rs2,False); { and we process the analysis}
     rs_vec.addtolist(rs); rs_vec.refresh;
     DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
     tmem_vec.addtolist(60*Hour+Minute+Second/60+MilliSecond/60/1000-t0_mem); tmem_vec.refresh;
     VCMT_moy.reset; 
  end;
end;

procedure prepare_pm;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 2 ;
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  VCMT_t1+VCMT_t4 ;
         TDBrecord('PG0.global').max_EP_num := 0 ;  // limitless
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= VCMT_interStim ;  // small break between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='Perforing_Monitor';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=VCMT_amp;
         TDBrecord('PG0.Exp_params').t1:=VCMT_t1;
         TDBrecord('PG0.Exp_params').t2:=VCMT_t2;
         TDBrecord('PG0.Exp_params').t3:=VCMT_t3;
         TDBrecord('PG0.Exp_params').t4:=VCMT_t4;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_VCMTstim ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, mt_initprocess, pm_process, set_dac_to_zero);
end;


procedure PM_Event(n:integer);
var amplifier : string ; 
begin    
   mt_dialog.updatevar;
   case n of 
   999 : prepare_pm;
   end;
end;

procedure PerforingMonitor_Init; {executed only when ze choose the protocol }
begin
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,4,1);
  color:=cl_gray;

   if VCMT_amp=0 then begin VCMT_amp:=-5; VCMT_t1:=20; VCMT_t2:=40; VCMT_t3:=60; VCMT_t4:=80; VCMT_interStim:=0.5; end;  // in case not initialized
   {then we display the channels}
   addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);

   rs_vec.create(t_single,0,-1) ; tmem_vec.create(t_single,0,-1) ; { we initialize the vector of the rs values }
   rs_graph.create(tmem_vec,rs_vec,0,0); rs_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
   addobject(1,6,rs_vec);

   lVer.create('',0,cl_black,0); lHor.create('',0,cl_black,0);
   addObject(1,1,lVer); addObject(1,1,lHor);

   VCMT_memo.create(''); VCMT_memo.font.name:='Times New Roman'; VCMT_memo.font.size:=11;
   VCMT_memo.font.color:=rgb(0,0,0);  VCMT_memo.font.style:=fs_bold;
   addObject(1,4,VCMT_memo);

   mt_dialog.create ;
   mt_dialog.getRealA(' Pulse size (mV)',VCMT_amp,3,1,99);
   mt_dialog.getRealA('inter-Stim-interval (s)',VCMT_interStim,3,1,99);
   mt_dialog.setText('');
   mt_dialog.setText('(params taken from the VC Membrane Test)');
   mt_dialog.setText('     (to be changed there)  ');
   mt_dialog.setText('');
   mt_dialog.getCommandA('  init() ',0,999);
   mt_dialog.OnEvent:=PM_event ;
   AddDialog(1,5,mt_dialog); 

   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
   t0_mem := 1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond;

   prepare_pm;
end;



{$EDIT IV-curve}
{ ==============================================================================
--------- BUILDING THE IV-CURVE PROCEDURES AND DIALOGS -------------------------
================================================================================ }

var
   v_start    : real ;  v_step : real ; {step parameters }
   max_step : integer ; int_repet : integer ; int_step : integer ;{ index for the number of steps }
   IV_moy :  Taverage ; iv_dialog2 : Tdialog ; iv_dialog : Tdialog ;
   iv_v : Tvector ; iv_i : Tvector ; iv_graph : Tgraph ;
   del_iv, dur_iv, interstim_iv : real ;


procedure ProcessIV(seq:longint;var vec:Tvector);
var dv : real;
begin 
   dv := (seq-1)*v_step ;
   vec.fill(0); vec.fill1(v_start+dv,del_iv+vec.Istart,del_iv+dur_iv+vec.Istart);
end;

procedure iv_initprocess;
begin
   iv_i.create(t_single,0,-1);
   iv_i.X0:=v_start ; iv_i.DX := v_step ;
   iv_i.Mode := DM_LINE_DIAMOND ;
   addobject(1,4,iv_i);
end;

procedure ivcurve_process;
var tt:Tvector ;
begin 
  tt.create; Vcopy(v1,tt) ; 
  iv_i.addtolist(tt.mean(del_iv+dur_iv/2,del_iv+4*dur_iv/5));
  iv_i.invalidate ;
  //iv_i.SetWorld(iv_i.X0,iv_i.Ymin,iv_i.Xmax,iv_i.Ymax);
end;

procedure prepare_iv;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 2 ; // VC
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_iv+dur_iv ;
         TDBrecord('PG0.global').max_EP_num :=max_step ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= interstim_iv ;  // small beak between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='iv_curve';
         TDBrecord('PG0.Exp_Params').v_start:=v_start;
         TDBrecord('PG0.Exp_params').v_step:=v_step;
         TDBrecord('PG0.Exp_Params').step_number:=max_step;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := ProcessIV ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, iv_initprocess, ivcurve_process, set_dac_to_zero);
end;
         
procedure IVcurve_Event(n:integer);
var amplifier : string ; 
begin    
   iv_dialog.updatevar;
   case n of 
   201 : prepare_iv ;
   end;
end;


procedure IVcurve_Init;
begin
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

   v_start := -20; v_step :=10 ;  int_repet:=0 ; max_step := 10 ;
   interstim_iv := 1 ; del_iv := 40 ; dur_iv := 70 ;
   with iv_dialog do
   begin
      create;
      OnEvent :=IVcurve_event ;
      setText(' ==<| Parameters |> ');
      getRealA('starting value (mV)',v_start,10,3,200);
      getRealA('Step absolute (mV)',v_step,10,3,200);
      getIntegerA('Number of Steps',max_step,10,200);
      getRealA('Onset/Delay (ms)',del_iv,10,3,200);
      getRealA('Duration (ms)',dur_iv,10,3,200);
      getRealA('interstim (s)',interstim_iv,10,3,200);
      getCommandA('init protocol',0,201);
   end;
   AddDialog(1,4,iv_dialog);
   prepare_iv;
end;



{$EDIT sinusoids}
{ ==============================================================================
--------- BUILDING THE SINUSOIDS STIMULATION PROCEDURES AND DIALOGS -------------
================================================================================ }


var 
  amp_sin, freq_sin, phase_sin : real ; // for single sin
  singlesin_dialog, multiplesin_dialog, chirp_dialog : Tdialog ;
  min_amp_sin, max_amp_sin, freq_start, freq_end : real;  freq_step_num, global_freq_index : integer ; // for multiple sin
  freq_vec, amp_freq_vec : Tvector; t0_trial : real;
  continu_flag : boolean;
  chirp_amp, chirp_freq_start, chirp_freq_end, chirp_duration : real;

//=================================================
// ------- SINGLE SINUSOIDS PROTOCOL
//=================================================

procedure Build_sin(seq:longint;var vec:Tvector); {Build a sinewave into vec }
begin
vec.sinewave(amp_sin,1.0/freq_sin,phase_sin) ; 
end;

procedure prepare_singlesin;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').cont_choice := True ;  // single sinusiod in continuous mode
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='single_sin';
         TDBrecord('PG0.Exp_Params').sin_amplitude:=amp_sin;
         TDBrecord('PG0.Exp_params').frequency:=freq_sin;
         TDBrecord('PG0.Exp_Params').phase_shift:=phase_sin;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_Sin ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
end;
         
         
procedure SingleSin_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   singlesin_dialog.updatevar;
   case n of 
   201 : prepare_singlesin;
   end;
end;

//=================================================
// ------- CHIRP PROTOCOL
//=================================================

procedure Build_chirp(seq:longint;var vec:Tvector);
var ii:integer ; freq : real ;
begin
  for ii:=vec.Istart to vec.Iend do
  begin
      freq := chirp_freq_start+SQR(ii-vec.Istart)/SQR(vec.Iend-vec.Istart)*(chirp_freq_end-chirp_freq_start) ;   // freq prop. to t^2
      vec[ii] := chirp_amp*Sin(2.*PI*freq/1000.*vec.ConvX(ii));  // ms -> s
  end;
end;

procedure prepare_chirp;
var bf, ii : integer; freq : real ;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  chirp_duration ;
         TDBrecord('PG0.global').max_EP_num := 1 ; // 1 episodes !!
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= 0.2 ;  // small break between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='chirp_stimulation';
         TDBrecord('PG0.Exp_Params').chirp_amplitude:=amp_sin;
         TDBrecord('PG0.Exp_params').chirp_frequency_start:=chirp_freq_start;
         TDBrecord('PG0.Exp_Params').chirp_frequency_end:=chirp_freq_end;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_Chirp ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
end;
         
         
procedure Chirp_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   chirp_dialog.updatevar;
   case n of 
   201 : prepare_chirp;
   end;
end;

//=================================================
// ------- MULTIPLE SINUSOIDS PROTOCOL
//=================================================


var current_stop_value : integer ;
var exp_freq_vec, exp_time_vec, exp_amp_vec : Tvector; // for saving freq and time
   var string_for_saving :  string;

procedure check_for_stop_acq(n:integer);
begin
    if not continu_flag then acquisition.stop;
    if n>current_stop_value then acquisition.stop ;

end;

procedure initialize_a_single_exp;
begin
      global_freq_index :=global_freq_index+1;
      freq_sin := freq_vec[global_freq_index];
      amp_sin := amp_freq_vec[global_freq_index];
      singlesin_dialog.update; // to see the values of the amp and frequencies                                      
      multiplesin_dialog.update; // to see the valueof the frequency index                                      
      current_stop_value := Round((1+5./freq_sin)/CONTINUOUS_TIMER); // 5s min, +5periods in case of long period

       exp_freq_vec.addtolist(freq_sin); // for recording
       exp_amp_vec.addtolist(amp_sin);
       
     RTneuron.execute('finitialize()'); // reinitializing NEURON
     stimulator.Channels[1].BuildEp := Build_Sin ; 
     stimulator.initVectors;
     // then Tdetector settings, we redo it for security !
     detector.create; detector.InitTimer(v1, CONTINUOUS_TIMER);
     detector.AddEvent(check_for_stop_acq, 0.);
end;

procedure multiplesin_endprocess;
begin
   exp_time_vec.addtolist(v1.Xend);
   detector.update(v1.Iend);
   if (global_freq_index<freq_step_num) and (continu_flag=True) then
   begin
      initialize_a_single_exp;
      acquisition.InstallProcess(nil, nil, nil, multiplesin_endprocess); // need to make disapear the myinitprocess0
      if SAVING then acquisition.startandsave(True) else acquisition.start;  
   end
   else begin // we need to save the vectors
      continu_flag:=False;   // we prevent restarting !
      exp_freq_vec.SaveAsObject(acquisition.genericfilename+'_freq');
      exp_time_vec.SaveAsObject(acquisition.genericfilename+'_time');
      exp_amp_vec.SaveAsObject(acquisition.genericfilename+'_amp');
   end;
end;


procedure Shuffle_2Vector(var vec1, vec2:Tvector);   // identically shuffles 2 vectors...
var ii,i1,i2:integer; temp1, temp2:real;
begin
    for ii:=0 to 10*vec1.Iend do 
    begin
        i1:= 1+Random(vec1.Iend-1); i2:= 1+Random(vec1.Iend-1);
        temp1:= vec1[i1]; vec1[i1]:=vec1[i2]; vec1[i2]:=temp1;
        temp2:= vec2[i1]; vec2[i1]:=vec2[i2]; vec2[i2]:=temp2;
    end;
end;

procedure launch_multiple_sim; // also handle the case of the interrupted experiment
begin
   exp_freq_vec.create(t_double, 0, -1);
   exp_time_vec.create(t_double, 0, -1);
   exp_time_vec.addtolist(0);  // we add zero !
   exp_amp_vec.create(t_double, 0, -1);
   string_for_saving := TDBrecord('PG0.global').PathOfTheDay+'multiple_sin';
   InitializeChannels; // we can initialize the channels
   initialize_a_single_exp;   
   acquisition.InstallProcess(my_initprocess0, nil, nil, multiplesin_endprocess);
  if SAVING then acquisition.startandsave else acquisition.start;
end; { launch_multiple_sim }

  
procedure prepare_multiplesin;
var ii : integer ; exponent : real;
begin
     freq_vec.create(t_double, 1, freq_step_num);
     amp_freq_vec.create(t_double, 1, freq_step_num);
     for ii:=1 to freq_step_num do
     begin
          exponent := LN(freq_start)+(ii-1)/(freq_step_num-1)*(LN(freq_end)-LN(freq_start)) ;
          freq_vec[ii] := Exp(exponent) ;
          exponent := LN(min_amp_sin)+(ii-1)/(freq_step_num-1)*(LN(max_amp_sin)-LN(min_amp_sin)) ;
          amp_freq_vec[ii] := Exp(exponent) ;
     end;
     Shuffle_2Vector(freq_vec, amp_freq_vec); // then we shuffle the order of frequencies
     
     t0_trial :=0;
     SAVING := True ; 
     global_freq_index := 0 ; // we start the sequence of stimulation
     continu_flag := True;

     {we write all the relevant global informations}
     amplifier := TDBrecord('PG0.global').amplifier ;
     TDBrecord('PG0.global').cont_choice := True ;  // single sinusiod in continuous mode
     TDBrecord('PG0.global').stim := True ;
     TDBrecord('PG0.Exp_Params').clear;
     TDBrecord('PG0.Exp_Params').exp_type:='multiple_sin';
     TDBrecord('PG0.Exp_Params').freq_start:=freq_start;
     TDBrecord('PG0.Exp_params').freq_stop:=freq_end;
     TDBrecord('PG0.Exp_Params').min_amp_freq:=min_amp_sin;
     TDBrecord('PG0.Exp_params').max_amp_freq:=max_amp_sin;
     {then we initialize the stimulation}
end;
         
         
procedure MultipleSin_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   multiplesin_dialog.updatevar;
   case n of 
   201 : prepare_multiplesin;
   301 : launch_multiple_sim;
   end;
   multiplesin_dialog.update;
   maindialog.update;
end;

//=================================================
// ------- THEN DIALOG
//=================================================

procedure Init_SinDialog;
begin
    DestroyAllWindows(1);
    Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
    Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
    Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
    DivideWindow(1,3,3,1);

    amp_sin := 40 ;  freq_sin := 10 ;  phase_sin := 0 ; // for single sin
    freq_start := 0.1 ;  freq_end := 1000 ; freq_step_num := 30 ; // for multiple sin
    min_amp_sin := 30 ; max_amp_sin := 200 ;
    chirp_freq_start := 0.001 ;  chirp_freq_end := 100 ; chirp_amp := 40 ; chirp_duration := 10000 ; // for multiple sin
    
   with singlesin_dialog do
   begin
      create;
      OnEvent:=SingleSin_Event; 
      setText(' ==<| Single Sinusoid Stimulation |> ');
      getRealA('Amplitude (pA or mV)',amp_sin,10,3,200);
      getRealA('frequency (Hertz)',freq_sin,10,3,200);
      getRealA('phase shift (Rd)',phase_sin,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
      setText('');
      setText('(watch here to see multiple_sin variations)');
   end;
   AddDialog(1, 3, singlesin_dialog);
   with chirp_dialog do
   begin
      create;
      OnEvent:=Chirp_event;
      setText(' ==<| Chirp Stimulation |> ');
      getRealA('Amplitude (pA or mV)',chirp_amp,10,3,200);
      getRealA('frequency start (Hz)',chirp_freq_start,10,3,200);
      getRealA('frequency end (Hz)',chirp_freq_end,10,3,200);
      getRealA('duration (ms)',chirp_duration,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 4, chirp_dialog);
   with multiplesin_dialog do
   begin
      create;
      OnEvent:= MultipleSin_Event; 
      setText(' ==<| Multiple Sinusoids Stimulation |> ');
      getRealA('start frequency (Hz)',freq_start,10,3,200);
      getRealA('stop frequency (Hz)',freq_end,10,3,200);
      getIntegerA('number of freq steps',freq_step_num,10,200);
      setText(' Increasing amplitude with frequency ');
      getRealA(' min amplitude at low freq (pA or mV)',min_amp_sin,10,3,200);
      getRealA(' max amplitude at high freq (pA or mV)',max_amp_sin,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
      getCommandA(' START ',0,301); { OnEvent flag -> 301 }
      getIntegerA('Index of the current step',global_freq_index,10,200);
   end;
   AddDialog(1, 5, multiplesin_dialog);
end;

{$EDIT pulses}
{ ==============================================================================
--------- BUILDING THE PULSES STIMULATION PROCEDURES AND DIALOGS ---------------
================================================================================ }


{ ------------ Single Pulse ----------------------}

var amp_sp, del_sp, dur_sp :real; singlepulse_dialog:Tdialog;
procedure Build_SinglePulse(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  vec.fill(0); vec.fill1(amp_sp,del_sp+vec.Istart,del_sp+dur_sp+vec.Istart);
end;

procedure SinglePulse_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   singlepulse_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp+dur_sp ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='single_pulse';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_sp;
         TDBrecord('PG0.Exp_params').start_at:=del_sp;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_SinglePulse ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;

{ ------------ Double Pulses ----------------------}

var amp1_dp, amp2_dp, del_dp, dur1_dp, dur2_dp :real; doublepulse_dialog:Tdialog;
procedure Build_DoublePulse(seq:longint;var vec:Tvector);  
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
   vec.fill(0); 
   vec.fill1(amp1_dp,del_dp+vec.Istart,del_dp+dur1_dp+vec.Istart);
   vec.fill1(amp2_dp,del_dp+dur1_dp+vec.Istart,del_dp+dur1_dp+dur2_dp+vec.Istart);
end;

procedure DoublePulse_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   doublepulse_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration := 2*del_dp+dur1_dp+dur2_dp ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='double_pulse';
         TDBrecord('PG0.Exp_Params').pulse_amplitude1:=amp1_dp;
         TDBrecord('PG0.Exp_Params').pulse_amplitude2:=amp2_dp;
         TDBrecord('PG0.Exp_params').start_at:=del_dp;
         TDBrecord('PG0.Exp_Params').pulse_duration1:=dur1_dp;
         TDBrecord('PG0.Exp_Params').pulse_duration2:=dur2_dp;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_DoublePulse ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;


{ ------------ Triple Pulses ----------------------}

var 
   amp1_tp, amp2_tp, amp3_tp, del_tp, dur1_tp, dur2_tp, dur3_tp :real; 
   triplepulse_dialog:Tdialog;
procedure Build_TriplePulse(seq:longint;var vec:Tvector);  
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
   vec.fill(0); 
   vec.fill1(amp1_tp,del_tp+vec.Istart,del_tp+dur1_tp+vec.Istart);
   vec.fill1(amp2_tp,del_tp+dur1_tp+vec.Istart,del_tp+dur1_tp+dur2_tp+vec.Istart);
   vec.fill1(amp3_tp,del_tp+dur1_tp+dur2_tp+vec.Istart,del_tp+dur1_tp+dur2_tp+dur3_tp+vec.Istart);
end;


procedure TriplePulse_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   triplepulse_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration := 2*del_tp+dur1_tp+dur2_tp+dur3_tp ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='triple_pulse';
         TDBrecord('PG0.Exp_Params').pulse_amplitude1:=amp1_tp;
         TDBrecord('PG0.Exp_Params').pulse_amplitude2:=amp2_tp;
         TDBrecord('PG0.Exp_Params').pulse_amplitude3:=amp3_tp;
         TDBrecord('PG0.Exp_params').start_at:=del_tp;
         TDBrecord('PG0.Exp_Params').pulse_duration1:=dur1_tp;
         TDBrecord('PG0.Exp_Params').pulse_duration2:=dur2_tp;
         TDBrecord('PG0.Exp_Params').pulse_duration3:=dur3_tp;   
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_TriplePulse ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;


{ ------------ Pulse Train ----------------------}


var amp_pt, dur_pt, del_pt, inter_pt : real ;  num_pt : integer;
pulsetrain_dialog : Tdialog ;
procedure Build_PulseTrain(seq:longint;var vec:Tvector);
var ii : integer ;  
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
   vec.fill(0);
   for ii:=0 to num_pt-1 do vec.fill1(amp_pt,del_pt+ii*(dur_pt+inter_pt),del_pt+ii*(dur_pt+inter_pt)+dur_pt);
end;

procedure PulseTrain_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   pulsetrain_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration := 2*del_pt+num_pt*(dur_pt+inter_pt);
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='pulse_train';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_pt;
         TDBrecord('PG0.Exp_Params').pulse_number:=num_pt;
         TDBrecord('PG0.Exp_Params').pulse_delay:=del_pt;
         TDBrecord('PG0.Exp_Params').pulse_duration:=inter_pt;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_PulseTrain ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;


procedure Init_Pulses;
begin
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,4,1);
  color:=cl_gray;

   amp_sp := 50.0; del_sp:=400.0; dur_sp:=800.0;
   amp1_dp := 50.0; amp2_dp := -50.0; del_dp:=100.0; dur1_dp:=400.0; dur2_dp:=400.0; 
   amp1_tp := 50.0; amp2_tp := -50.0; amp3_tp := 50.0; 
   del_tp  := 50.0; dur1_tp:= 200.0; dur2_tp:= 400.0; dur3_tp:= 200.0; 
   del_pt:=100 ; amp_pt := 1000 ; num_pt := 10 ; inter_pt := 5 ;
   
   with singlepulse_dialog do
   begin
      create;
      OnEvent:=SinglePulse_Init; 
      setText(' ==<| Single Pulse Stimulation |> ');
      getRealA('Amplitude (pA or mV)',amp_sp,10,3,200);
      getRealA('Onset/Delay (ms)',del_sp,10,3,200);
      getRealA('Duration (ms)',dur_sp,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 3, singlepulse_dialog);
   with doublepulse_dialog do
   begin
      create;
      OnEvent:=DoublePulse_Init; 
      setText(' ==<| Double Pulse Stimulation |> ');
      getRealA('Amplitude 1 (pA or mV)',amp1_dp,10,3,200);
      getRealA('Amplitude 2 (pA or mV)',amp2_dp,10,3,200);
      getRealA('Onset/Delay (ms)',del_dp,10,3,200);
      getRealA('Duration 1 (ms)',dur1_dp,10,3,200);
      getRealA('Duration 2 (ms)',dur2_dp,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 4, doublepulse_dialog);
   with triplepulse_dialog do
   begin
      create;
      OnEvent:=TriplePulse_Init; 
      setText(' ==<| Triple Pulse Stimulation |> ');
      getRealA('Amplitude 1 (pA or mV)',amp1_tp,10,3,200);
      getRealA('Amplitude 2 (pA or mV)',amp2_tp,10,3,200);
      getRealA('Amplitude 3 (pA or mV)',amp3_tp,10,3,200);
      getRealA('Onset/Delay (ms)',del_tp,10,3,200);
      getRealA('Duration 1 (ms)',dur1_tp,10,3,200);
      getRealA('Duration 2 (ms)',dur2_tp,10,3,200);
      getRealA('Duration 3 (ms)',dur3_tp,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 5, triplepulse_dialog);
   with pulsetrain_dialog do
   begin
      create;
      OnEvent:=PulseTrain_Init; 
      setText(' ==<| Pulse Train Stimulation |> ');
      getRealA('Amplitude (pA or mV)',amp_pt,10,3,200);
      getRealA('Onset/Delay (ms)',del_pt,10,3,200);
      getRealA('Pulse Duration (ms)',dur_pt,10,3,200);
      getRealA('inter-Pulse Interval (ms)',inter_pt,10,3,200);
      getIntegerA('Pulse Number',num_pt,10,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 6, pulsetrain_dialog);
end;


{$EDIT fancy_ramps}
{ ==============================================================================
--------- BUILDING THE RAMP STIMULATION PROCEDURES AND DIALOGS ---------------
================================================================================ }

var 
   del_fr, amp1_fr, ramp1_fr, dur1_fr, amp2_fr, ramp2_fr, dur2_fr, amp3_fr, ramp3_fr, dur3_fr, amp4_fr, ramp4_fr, dur4_fr, isi_fr : real; 
   fancyramp_dialog1, fancyramp_dialog2, fancyramp_dialog3, fancyramp_dialog4 :Tdialog;
procedure Build_FancyRamp(seq:longint;var vec:Tvector);
var ii : longint ; tt : real ;
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
   vec.fill(0); 
   for ii:=vec.Istart to vec.Iend-1 do
   begin
   tt := vec.ConvX(ii) ;
   if (del_fr<tt) and (tt<dur1_fr+del_fr) then vec[ii]:=amp1_fr+(tt-del_fr)*ramp1_fr/dur1_fr;
   if (del_fr+dur1_fr<tt) and (tt<del_fr+dur1_fr+dur2_fr) then vec[ii]:=amp2_fr+(tt-dur1_fr-del_fr)*ramp2_fr/dur2_fr;
   if (del_fr+dur1_fr+dur2_fr<tt) and (tt<del_fr+dur1_fr+dur2_fr+dur3_fr) then vec[ii]:=amp3_fr+(tt-dur2_fr-dur1_fr-del_fr)*ramp3_fr/dur3_fr;
   if (del_fr+dur1_fr+dur2_fr+dur3_fr<=tt) and (tt<del_fr+dur1_fr+dur2_fr+dur3_fr+dur4_fr) then 
         vec[ii]:=amp4_fr+(tt-dur3_fr-dur2_fr-dur1_fr-del_fr)*ramp4_fr/dur4_fr;
   end;
end;

procedure FancyRamp_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   fancyramp_dialog1.updatevar; fancyramp_dialog2.updatevar;
   fancyramp_dialog3.updatevar; fancyramp_dialog4.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration := 2*del_fr+dur1_fr+dur2_fr+dur3_fr+dur4_fr;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').acquisitionISI := isi_fr ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='fancy_ramp';
         TDBrecord('PG0.Exp_Params').pulse_amplitude1:=amp1_fr;
         TDBrecord('PG0.Exp_Params').pulse_amplitude2:=amp2_fr;
         TDBrecord('PG0.Exp_Params').pulse_amplitude3:=amp3_fr;
         TDBrecord('PG0.Exp_Params').pulse_ramp1:=ramp1_fr;
         TDBrecord('PG0.Exp_Params').pulse_ramp2:=ramp2_fr;
         TDBrecord('PG0.Exp_Params').pulse_ramp3:=ramp3_fr;
         TDBrecord('PG0.Exp_params').start_at:=del_fr;
         TDBrecord('PG0.Exp_Params').pulse_duration1:=dur1_fr;
         TDBrecord('PG0.Exp_Params').pulse_duration2:=dur2_fr;
         TDBrecord('PG0.Exp_Params').pulse_duration3:=dur3_fr; 
        {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_FancyRamp ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         AddDialog(1, 3, fancyramp_dialog1);
         end;
   end;
   fancyramp_dialog1.update; fancyramp_dialog2.update;
   fancyramp_dialog3.update; fancyramp_dialog4.update;
end;


procedure Init_FancyRamp;
begin
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,4,1);
  color:=cl_gray;


   del_fr := 100 ; dur1_fr := 200 ; dur2_fr := 200 ; dur3_fr := 200 ; dur4_fr := 200;
   amp1_fr := 200 ; amp2_fr := -100 ; amp3_fr := -200 ; amp4_fr := 100;
   ramp1_fr := -100 ; ramp2_fr := 200 ; ramp3_fr := 300 ; ramp4_fr := 200;
   isi_fr := 0.2 ; 
  
   with fancyramp_dialog1 do
   begin
      create;
      getRealA('Onset/Delay (ms)',del_fr,10,3,200);
      setText('');
      setText(' ==========<| First Period |>========== ');
      getRealA('Amplitude Start (pA or mV)',amp1_fr,10,3,200);
      getRealA('Ramp Raise (pA or mV)',ramp1_fr,10,3,200);
      getRealA('Ramp Duration (ms)',dur1_fr,10,3,200);
      setText('');
      OnEvent:=FancyRamp_Init; 
   end;
   AddDialog(1, 3, fancyramp_dialog1);
   with fancyramp_dialog2 do
   begin
      create;
      setText('');
      setText('');
      setText(' ==========<| Second Period |>========== ');
      getRealA('Amplitude Start (pA or mV)',amp2_fr,10,3,200);
      getRealA('Ramp Raise (pA or mV)',ramp2_fr,10,3,200);
      getRealA('Ramp Duration (ms)',dur2_fr,10,3,200);
      setText('');
      OnEvent:=FancyRamp_Init; 
   end;
   AddDialog(1, 4, fancyramp_dialog2);
   with fancyramp_dialog3 do
   begin
      create;
      setText('');
      setText('');
      setText(' ==========<| Third Period |>========== ');
      getRealA('Amplitude Start (pA or mV)',amp3_fr,10,3,200);
      getRealA('Ramp Raise (pA or mV)',ramp3_fr,10,3,200);
      getRealA('Ramp Duration (ms)',dur3_fr,10,3,200);
      setText('');
      OnEvent:=FancyRamp_Init; 
   end;
   AddDialog(1, 5, fancyramp_dialog3);   
   with fancyramp_dialog4 do
   begin
      create;
      setText('');
      setText('');
      setText(' ==========<| Fourth Period |>========== ');
      getRealA('Amplitude Start (pA or mV)',amp4_fr,10,3,200);
      getRealA('Ramp Raise (pA or mV)',ramp4_fr,10,3,200);
      getRealA('Ramp Duration (ms)',dur4_fr,10,3,200);
      setText('');
      getRealA('ISI (s)',isi_fr,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
      OnEvent:=FancyRamp_Init; 
   end;
   AddDialog(1, 6, fancyramp_dialog4);
end;


{$EDIT stochastic}
{ ==============================================================================
--------- BUILDING THE STOCHASTIC STIMULATION PROCEDURES AND DIALOGS ---------------
================================================================================ }

//// ----- WHITE NOISE

var 
  wn_mean, wn_std : real ;
  wn_dialog, ou_dialog : Tdialog ;
  seed_wn, seed_ou : integer ;


procedure Build_WhiteNoise(seq:longint;var vec:Tvector); {Build a ramp into vec }
var ii:integer; x, y, u1, u2 : real ;
begin
   setRandSeed(seed_wn);
   ii:=vec.Istart ;
   while ii<vec.Iend do
   begin
      u1 :=Random ;
      u2 :=Random ;
      if (u1>0) and (u2>0) then 
      begin
         x:= SQRT(-2*LN(u1))*COS(2*PI*u2);
         y:= SQRT(-2*LN(u1))*SIN(2*PI*u2);
         vec[ii]:=wn_mean+wn_std*x;
         if ii<vec.Iend then vec[ii+1]:=wn_mean+wn_std*y;
         ii:=ii+2;
      end;
   end;
end;

procedure WN_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   wn_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := True ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='white_noise';
         TDBrecord('PG0.Exp_Params').wn_mean:=wn_mean;
         TDBrecord('PG0.Exp_params').wn_std:=wn_std;
         TDBrecord('PG0.Exp_params').wn_seed:=seed_wn;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_WhiteNOise ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;

//// ----- ORNSTEIN UHLENBECK NOISE

var ou_mean, ou_var, ou_tau : real ;

procedure Build_OU(seq:longint;var vec:Tvector); {Build a ramp into vec }
var whitenoise : Tvector ; ii, jj:integer; u1, u2, x, y,  DT, A, diffcoeff, tau_s : real ;
begin
   setRandSeed(seed_ou);
   // we generate white noise of 0 mean !
   whitenoise.create;
   whitenoise.copyobject(vec, False);
   ii:=whitenoise.Istart ;
   while ii<vec.Iend do
   begin
      u1 :=Random ;
      u2 :=Random ;
      if (u1>0) and (u2>0) then 
      begin
         x:= SQRT(-2*LN(u1))*COS(2*PI*u2);
         y:= SQRT(-2*LN(u1))*SIN(2*PI*u2);
         whitenoise[ii]:=x;
         if ii<whitenoise.Iend then whitenoise[ii+1]:=y;
         ii:=ii+2;
      end;
   end;
    tau_s := ou_tau/1000. ; // tau in s because continuous mode !
    diffcoeff := 2.*ou_var*ou_var/tau_s  ;
    DT:= vec.ConvX(vec.Istart+1)-vec.ConvX(vec.Istart); // time step in s
    A := SQRT(diffcoeff*tau_s/2.*(1-EXP(-2*DT/tau_s)));
    vec[vec.Istart]:=ou_mean;
    for jj:=vec.Istart to vec.Iend-1 do
    begin
        vec[jj+1] := ou_mean +(vec[jj]-ou_mean)*EXP(-DT/tau_s)+A*whitenoise[jj];    
    end;
end;


procedure OU_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   ou_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := True ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='ou_noise';
         TDBrecord('PG0.Exp_Params').ou_mean:=ou_mean;
         TDBrecord('PG0.Exp_params').ou_var:=ou_var;
         TDBrecord('PG0.Exp_params').ou_tau:=ou_tau;
         TDBrecord('PG0.Exp_params').ou_seed:=seed_ou;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_OU ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;

procedure Init_Stochastic;
begin
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

  wn_mean := 50 ; wn_std :=20 ;
  ou_mean := 50 ; ou_var:=20 ; ou_tau :=10 ;
 
   with wn_dialog do
   begin
      create;
      OnEvent:=WN_Event; 
      setText(' ==<| White Noise Stimulation |> ');
      getRealA('mean (pA or mV)',wn_mean,10,3,200);
      getRealA('st. deviation (pA or mV)',wn_std,10,3,200);
      getIntegerA('SEED',seed_wn,10,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 4, wn_dialog);
   with ou_dialog do
   begin
      create;
      OnEvent:=OU_Event; 
      setText(' ==<|Ornstein Uhlenbeck Stimulation |> ');
      getRealA('mean (pA or mV)',ou_mean,10,3,200);
      getRealA('st. deviation (pA or mV)',ou_var,10,3,200);
      getRealA('temp. correl. (ms)',ou_tau,10,3,200);
      getIntegerA('SEED',seed_ou,10,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 5, ou_dialog);
end;

{$EDIT F-I_curve}
{ ==============================================================================
--------- BUILDING THE F-I CURVE PROCEDURES AND DIALOGS ---------------
================================================================================ }


{ ---------the protocol ----------------------}

var amp1_fi, amp2_fi, del_fi, dur_fi, interstim_fi :real; subnsteps_fi, nsteps_fi : integer ; FIcurve_dialog:Tdialog;

procedure Build_FIcurve(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
var amp : real; n : integer ;
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  n := Floor((seq-1)/subnsteps_fi);
  amp := amp1_fi + (amp2_fi-amp1_fi)*n/(nsteps_fi-1); 
  vec.fill(0); vec.fill1(amp,del_fi+vec.Istart,del_fi+dur_fi+vec.Istart);
end;



procedure FIcurve_Init(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   FIcurve_dialog.updatevar;
   case n of 
   201 : begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_fi+dur_fi ;
         TDBrecord('PG0.global').max_EP_num := subnsteps_fi*nsteps_fi ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= interstim_fi ;  // small beak between the stims
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='FI-Curve';
         TDBrecord('PG0.Exp_Params').pulse_amplitude1:=amp1_fi;
         TDBrecord('PG0.Exp_Params').pulse_amplitude2:=amp2_fi;
         TDBrecord('PG0.Exp_Params').nsteps_level:=nsteps_fi;   
         TDBrecord('PG0.Exp_Params').nsteps_per_level:=subnsteps_fi;
         TDBrecord('PG0.Exp_params').start_at:=del_fi;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_fi;
         {then we initialize the stimulation}
         InitializeChannels; // finally, we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_FIcurve ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, nil, set_dac_to_zero);
         end;
   end;
end;


procedure Init_FIcurve;
begin
  amp1_fi := 30; amp2_fi := 50; 
  del_fi:=400.0; dur_fi:=800.0;
  nsteps_fi := 10; subnsteps_fi:=10; interstim_fi :=0.1 ;
  
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,4,1);
  color:=cl_gray;

   
   with FIcurve_dialog do
   begin
      create;
      OnEvent:=FIcurve_Init; 
      setText(' ==<| F-I Curve protocol |> ');
      getRealA('Amplitude 1 (pA or mV)',amp1_fi,10,3,200);
      getRealA('Amplitude 2 (pA or mV)',amp2_fi,10,3,200);
      getIntegerA('Number of Steps',nsteps_fi,10,200);
      getIntegerA('Steps # per level',subnsteps_fi,10,200);
      getRealA('Onset/Delay (ms)',del_fi,10,3,200);
      getRealA('Duration (ms)',dur_fi,10,3,200);
      getRealA('interstim (s)',interstim_fi,10,3,200);
      getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   end;
   AddDialog(1, 5, FIcurve_dialog);
end;

{$EDIT VNP}


{$EDIT main_dialog}
{ ==============================================================================
--------- LAUNCHING THE EXPERIMENT ----------------------------------------------
================================================================================ }

procedure launch_exp;
var amplifier: string ; init : boolean ;
begin
 
  amplifier := TDBrecord('PG0.global').amplifier ;
  if amplifier='nrn_simulation' then acquisition.Fcontinuous:=True ; // NEURON doesn;t support well episodes

  if SAVING then acquisition.startandsave else acquisition.start;
end;
 

{ ==============================================================================
--------- loading the NEURON files  --------------------------------------------
================================================================================ }
                                                              
procedure load_nrn_files;   // load the NEURON model
var clamp_int : integer ; full_path : string ;
begin
clamp_int := TDBrecord('PG0.global').clamp_int ;
if clamp_int=1 then full_path := TDBrecord('PG0.global').loadnrnPath+'Iclamp_hh.hoc'
else full_path := TDBrecord('PG0.global').loadnrnPath+'Vclamp_hh.hoc';
RTneuron.execute('load_file("'+full_path+'")');
end;

          
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure MainDialog_update(n:integer); 
var amplifier : string ;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}     
  if acquisition.IsRunning then acquisition.stop; 
  MainDialog.updatevar;
  TDBrecord('PG0.global').Gain1_int:=gain1_int;
  TDBrecord('PG0.global').Gain2_int:=gain2_int;
  TDBrecord('PG0.global').clamp_int := clamp_int; 
  TDBrecord('PG0.global').f_acq := f_acq; 
  
  case n of
    101: begin 
              Page := 1 ;     
              if (protocol_choice<>3) or (protocol_choice<>4) then mt_cursor.free ;
              if protocol_choice<>5 then icmt_cursor.free ; // we delete the cursors 
          
              case protocol_choice of
                       1 : passive_recording_init ;
                       2 : SealTest_Init;
                       3 : VCmembTest_Init;
                       4 : PerforingMonitor_Init;
                       5 : ICmembTest_Init;
                       6 : IVcurve_Init;
                       7 : Init_SinDialog;
                       8 : Init_Pulses;
                       9 : Init_Stochastic;
                       10 : Init_FancyRamp;
                       11 : Init_FIcurve;
                       
              end;
         end;
    102 : InitializeChannels; 
    111 : begin SetGain1; InitializeChannels;  end;
    112 : begin SetGain2; InitializeChannels;  end;
    200 : launch_exp;
    201 : acquisition.stop ;
    301 : comments := '';
    280 : load_nrn_files ;
    281 : RTneuron.Execute(dll_load);
    282 : RTneuron.Restart;
  end;
  gain1:=TDBrecord('PG0.global').Gain1;gain2:=TDBrecord('PG0.global').Gain2;    
  clamp_int:=TDBrecord('PG0.global').clamp_int ;   
  f_acq := TDBrecord('PG0.global').f_acq ;   
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -> dangerous for division, e.g. freq) }
var amplifier : string ;
begin
DB.create;
dll_load := TDBrecord('PG0.global').loadnrnpath ;
dll_load := 'nrn_load_dll("'+dll_load+'nrnmech.dll")';
PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ; // data path
amplifier := TDBrecord('PG0.global').amplifier ;
protocol_choice := 1;
//------------
   with MainDialog do
   begin
   create;
   OnEvent := MainDialog_update;
   getRealA(' Acquisition Freq. (kHz) ',f_acq,3,1,99);
  
   if amplifier='nrn_simulation' then 
     begin 
             getCommandA(' restart NEURON ',0,282);
             getCommandA(' load NEURON mech ',0,281);
     end;
   setText(' ================================= ');
   setText(' ---------------< Protocol Selection >----------------- ');
   setText('');
   getStringList('  PROTOCOL  ',ProtoNames,'0|1|2|3|4|5|6|7|8|9|10|11',protocol_choice,101);  { Onevent flag ->199}
   setText(' ================================= ');
   getStringList(' IC / VC  ','  Iclamp  |  Vclamp ','1|2',clamp_int,102);  { Onevent flag ->199}
   setText('');
   if amplifier='multiclamp' then 
     begin 
        setText(' ==<| GAIN  |>== ');
        getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_int,111);
        getStringListA('Secondary Output ','1 | 2 | 5 | 10 | 20 | 50 | 100',Gain2_int,112);
        setText('');
     end;
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   getBoolean('continu ? (close loop!)', continu_flag);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='Main Dialog';
  end;
Maindialog.show;
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}


var 
    already_initiated : boolean ; // to know if we need to reinitialize the TDBrecord
    global, Exp_params : TDBrecord ;   // THOSE TWO OBJECTS ARE THE ONLY TWO TO BE DELETED WHEN USED WITH TMACRO !!!!

procedure global_init;
var PathOfTheDay : string ;
begin

RTneuron.resetParams;

// THOSE TWO OBJECTS ARE THE ONLY TWO TO BE DELETED WHEN USED WITH TMACRO !!!!
global.create;  // TDBrecord('PG0.global').create ; INSTEAD
Exp_Params.create;  // TDBrecord('PG0.Exp_Params').create ; INSTEAD


DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
/// ---- CASE ON LAPTOP
{
global.amplifier:='nrn_simulation'; // choice of the amplifier
PathOfTheDay := 'Z:\home\yann\Documents\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
global.loadnrnPath := 'Z:/home/yann/work/elphy_code/nrn_files/' ;
}
/// ---- CASE ON MULTICLAMP
TDBrecord('PG0.global').amplifier:='multiclamp';
PathOfTheDay := 'D:\yann\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
TDBrecord('PG0.global').loadnrnPath := 'D:/yann/elphy_code/nrn_files/' ; 

f_acq:=10;
TDBrecord('PG0.global').f_acq:=f_acq; // in kHz

if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
TDBrecord('PG0.global').PathOfTheDay := PathOfTheDay ;
TDBrecord('PG0.global').gain1:=1; // gain of the first channel
TDBrecord('PG0.global').int_gain1:=1; // integer coding for this gain
TDBrecord('PG0.global').gain2:=1; // gain of the second channel
TDBrecord('PG0.global').int_gain2:=1; //
TDBrecord('PG0.global').clamp_int := 1; // integer that code for 1:IC, 2: VC
TDBrecord('PG0.global').cont_choice := True; // if True -> continus mode, else episode
TDBrecord('PG0.global').stim := False;  // if True acquisition.Fstimulate := True
TDBrecord('PG0.global').main_protocol:='classic_electrophy';
TDBrecord('PG0.global').protocol:='';
TDBrecord('PG0.global').saving := False ;
TDBrecord('PG0.global').episode_duration := 0 ;
TDBrecord('PG0.global').max_EP_num :=0 ;
TDBrecord('PG0.global').acquisitionISI:=1. ; 
TDBrecord('PG0.global').FadvanceON := False ;


already_initiated :=True;
InsertPage(1,'fake');DeleteAllPages('fake');InsertPage(1,'default');DeleteAllPages('default');
Color := cl_gray ;
end;

program Launch
global_init ;
SetProtocolNames;
init_windows;
Init_Main_Dialog;
passive_recording_init;

{
program set_to_zero
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;    
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);   
    stimulator.setValue(0,0,1,0);   
    stimulator.setValue(0,1,0,0);  
end; 

program Launch_from_Tmacro
MessageBox('working ?');
global_init ;
SetProtocolNames;
init_windows;
Init_Main_Dialog;
passive_recording_init;
}
