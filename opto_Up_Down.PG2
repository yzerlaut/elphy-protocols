{$EDIT START}
{========================================================================
------- Master file for the optogenetics experiments  ---------
------- phase-locked on the slow cortical oscillation ---------
========================================================================}

Const
   ProtocolCount    = 8 ; 
   OptoCount    = 8 ; 
   location	    = 'Macbook' ; // switch to 'RT-Setup' for experiments !!
   
  { ========= COMMON VARIABLES ============ }
var
   protocol_index, setup_index, location_index, opto_index, clamp_index		   : integer ; 
   setup, comments, PathOfTheDay, sep, root_dir					   : string ;
   MainDialog, dialog, StimDialog						   : Tdialog ;{ two dialogs for buttons and protocols}
   stim, closedLoop, SAVING , cont_choice					   : boolean ; 
   ProtocolName									   : array[1..protocolCount] of string; ProtoNames, ProtoNum:string;
   DB										   : Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond				   : smallint; {variables to fetch the date and time }
   gain1,gain2									   : real;
   gain1_index,gain2_index							   : integer;
   dll_load									   : string ;
   f_acq									   : real ; // parameters of the patch recording !
   hist, cum_proba								   : Tvector; 
   fraction_of_cumprob_for_Down_transition, fraction_of_cumprob_for_Up_transition  : real;
   upward_threshold, downward_threshold, spike_threshold, subsampling_freq, V0_TTL : real ;
   Up_Stim_Periodicity, Down_Stim_Periodicity					   : integer ;
   Delay_for_Up_stim, Delay_for_Down_stim					   : real ;
   Dur_for_Up_stim, Dur_for_Down_stim						   : real ;
   UD_dialog									   : Tdialog ;
   Down_cursor, Up_cursor							   : Tcursor ;
   with_LFP									   : boolean;
   Up_State_Stim, Down_State_Stim						   : boolean;
   flag_for_state_stimulation, Stim_Periodicity					   : integer;
   Delay_for_stim, Dur_for_stim							   : real;
   already_initiated								   : boolean ; // to know if we need to reinitialize the TDBrecord
   global, Exp_params								   : TDBrecord ;
   vec_params									   : Tvector ;
   LocationName									   : array[1..3] of string; LocationNames : string;
   OptoName									   : array[1..OptoCount] of string; OptoNames : string; OptoList : string;
   SetupName									   : array[1..3] of string; SetupNames : string;
   ClampName									   : array[1..2] of string; ClampNames : string;
   min_delay, max_delay, min_duration, max_duration, min_amp, max_amp		   : real ;
   num_delay, num_duration, num_amp						   : integer ;
   
   
{ ============================================================================	   
  ----- Protocol And Constants Initialization --------------------------------
  ============================================================================ }
                                             
 
procedure SetProtocolNames;
var          
  i:integer;                           
begin
   ProtocolName[1]:= 'Vm-Feedback---Spont-Act-Sampling'; 
   ProtocolName[2]:= 'Vm------------Opto-Stim-vs-Ctrl'; 
   ProtocolName[3]:= 'Vm------------Stim-at-Various-Delays'; 
   ProtocolName[4]:= 'Vm------------Stim-of-Various-Durations'; 
   ProtocolName[5]:= '*LFP* Feedback -D  Spont. Act. Sampling'; 
   ProtocolName[6]:= '*LFP* ----------D  2 Holding Protocols'; 
   ProtocolName[7]:= '*LFP* ----------D  V-Clamp for Excitation'; 
   ProtocolName[8]:= '*LFP* ----------D  V-Clamp for Inhibition'; 
   ProtoNames:=ProtocolName[1];
   ProtoNum :='0|1';
   for i:=2 to ProtocolCount do 
   begin ProtoNames:=ProtoNames+'|'+ProtocolName[i]; ProtoNum:=ProtoNum+'|'+Istr(i); end;
end;    


procedure SetLocations;
begin
   LocationName[1]:= 'RT-Setup'; 
   LocationName[2]:= 'OS-X'; 
   LocationName[3]:= 'Linux';
   LocationNames := 'RT-Setup|OS-X|Linux';
end;

procedure SetClamp;
begin
   ClampName[1]:= 'I-Clamp'; 
   ClampName[2]:= 'V-Clamp';
   ClampNames := 'I-Clamp|V-Clamp';
end;    

procedure SetSetup;
begin
   SetupName[1]:= 'RT-Setup'; 
   SetupName[2]:= 'Data-Replay'; 
   SetupName[3]:= 'NEURON-sim.';
   SetupNames := 'RT-Setup|Data-Replay|NEURON-sim.';
end;    

procedure SetOpto;
var i:integer;                           
begin
   OptoName[1]:= 'Photo-Activation l5 pyr.'; 
   OptoName[2]:= 'Photo-Inhibition l5 pyr.'; 
   OptoName[3]:= 'Photo-Activation PV+'; 
   OptoName[4]:= 'Photo-Inhibition PV+'; 
   OptoName[5]:= 'Photo-Activation SOM+'; 
   OptoName[6]:= 'Photo-Inhibition SOM+'; 
   OptoName[7]:= 'Photo-Activation l2/3 pyr.'; 
   OptoName[8]:= 'Photo-Inhibition l2/3 pyr.';
   OptoList :='0';
   for i:=1 to OptoCount do 
   begin OptoNames:=OptoNames+'|'+OptoName[i]; Optolist:=Optolist+'|'+Istr(i); end;
end;    

procedure init_windows;
begin
   DeleteAllPages('');
   InsertPage(1,'fake');DeleteAllPages('fake');
   InsertPage(1,'Intra-recording \& (phase-locked) Optogenetics');
   Page:=1; color:=cl_gray;
end;

procedure init_csts;
begin
   f_acq := 10. ; 
   upward_threshold :=-60;
   downward_threshold :=-65;
   subsampling_freq := 0.5;
   spike_threshold := -30;
   V0_TTL := 5;
   Stim_Periodicity := 2 ;
   Down_Stim_Periodicity := 2 ;
   Delay_for_stim := 30 ;
   Dur_for_stim := 100   ;
   fraction_of_cumprob_for_Down_transition := 0.3 ;
   fraction_of_cumprob_for_Up_transition := 0.6 ;
   flag_for_state_stimulation := 1;
   clamp_index :=1 ; opto_index :=1;
end;
  
{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments + Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }
 
procedure write_Exp_params; {to be used by all subsequent protocols}
begin
   TDBrecord('PG0.global').f_acq := f_acq ; 
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Down_transition := fraction_of_cumprob_for_Down_transition;
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Up_transition := fraction_of_cumprob_for_Up_transition;
   TDBrecord('PG0.Exp_params').upward_threshold := upward_threshold ;
   TDBrecord('PG0.Exp_params').downward_threshold := downward_threshold ;
   TDBrecord('PG0.Exp_params').subsampling_freq := subsampling_freq;
   TDBrecord('PG0.Exp_params').spike_threshold :=  spike_threshold;
   TDBrecord('PG0.Exp_params').V0_TTL := V0_TTL;
   TDBrecord('PG0.Exp_params').Stim_Periodicity := Stim_Periodicity ;
   TDBrecord('PG0.Exp_params').Delay_for_stim := Delay_for_stim  ;
   TDBrecord('PG0.Exp_params').Dur_for_stim := Dur_for_stim    ;
   TDBrecord('PG0.Exp_params').stim := stim;
   TDBrecord('PG0.Exp_params').closedLoop :=closedLoop;
   TDBrecord('PG0.Exp_params').gain1 := gain1 ;
   TDBrecord('PG0.Exp_params').gain2 := gain2;
   TDBrecord('PG0.Exp_params').f_acq :=f_acq;
   TDBrecord('PG0.Exp_params').with_LFP:=with_LFP;
   TDBrecord('PG0.Exp_params').Up_State_Stim:=Up_State_Stim;
   TDBrecord('PG0.Exp_params').Down_State_Stim := Down_State_Stim ;
   TDBrecord('PG0.Exp_params').flag_for_state_stimulation:=flag_for_state_stimulation;
   TDBrecord('PG0.Exp_params').setup:=SetupName[setup_index];
   TDBrecord('PG0.Exp_params').clamp := ClampName[clamp_index];
   TDBrecord('PG0.Exp_params').optogenetics := OptoName[opto_index];
   TDBrecord('PG0.Exp_params').location := LocationName[location_index];
   TDBrecord('PG0.Exp_params').min_delay:=min_delay;
   TDBrecord('PG0.Exp_params').max_delay:=max_delay;
   TDBrecord('PG0.Exp_params').num_delay:=num_delay;
   TDBrecord('PG0.Exp_params').min_duration:=min_duration;
   TDBrecord('PG0.Exp_params').max_duration:=max_duration;
   TDBrecord('PG0.Exp_params').num_duration:=num_duration;
   TDBrecord('PG0.Exp_params').min_amp:=min_amp;
   TDBrecord('PG0.Exp_params').max_amp:=max_amp;
   TDBrecord('PG0.Exp_params').num_amp:=num_amp;
end;

procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  DB.s:=''+CRLF;                                     
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_index];
  DB.Comments := comments ; {comments is a global variable }
  DB.Day := Day ; DB.Month := Month ; DB.Year := Year ;
  DB.Hour := Hour ; DB.Minute := Minute ; DB.SEcond := Second ;    
end;

procedure save_metadata_as_txt;
var jj:integer; st, st2, filename :string;
begin
   filename := TDBrecord('PG0.Exp_params').filename;
   openText(1,filename+sep+'metadata.json',false);
   writelnText(1,'{');
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    st2:=TDBrecord('PG0.global').Valstring[jj] ;
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    st2:=TDBrecord('PG0.Exp_params').Valstring[jj];
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;        
  for jj:=1 to ChannelCount do WriteLnText(1, '"DY'+Istr(jj)+'" : "'+Rstr(v[jj].dY)+'",');
  writelnText(1,'"lastline":"no_value"');
  writelnText(1,'}');
  closeText(1);                                                              
end;

procedure my_initprocess0;
var PathOfTheDay, protocol, filename  : string ; {variables to fetch the date and time }
begin
   PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ;
   protocol := ProtocolName[protocol_index];
   TDBrecord('PG0.Exp_params').exp_type := protocol;
   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
   filename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
   TDBrecord('PG0.Exp_params').filename := filename;
   acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
   FillDBinfo(DB); 
   if SAVING then begin CreateDir(filename); write_Exp_params; save_metadata_as_txt;  acquisition.writeDBfileinfo(DB); end;
end;

{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }


{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }

procedure UpdateCursor(n:integer);
begin
   downward_threshold := Down_Cursor.position[1];
   upward_threshold := Up_Cursor.position[1];
   UD_dialog.update;
end;

procedure FinalPlot_Settings;
begin
   if (ProtocolName[protocol_index]='Vm------------Opto-Stim-vs-Ctrl') or
      (ProtocolName[protocol_index]='Vm------------Stim-at-Various-Delays') or
      (ProtocolName[protocol_index]='Vm------------Stim-of-Various-Durations') or
      (ProtocolName[protocol_index]='Vm-Feedback---Spont-Act-Sampling') then
   begin
      v1.cpy:=1 ; v5.cpy := 1 ; v3.cpy:= 2 ; v4.cpy:= 2 ;  {we set the coupling value -D  to couple to future analysis} 
      v1.color := CL_Black ; v2.color := CL_Black ; v3.color := CL_Red ; v4.color := CL_Blue ; v5.color := CL_Red ;
      Down_Cursor.create ; Down_Cursor.style:=cs_Y ; DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
      Down_Cursor.InstallSource(v1); Down_Cursor.visible:=True ; Down_Cursor.position[1]:=downward_threshold ;
      Down_Cursor.OnChange:=UpdateCursor;
      Up_Cursor.create ; Up_Cursor.style:=cs_Y ;  Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
      Up_Cursor.InstallSource(v1); Up_Cursor.visible:=True ; Up_Cursor.position[1]:=upward_threshold ;
      Up_Cursor.OnChange:=UpdateCursor;
   end;
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ; v4.cpx:=1 ; v5.cpx:=1 ;
end;

procedure Set_DC_Channels_DEMO;       {NOT WORKING YET !!!!}
var 
   i : integer; f_acq:real; setup:string;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}
   RTneuron.ResetParams;
   acquisition.ChannelCount := 6; // vm, v_up, v_ttl
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);

   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }
 
   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   
   RTneuron.FadvanceON:=True; { -D  NEURON calculus }  
   RTneuron.execute('create soma, lfp');
   RTneuron.execute('insert pas');
   RTneuron.execute('e_pas=-80.');
   RTneuron.execute('L=diam=79.8');
   RTneuron.Execute('g_pas = 5e-5');
   // channel 1 --D  primary -D  Vm
   acquisition.Channels[1].NrnSymbolName:='soma.v(0.5)';
   acquisition.Channels[1].unitY:='mV' ;
   addObject(1,1,v1); v1.title:='Vm(t)';
   // leaving channel 2 for secondary !
   acquisition.Channels[2].NrnSymbolName:='Iinj';
   acquisition.Channels[2].unitY:='pA' ;
   // if 'I-clamp protocols' => addObject(1,2,v2); v2.title:='Iinj';

   {===============================================================}
   {        Articifially Emulating Vm/lFP                          }
   {===============================================================}
   if SetupName[setup_index]='NEURON-sim.' then
      begin
	 RTneuron.execute('insert WangBuszaki');
	 RTneuron.Execute('soma stim = new cExpSyn_with_static_cond(.5)');
      end
   else if SetupName[setup_index]='Data-Replay' then
      begin
	 RTneuron.execute('objref vclamp');
	 RTneuron.execute('soma vclamp = new SEClamp(.5)');
	 RTneuron.execute('vclamp.rs=1e-2');
	 RTneuron.execute('vclamp.dur1=1e9');
	 if not with_LFP then RTneuron.execute('vv.play(&vclamp.amp1, dt)');
	 if with_LFP then RTneuron.execute('vv2.play(&lfp.v(0.5), dt)');
      end;
   
   {===============================================================}
   {        Protocol Specific Mechanisms                           }
   {===============================================================}
   if (ProtocolName[protocol_index]='Vm------------Opto-Stim-vs-Ctrl') or
      (ProtocolName[protocol_index]='Vm------------Stim-at-Various-Delays') or
      (ProtocolName[protocol_index]='Vm------------Stim-of-Various-Durations') then
   begin
      RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(.5)');
      acquisition.Channels[3].NrnSymbolName:='UD_loop.V_TTL'; acquisition.Channels[3].unitY:='mV' ; v3.title:='Up_flag'; addObject(1,2,v3); 
      acquisition.Channels[4].NrnSymbolName:='UD_loop.Up_flag'; acquisition.Channels[4].unitY:='mV' ; v4.title:='TTL_Input'; addObject(1,2,v4);  
      acquisition.Channels[5].NrnSymbolName:='UD_loop.v_LP'; acquisition.Channels[5].unitY:='mV' ; v5.title:='Vm_low_passed'; addObject(1,1,v5);
   end;

   // Final graphical settings
   FinalPlot_Settings;
end;

procedure Set_DC_channels;
var
   gain1, gain2, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   clamp_index, max_ep_num, i :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 4; // for the whole classic_electrophy protocols
   RTneuron.execute('create soma, lfp');
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);
   
   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   
   // MEMBRANE POTENTIAL, SENT TO THE DYNAMIC CLAMP LOOP
   RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='soma.v(.5)';
   acquisition.Channels[1].NrnSymbolName:='soma.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
   addObject(1,1,v1); v1.title:='Vm(t)';
   // LFP
   RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='lfp.v(.5)';
   acquisition.Channels[1].NrnSymbolName:='lfp.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
   addObject(1,2,v2); v2.title:='LFP(t)';
   if closedLoop then
      begin
	 RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(.5)');
	 // CHECKING THE OUTPUT OF THE FEEDBACK LOOP , additional inputs for closed-loop setting
	 RTneuron.AdcChan[2].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[2].NrnSymbolName:='TTL_CHECK'; // secondary comes from analogous
	 RTneuron.AdcChan[3].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[3].NrnSymbolName:='UP_CHECK'; // secondary comes from analogous
	 // OUTPUT OF THE FEEDBACK LOOP                                      
	 RTneuron.DacChan[0].NrnSymbolName:='UD_loop.V_TTL'; RTneuron.DacChan[0].setScale(0,32767,0,1000.0/gain1); {command -D  I clamp, stim.i in nA !!! and opposite sign !!!}
	 RTneuron.DacChan[1].NrnSymbolName:='UD_loop.Up_flag'; RTneuron.DacChan[1].setScale(0,32767,0,1000.0/gain1); {command -D  I clamp, stim.i in nA !!! and opposite sign !!!}
	 acquisition.Channels[3].NrnSymbolName:='TTL_CHECK'; acquisition.Channels[3].unitY:='mV' ;
	 acquisition.Channels[4].NrnSymbolName:='UP_CHECK'; acquisition.Channels[4].unitY:='mV' ;
	 addObject(1,3,v3); addObject(1,3,v4); v3.title:='Online-Analysis Quantities';
      end;
   FinalPlot_Settings;
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
var Gain1_index:integer;
begin

    gain1_index:=TDBrecord('PG0.global').Gain1_index;
    case Gain1_index of
    1: TDBrecord('PG0.global').Gain1 := 1.0; 2: TDBrecord('PG0.global').Gain1 := 2.0;
    3: TDBrecord('PG0.global').Gain1 := 5.0; 4: TDBrecord('PG0.global').Gain1 := 10.0;
    5: TDBrecord('PG0.global').Gain1 := 20.0; 6: TDBrecord('PG0.global').Gain1 := 50.0;
    7: TDBrecord('PG0.global').Gain1 := 100.0; 8: TDBrecord('PG0.global').Gain1 := 200.0;
    9: TDBrecord('PG0.global').Gain1 := 500.0; 10: TDBrecord('PG0.global').Gain1 := 1000.0;
    11: TDBrecord('PG0.global').Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure InitializeChannels;
var setup : string ;
begin
   setup := TDBrecord('PG0.global').setup ;
   if setup='RT-Setup' then Set_DC_channels else Set_DC_channels_DEMO;
end;

procedure set_dac_to_zero;
begin
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;  
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);   
    stimulator.setValue(0,0,1,0);   
    stimulator.setValue(0,1,0,0);  
end; 
end;

procedure Save_Vector_From_NEURON(neuron_vector, filename: string);
var nrnPath, protocol :  string;
begin
   protocol := ProtocolName[protocol_index];
   nrnPath := TDBrecord('PG0.global').nrnPathOfTheDay ;
   nrnPath := nrnPath+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol;
   RTneuron.execute('objref ff, vv');
   RTneuron.execute('vv = new Vector()');
   RTneuron.execute('ff = new File()');
   RTneuron.execute('ff.wopen("'+nrnPath+'/'+filename+'")');
   RTneuron.execute('i=0');
   RTneuron.execute('for i=0,1999 {vv.append('+neuron_vector+'[i])}');
   RTneuron.execute('vv.printf(ff)');
   RTneuron.execute('ff.close()');
end;

procedure Get_Transitions_Times;
begin
   if closedLoop then
      begin
	 Save_Vector_From_NEURON('UD_loop.up_transition_vec', 'up_transitions.txt');
	 Save_Vector_From_NEURON('UD_loop.down_transition_vec', 'down_transitions.txt');
	 Save_Vector_From_NEURON('UD_loop.stim_vec', 'stim_flag.txt');
	 Save_Vector_From_NEURON('UD_loop.delay_vec', 'delays.txt');
	 Save_Vector_From_NEURON('UD_loop.duration_vec', 'durations.txt');
      end;
end;

{$EDIT artificial-UD}
{ ==============================================================================
--------------- CREATING ARTIFICIAL Up & Down States --------------------
================================================================================ }

procedure Initialize_Simulated_Up_and_Down_States;
      // we set a sequence of Up and Down states !!
begin
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim(.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('soma nsI = new NetStim(.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.delay = 0');
   RTneuron.execute('nsE.seed(0)');
   RTneuron.execute('nsI.seed(2)');
   {synaptic weights}
   RTneuron.execute('ncE.weight = 0.003');
   RTneuron.execute('ncI.weight = -0.003'); {NEGATIVE FLAG !!!}
   {then synaptic times}
   RTneuron.execute('stim.tau = 5');
   {synaptic reversal potential}
   RTneuron.execute('stim.DrivingForce = 30');
   { static conductance }
   RTneuron.execute('stim.muV = -55');
   RTneuron.execute('stim.Gs = 0.4');
   {firing frequencies}
   RTneuron.execute('nsE.interval = 0.1');
   RTneuron.execute('nsI.interval = 0.1');
   {current to bring at mean}
   RTneuron.execute('stim.I0 = 0.3');
   RTneuron.execute('objref fih, rand, cvode');
   RTneuron.execute('rand = new Random()');
   RTneuron.execute('rand.normal(400,200*200)');
   RTneuron.execute('cvode = new CVode()');
   RTneuron.execute('fih = new FInitializeHandler(1, "f1()")');
   RTneuron.execute('tt = 0.');
   RTneuron.execute('proc f1() {for i=0, 100 {tt = tt+rand.repick() print tt cvode.event(tt, "stim.stop_flag=(1-stim.stop_flag)")}}');
end;

{$EDIT Spont-act-sampling}
{ ==============================================================================
--------------- Spontaneous activity sampling --------------------
================================================================================ }

procedure Calculate_Threshold_for_Vm;
var i0, ii : integer; 
begin
   // we create the vectors
   hist.create(t_single,0,100); hist.x0:=-80.;hist.dx:=1.;
   cum_proba.create(t_single,0,100); cum_proba.x0:=-80.;cum_proba.dx:=1.;
   // ========== CORE OF THE CALCULATION =========== //
   Distri(v1, hist, -80, 20);
   // RE-include this code if you want to start the cum. proba form the Peak of the Down state
   ii := 0;
   while ((hist.yvalue[ii]<0.98*hist.ymax) and (ii<hist.Iend)) do ii := ii+1;
   hist.fill1(0., -80., hist.convx(ii+1)); // filling all values previous to Down state peak with 0 values
   DistriFunction(hist, cum_proba); // cumulative distribution
   ii:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Down_transition);
   downward_threshold := cum_proba.convx(ii+1);
   i0:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Up_transition);
   upward_threshold := cum_proba.convx(i0+1);
   UD_dialog.update;
   v1.refresh;
end;

procedure ShowHistograms;
begin
   Down_Cursor.create ; Down_Cursor.style:=cs_X ;
   DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
   Down_Cursor.InstallSource(hist); Down_Cursor.visible:=True ;
   Down_Cursor.position[1]:=downward_threshold ; 
   Down_Cursor.OnChange:=UpdateCursor;
   Up_Cursor.create ; Up_Cursor.style:=cs_X ;
   Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
   Up_Cursor.InstallSource(hist); Up_Cursor.visible:=True ;
   Up_Cursor.position[1]:=upward_threshold ;
   Up_Cursor.OnChange:=UpdateCursor;
   hist.SetWorld(-80, 20, 0, hist.ymax);
   cum_proba.SetWorld(-80, 20, 0, cum_proba.ymax);
   addObject(1,2,hist); 
   addObject(1,3,cum_proba); 
end;

procedure Set_Threshold;
begin
   FInalPLot_settings;
   v1.refresh;
end;

procedure SAS_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : Calculate_Threshold_for_Vm;
     202 : Set_Threshold;
     203 : ShowHistograms;
     end;
     UD_dialog.update;
end;  

procedure InitSASdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), Round(PageWidth/2), PageHeight);
   Definewindow(1, Round(PageWidth/2), Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   TDBrecord('PG0.Exp_params').exp_type := 'Spont-Act-Sampling' ;
   with UD_dialog do
   begin
      create;
      OnEvent:=SAS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==* Analyzing the *Vm* during Slow Oscill.  *==__');
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('Subsampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('fraction of cum. proba for transition to Down',fraction_of_cumprob_for_Down_transition,10,3,200);
      getRealA('fraction of cum. proba for transition to Up',fraction_of_cumprob_for_Up_transition,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV)',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV)',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('');
      getCommandA(' Calculate optimal threshold',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Set cursors',0,202);
      getCommandA('Show Histograms',0,203);
      Caption:='Sampling Spont. Act.';
      Show;
   end;
end;


{$EDIT Vm-feedback-loop-init}
{ ==============================================================================
--------------- INITIALIZE A SINGLE PROTOCOL (COMMON All-Vm Feedback) -----------
================================================================================ }

procedure Init_Vm_feedback_loop;
var setup : string ; i : integer;
begin
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
   RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   RTneuron.execute('UD_loop.subsampling_freq = '+Rstr(subsampling_freq));
   RTneuron.execute('UD_loop.spike_threshold = '+Rstr(spike_threshold));
   RTneuron.execute('UD_loop.V0_TTL = '+Rstr(V0_TTL));
   
   // the choice is here !
   if Up_State_Stim then RTneuron.execute('UD_loop.up_stimulation = 0') else RTneuron.execute('UD_loop.up_stimulation = -1');
   if Down_State_Stim then RTneuron.execute('UD_loop.down_stimulation = 0') else RTneuron.execute('UD_loop.down_stimulation = -1');

   if (ProtocolName[protocol_index]='Vm------------Opto-Stim-vs-Ctrl') then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
      end;
   if (ProtocolName[protocol_index]='Vm------------Opto-Stim-vs-Ctrl') then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
      end;
   setup := TDBrecord('PG0.global').setup ;
   if setup='NEURON-sim.' then Initialize_Simulated_Up_and_Down_States;
   // the initialization
   RTneuron.execute('finitialize(-80.)');
end;

{$EDIT Single-state-test}
{ ==============================================================================
--------------- PHASE-LOCKED OPTOGENTICS IN UP-or-DOWN-STATE  ------------------
================================================================================ }

procedure UD_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False;
		 TDBrecord('PG0.Exp_params').exp_type := 'Opto-stim-during-Up-state'; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; 
		 TDBrecord('PG0.Exp_params').exp_type := 'Opto-stim-during-Down-state'; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     end;
     UD_dialog.update;
end;  

procedure InitUDdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   TDBrecord('PG0.Exp_params').exp_type := 'Up-state-stim' ;
   with UD_dialog do
   begin
      create;
      OnEvent:=UD_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Simulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> TTL parameters :');
      getRealA('TTL input value (mV) ',V0_TTL,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity,6,200);
      getRealA('Delay after Down-state start (ms) ', Delay_for_stim,10,3,200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;



{$EDIT Main_dialog}
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure Update_Setup;
begin
   TDBrecord('PG0.global').setup:=SetupName[setup_index];
end;

procedure Update_Clamp;
begin
   TDBrecord('PG0.global').clamp:=ClampName[clamp_index];
end;

procedure Update_Opto;
begin
   TDBrecord('PG0.global').optogenetics:=OptoName[opto_index];
end;

procedure Update_Location;
var Hour2,Minute2,Second2,MilliSecond2 : smallint;
begin
   TDBrecord('PG0.global').location:=LocationName[location_index]; 
   DecodeDateTime(Now,Year,Month,Day,Hour2,Minute2,Second2,MilliSecond2); {function to fetch date and time}
   case location_index of
     1: begin {setup}
	   PathOfTheDay := 'D:\Yann\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='\';
	   TDBrecord('PG0.global').loadnrnPath := 'D:/home/yann/work/elphy/nrn_files/' ; 
	   TDBrecord('PG0.global').nrnPathOfTheDay := 'D:/Yann/DATA/'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'/'; 
	end; 
     2: begin {osx}
	   PathOfTheDay := 'Z:\Users\yzerlaut\DATA\debuging_data\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='/';
	   TDBrecord('PG0.global').loadnrnPath := 'Z:/Users/yzerlaut/work/elphy/nrn_files/' ; 
	   TDBrecord('PG0.global').nrnPathOfTheDay := 'Z:/Users/yzerlaut/DATA/debuging_data/'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'/'; 
	end;
     3: begin {linux}
	   PathOfTheDay := 'Z:\home\yann\DATA\debuging_data\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
	   sep :='/';
	   TDBrecord('PG0.global').loadnrnPath := 'Z:/home/yann/work/elphy/nrn_files/' ; 
	   TDBrecord('PG0.global').nrnPathOfTheDay := 'Z:/home/yann/DATA/debuging_data/'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'/'; 
	end;
    end;
   if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
   TDBrecord('PG0.global').PathOfTheDay := PathOfTheDay ;
end;

procedure loadNRNmech;
begin
   dll_load := TDBrecord('PG0.global').loadnrnpath ;
   dll_load := 'nrn_load_dll("'+dll_load+'nrnmech.dll")';
   RTneuron.Execute(dll_load);
end;

procedure load_fake_Vm;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\Cell1_13909028.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/';
      txtfile2:=txtfile2+memo[memo.count];
      RTneuron.execute('objref ff, vv'); RTneuron.execute('vv = new Vector()');
      RTneuron.execute('ff = new File()'); RTneuron.execute('ff.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv.scanf(ff)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure load_fake_LFP;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\LFP1_25632003.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/';
      txtfile2:=txtfile2+memo[memo.count];
      RTneuron.execute('objref ff2, vv2'); RTneuron.execute('vv2 = new Vector()');
      RTneuron.execute('ff2 = new File()'); RTneuron.execute('ff2.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv2.scanf(ff2)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure MainDialog_update(n:integer); 
var proto : string ; memo : Tmemo; ii : integer;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}     
  { if acquisition.IsRunning then acquisition.stop;  }
  MainDialog.updatevar;
  TDBrecord('PG0.global').Gain1_index:=gain1_index;
  TDBrecord('PG0.global').Gain2_index:=gain2_index;
  TDBrecord('PG0.global').clamp_index := clamp_index; 
  TDBrecord('PG0.global').f_acq := f_acq; 
  case n of
    101: begin
	    proto := ProtocolName[protocol_index];
	    if proto='Vm-Feedback---Spont-Act-Sampling'
	       then begin closedLoop:=False ; with_LFP :=False ; InitSASdialog; end
	    else if proto='Vm------------Opto-Stim-vs-Ctrl'
	       then begin closedLoop:=True; with_LFP :=False ; InitUDdialog; end;
	    // we initialize the experiment with the default parameters !
	    InitializeChannels; Init_Vm_feedback_loop;	    
         end;
    333	: load_fake_Vm;
    334	: load_fake_LFP;
    37: Update_Setup;
    38: Update_Location;
    39: Update_Opto;
    40: Update_Clamp;
    111 : SetGain1; 
    200 : begin
	     acquisition.InstallProcess(my_initprocess0, nil, nil, Get_Transitions_Times);
	     if SAVING then acquisition.startandsave else acquisition.start;
	  end;
    201 : acquisition.stop ;
    301 : comments := '';
    281 : LoadNRNmech;
    282 : begin RTneuron.Restart; loadNRNmech; end;
  end;
  gain1:=TDBrecord('PG0.global').Gain1;
  gain2:=TDBrecord('PG0.global').Gain2;    
  clamp_index:=TDBrecord('PG0.global').clamp_index ;      
  f_acq := TDBrecord('PG0.global').f_acq ; 
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -D  dangerous for division, e.g. freq) }
var setup : string ;
begin
DB.create;
protocol_index := 0;
//------------
   with MainDialog do
   begin
      create;
      getStringList(' Setup : ', SetupNames,'0|1|2|3',setup_index,37);  { Onevent flag ->199}
      getStringList(' Location : ', LocationNames,'0|1|2|3',location_index,38);  { Onevent flag ->199}
      getStringList(' Optogenetics : ', OptoNames, OptoList, opto_index, 39);  { Onevent flag ->199}
      getStringList(' Ampli-Mode : ', ClampNames, '0|1|2', clamp_index,40);  { Onevent flag ->199}
      if setup_index=2 then getCommandA('load *Vm* Datafile for Replay ',0,333);
      if setup_index=2 then getCommandA('load *LFP* Datafile for Replay ',0,334);
      getRealA('Acquisition freq. (kHz)',f_acq,3,2,785);
      setText('');
      OnEvent := MainDialog_update;
   
      getCommandA(' restart NEURON ',0,282);
      getCommandA(' load NEURON mech ',0,281);
      //getCommandA(' load NEURON model ',0,280); 

      setText(' ================================= ');
      setText(' ---------------< Protocol Selection >----------------- ');
      setText('');
      getStringList('  PROTOCOL  ', ProtoNames, Protonum, protocol_index,101);  { Onevent flag ->199}
   setText(' ================================= ');
   setText('');
   setText(' ==<| GAIN  |>== ');
   getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_index,111);
   setText('');
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='RT-optogenetics';
  end;
Maindialog.show;
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}


procedure global_init;
var PathOfTheDay : string ;
begin

   RTneuron.resetParams;
   SetLocations; SetSetup; SetOpto; SetClamp;SetProtocolNames;
   if location='RT-Setup' then begin setup_index :=1; location_index:=1 ; SAVING:=True; end;
   if location='Macbook' then begin setup_index :=2; location_index:=2 ; SAVING:=False; end;
   global.create; Exp_Params.create;
   Update_Location; Update_Setup;
 
   // those 3 parameters are obvious, we just keep them for compatibility with the other conventions
   clamp_index := 1;
   TDBrecord('PG0.global').clamp_index := clamp_index; // integer that code for 1:IC, 2: VC
   TDBrecord('PG0.global').cont_choice := True; // if True -D  continus mode, else episode
   TDBrecord('PG0.global').stim := False;  // if True acquisition.Fstimulate := True
   TDBrecord('PG0.global').main_protocol:='';
   TDBrecord('PG0.global').protocol:='RT-opto-Up-Down';
   TDBrecord('PG0.Exp_params').exp_type := 'blank-exp';
   TDBrecord('PG0.global').saving := True ;
   gain1 :=1 ; gain2 := 1. ;
   TDBrecord('PG0.global').gain1 := gain1 ;  TDBrecord('PG0.global').gain2 := gain2 ;
   TDBrecord('PG0.global').FadvanceON := True ;  
   Color := cl_gray ;
end;

program Launch
{ see the documentation, for the details of the acquisition and RTneuron functions }
global_init ;
init_csts;
Init_Main_Dialog;
RTneuron.resetParams;
loadNRNmech;
