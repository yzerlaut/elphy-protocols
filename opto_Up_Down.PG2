{$EDIT TF_START}
{========================================================================
------- Master file for the transfer functions experiments ---------
========================================================================}

Const
   ProtocolCount    = 2 ; 
   CONTINUOUS_TIMER = 0.5 ; {timer for Tdetect update}
   location	    = 'Setup' ;
   N_pause	    =  7 ; {N_pause*CONTINUOUS_TIMER = time between protocols...}
   START_I_CST = 1000; {in ms, for the break in between points}
   STOP_I_CST = 2500 ; {in ms}
   threshold_for_spikes = -30 ;  {for online counting of spikes}
   
var  { ========= COMMON VARIABLES ============ }
   protocol_choice : integer; 
   amplifier, comments, PathOfTheDay, root_dir : string ; 
   MainDialog, dialog, StimDialog : Tdialog ;{ two dialogs for buttons and protocols}
   stim, SAVING : boolean ; 
   ProtocolName:array[1..protocolCount] of string; ProtoNames, ProtoNum:string;
   DB:Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; {variables to fetch the date and time }
   gain1,gain2 : real; gain1_int,gain2_int,clamp_int:integer;cont_choice:boolean;  
   dll_load : string ;
   detector, time_detector : Tdetector ;
   Rm, Cm, Bridge, El, Holding, f_acq : real ; // parameters of the patch recording !
var
   TFdialog : Tdialog;  spiketimes : Tvector ;
   stop_flag : boolean ;   max_spikes_number : integer ;
var global_step : integer ;  continu_flag : boolean ;
var max_authorized_time :real;
var recorded_fout : Tvector ;
var rest_flag,jump_to_next:boolean ; // flag pour alterner de la stimulation et des periods de repos...

{ ============================================================================
 ---- Protocol names and graphical settings ----------------------------------
 ============================================================================= }
                                             
 
procedure SetProtocolNames;
var          
  i:integer;                           
begin
  ProtocolName[1]:= 'Up-state stim.'; 
  ProtocolName[2]:= 'Down-state stim.';
  ProtoNames:=ProtocolName[1];ProtoNum :='0|1';
  for i:=2 to ProtocolCount do 
  begin ProtoNames:=ProtoNames+'|'+ProtocolName[i];
  ProtoNum:=ProtoNum+'|'+Istr(i); end;
end;    


procedure init_windows;
begin
  deleteallpages('default');
  InsertPage(1,'Vm-recording during Phase-Locked Optogenetics');
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/2.));
   Definewindow(1, 0, Round(PageHeight/2.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
end;


{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments+Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }
 

procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  DB.s:=''+CRLF;                                     
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_choice];
  DB.Comments := comments ; {comments is a global variable }
  DB.Day := Day ; DB.Month := Month ; DB.Year := Year ;
  DB.Hour := Hour ; DB.Minute := Minute ; DB.SEcond := Second ;    
end;

procedure save_metadata_as_txt;
var jj:integer; st, st2:string;
begin
   openText(1,acquisition.genericFilename+'.json',false);
   writelnText(1,'{');
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    st2:=TDBrecord('PG0.global').Valstring[jj] ;
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    st2:=TDBrecord('PG0.Exp_params').Valstring[jj];
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;        
  for jj:=1 to ChannelCount do WriteLnText(1, '"DY'+Istr(jj)+'" : "'+Rstr(v[jj].dY)+'",');
  writelnText(1,'"lastline":"no_value"');
  writelnText(1,'}');
  closeText(1);                                                              
end;

procedure my_initprocess0;
var Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; PathOfTheDay, sep, protocol  : string ; {variables to fetch the date and time }
begin
  PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ;
  protocol := TDBrecord('PG0.Exp_params').exp_type ;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
  acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+  '_'+protocol ;
  FillDBinfo(DB); 
  if acquisition.saving then  acquisition.writeDBfileinfo(DB);
end;

{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }


{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }



procedure Set_DC_Channels_DEMO;       {NOT WORKING YET !!!!}
var 
   i : integer; f_acq:real;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 2; // vm, Iinj

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);

   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }
 
   RTneuron.FadvanceON:=True; { in dynamic clamp -> NEURON calculus }  
   RTneuron.execute('create soma');
   RTneuron.execute('insert pas');
   RTneuron.execute('e_pas = '+Rstr(El));
   RTneuron.execute('L=diam=79.8');
   RTneuron.Execute('g_pas = 5e-5');
   RTneuron.execute('insert WangBuszaki');
   
   RTneuron.Execute('objref stim');
   RTneuron.Execute('soma stim = new opto_Up_Down(.5)');
   for i:=1 to 3 do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   acquisition.Channels[1].unitY:='mV'; addObject(1,1,v1); v1.title:='V_intra(t)';
   acquisition.Channels[1].NrnSymbolName:='soma.v(.5)';
   acquisition.Channels[2].unitY:='nA'; addObject(1,2,v2); v1.title:='Iinj(t)';
   acquisition.Channels[2].NrnSymbolName:='stim.i';
   acquisition.Channels[3].unitY:='nA'; addObject(1,2,v3); v3.title:='Icst';
   acquisition.Channels[3].NrnSymbolName:='stim.Icst';
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ; 
   v1.cpy:=1 ; v2.cpy := 2 ; v3.cpy:=2 ; {we set the coupling value -> to couple to future analysis} 
   v2.color := CL_Olive ; v3.color := CL_Blue ;
end;

procedure Set_DC_channels;
var 
   gain1, gain2, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   Clamp_int, max_ep_num, i :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 6; // for the whole classic_electrophy protocols

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);
   
   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

   RTneuron.Execute('create soma');
   RTneuron.Execute('objref stim');
   RTneuron.Execute('soma stim = new opto_Up_Down(.5)');
   
   for i:=1 to 3 do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   
   // MEMBRANE POTENTIAL, SENT TO THE DYNAMIC CLAMP LOOP
   RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='soma.v(.5)';
   // CHECKING THE OUTPUT OF THE FEEDBACK LOOP , additional inputs for closed-loop setting
   RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='TTL_CHECK'; // secondary comes from analogous
   RTneuron.AdcChan[2].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[2].NrnSymbolName:='UP_CHECK'; // secondary comes from analogous
   
   // OUTPUT OF THE FEEDBACK LOOP                                      
   RTneuron.DacChan[0].NrnSymbolName:='stim.V_TTL'; RTneuron.DacChan[0].setScale(0,32767,0,1000.0/gain1); {command -> I clamp, stim.i in nA !!! and opposite sign !!!}
   RTneuron.DacChan[1].NrnSymbolName:='stim.Up_flag'; RTneuron.DacChan[1].setScale(0,32767,0,1000.0/gain1); {command -> I clamp, stim.i in nA !!! and opposite sign !!!}
   
   acquisition.Channels[1].NrnSymbolName:='soma.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
   acquisition.Channels[2].NrnSymbolName:='TTL_CHECK'; acquisition.Channels[2].unitY:='mV' ;
   acquisition.Channels[3].NrnSymbolName:='UP_CHECK)'; acquisition.Channels[3].unitY:='mV' ;
   addObject(1,1,v1); v1.title:='Vm(t)';
   addObject(1,2,v2); addObject(1,2,v3); v2.title:='Online Analysis Quantities';
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ;
   v1.cpy:=1 ; v2.cpy := 2 ; v3.cpy:= 2 ;  {we set the coupling value -> to couple to future analysis} 
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
var Gain1_int:integer;
begin

    gain1_int:=TDBrecord('PG0.global').Gain1_int;
    case Gain1_int of
    1: TDBrecord('PG0.global').Gain1 := 1.0; 2: TDBrecord('PG0.global').Gain1 := 2.0;
    3: TDBrecord('PG0.global').Gain1 := 5.0; 4: TDBrecord('PG0.global').Gain1 := 10.0;
    5: TDBrecord('PG0.global').Gain1 := 20.0; 6: TDBrecord('PG0.global').Gain1 := 50.0;
    7: TDBrecord('PG0.global').Gain1 := 100.0; 8: TDBrecord('PG0.global').Gain1 := 200.0;
    9: TDBrecord('PG0.global').Gain1 := 500.0; 10: TDBrecord('PG0.global').Gain1 := 1000.0;
    11: TDBrecord('PG0.global').Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure SetGain2;
var Gain2_int:integer;
begin
    gain2_int:=TDBrecord('PG0.global').Gain2_int;
    case Gain2_int of
    1: TDBrecord('PG0.global').Gain2 := 1.0;   2: TDBrecord('PG0.global').Gain2 := 2.0; 
    3: TDBrecord('PG0.global').Gain2 := 5.0;  4: TDBrecord('PG0.global').Gain2 := 10.0;
    5: TDBrecord('PG0.global').Gain2 := 20.0;   6: TDBrecord('PG0.global').Gain2 := 50.0; 
    7: TDBrecord('PG0.global').Gain2 := 100.0;
    end;
end;   {SetGain2}


procedure InitializeChannels;
var amplifier : string ;
begin
         amplifier := TDBrecord('PG0.global').amplifier ;
         if amplifier='nrn_simulation' then Set_DC_channels_DEMO;
         if amplifier='multiclamp' then Set_DC_channels;
         time_detector.create ; detector.create ;   // needs to be created
end;


procedure set_dac_to_zero;
begin
RTneuron.execute('stim.stop_flag=1'); {trying to use the stop flag !!!}
RTneuron.execute('fadvance()');
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;  
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);   
    stimulator.setValue(0,0,1,0);   
    stimulator.setValue(0,1,0,0);  
end; 
end;


ProcessCont  // COMMON to all continuous processes
begin
time_detector.update(v1.Iend);
detector.update(v1.Iend);
end;

{$EDIT Up-state-test}
{ ==============================================================================
--------------- BUILDING THE MEMBRANE TEST IN VOLTAGE CLAMP --------------------
================================================================================ }

{ Membrane Test procedure : Voltage Clamp test }
var
  UD_threshold, spike_threshold : real ;
	Up_Stim_Periodicity, Down_Stim_Periodicity :integer ;
	Delay_for_Up_stim, Delay_for_Down_stim : real ;
	Dur_for_Up_stim, Dur_for_Down_stim : real ;
  UD_dialog : Tdialog ; 
  UD_cursor : Tcursor ;
  
procedure write_Exp_params; {to be used by all subsequent protocols}
begin
   TDBrecord('PG0.global').f_acq := f_acq ; 
   TDBrecord('PG0.Exp_params').UD_threshold := UD_threshold ;
   TDBrecord('PG0.Exp_params').spike_threshold :=  spike_threshold;
	 TDBrecord('PG0.Exp_params').Up_Stim_Periodicity := Up_Stim_Periodicity ;
   TDBrecord('PG0.Exp_params').Down_Stim_Periodicity := Down_Stim_Periodicity  ;
	 TDBrecord('PG0.Exp_params').Delay_for_Up_stim := Delay_for_Up_stim  ;
   TDBrecord('PG0.Exp_params').Delay_for_Down_stim  := Delay_for_Down_stim  ;
	 TDBrecord('PG0.Exp_params').Dur_for_Up_stim := Dur_for_Up_stim    ;
   TDBrecord('PG0.Exp_params').Dur_for_Down_stim := Dur_for_Down_stim   ;
end;



procedure Init_single_exp;
begin         
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('stim.UD_threshold = '+Rstr(UD_threshold));
   RTneuron.execute('stim.spike_threshold = '+Rstr(spike_threshold));
   RTneuron.execute('stim.Up_Stim_Periodicity = '+Istr(Up_Stim_Periodicity));
   RTneuron.execute('stim.Down_Stim_Periodicity = '+Istr(Down_Stim_Periodicity));
   RTneuron.execute('stim.Delay_for_Up_stim = '+Rstr(Delay_for_Up_stim));
   RTneuron.execute('stim.Delay_for_Up_stim = '+Rstr(Delay_for_Up_stim));
   RTneuron.execute('stim.Dur_for_Up_stim = '+Rstr(Dur_for_Up_stim));
   RTneuron.execute('stim.Dur_for_Down_stim = '+Rstr(Dur_for_Down_stim));

   RTneuron.execute('finitialize()');
end;

procedure UD_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : MessageBox('nothing yet');
     end;
     UD_dialog.update;
end;  


procedure InitUDdialog;
begin
   TDBrecord('PG0.Exp_params').exp_type := 'Up-state-stim' ;
   with UD_dialog do
   begin
      create;
      OnEvent:=UD_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Phase-locked stim in the Up state');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_muV,10,3,200);
      getRealA(' clamping the std dev. (mV)',clamp_sV,10,3,200);
      getRealA(' clamping the Gtot/gL ratio',clamp_muGn,10,3,200);
      setText('______________________________________');
      getRealA('min. synaptic time ratio',min_Ts_ratio,10,3,200);
      getRealA('max. synaptic time ratio',max_Ts_ratio,10,3,200);
      setText('______________________________________');
      getRealA(' Driving Force (mV)',Driving_Force,10,3,200);
      getIntegerA('Number of points ',point_number,6,200);
      getboolean('Checking the conductance ??', check_for_conductance);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Autocorrelation time Impact';
      Show;
   end;
end;

{$EDIT Gtot_and_Tv_effect_on_spiking} 
{ ==============================================================================
---- How much does the mean somatic conductance might have an influence on the firing freq ---
================================================================================ }

procedure gen_GTVE_input; 
var ii : integer ; muGn, dmuGn : real;
begin

   initialize_stimulation_vectors;
    
   dmuGn := (max_muGn-min_muGn)/(point_number-1) ;  // nS
   for ii:=0 to point_number-1 do 
   begin
      muGn := min_muGn+ii*dmuGn ; {in nanoSiemens,  shuffled through vec_i}

      params_variations_calc(muGn, clamp_muV, clamp_sV, clamp_Ts_ratio, Driving_Force, Rm, Cm, El, I0, F, Q, Ts, Gs);
      put_the_values_into_stimulation_vectors(muGn, clamp_muV, clamp_sV, clamp_Ts_ratio+1./muGn, I0, F, Q, Ts, Gs);
    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure GTVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_GTVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitGTVEdialog;
begin
   TDBrecord('PG0.Exp_params').exp_type := 'tf_Gtot_and_TV_effect_on_spiking' ;
   with TFdialog do
   begin
      create;
      OnEvent:=GTVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Effect of both Gtot and Tv on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_muV,10,3,200);
      getRealA(' clamping the std dev. (mV)',clamp_sV,10,3,200);
      getRealA(' clamping the synaptic time ratio',clamp_Ts_ratio,10,3,200);
      getRealA(' Min. muG factor (muG/Gl)',min_muGn,10,3,200);
      getRealA(' Max. muG factor (muG/Gl)',max_muGn,10,3,200);
      setText('______________________________________');
      getRealA(' Driving Force (mV)',Driving_Force,10,3,200);
      getIntegerA('Number of points ',point_number,6,200);
      getboolean('Checking the conductance ??', check_for_conductance);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Gtot and Tv comod Effect';
      Show;
   end;
end;

{$EDIT muV_Effect} 

procedure gen_MUVE_input; 
var ii : integer ; dv : real;
begin
   initialize_stimulation_vectors;
   dv := (max_muV-min_muV)/(point_number-1) ; {mV}
   for ii:=0 to point_number-1 do 
   begin
      muV := min_muV+ii*dv ; {in mV,  shuffled through vec_i}
      params_variations_calc(clamp_muGn, muV, clamp_sV, clamp_Ts_ratio, Driving_Force, Rm, Cm, El, I0, F, Q, Ts, Gs);
      put_the_values_into_stimulation_vectors(clamp_muGn, muV, clamp_sV, clamp_Ts_ratio+1./clamp_muGn, I0, F, Q, Ts, Gs);
    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure MUVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_MUVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitMUVEdialog;
begin
   TDBrecord('PG0.Exp_params').exp_type := 'tf_muV_effect_on_spiking';
   with TFdialog do
   begin
      create;
      OnEvent:=MUVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the sV (mV)',clamp_sV,10,3,200);
      getRealA(' clamping the Ts ratio',clamp_Ts_ratio,10,3,200);
      getRealA(' clamping muG/Gl ([])',clamp_muGn, 10,3,200);
      setText('______________________________________');
      getRealA(' Min. muV',min_muV,10,3,200);
      getRealA(' Max. muV',max_muV,10,3,200);
      setText('______________________________________');
      getRealA(' Driving Force (mV)',Driving_Force,10,3,200);
      getIntegerA('Number of points ',point_number,6,200);
      getboolean('Checking the conductance ??', check_for_conductance);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Dependence on mean Vm';
      Show;
   end;
end;


{$EDIT sV_Effect} 

procedure gen_sVE_input; 
var ii : integer ; dsv, sv1 : real;
begin
   initialize_stimulation_vectors;
   dsv := (max_sV-min_sV)/(point_number-1) ; {mV}
   for ii:=0 to point_number-1 do 
   begin
      sV1 := min_sV+ii*dsv ; {in mV,  shuffled through vec_i}
      params_variations_calc(clamp_muGn, clamp_muV, sV1, clamp_Ts_ratio, Driving_Force, Rm, Cm, El, I0, F, Q, Ts, Gs);
      put_the_values_into_stimulation_vectors(clamp_muGn, clamp_muV, sV1, clamp_Ts_ratio+1./clamp_muGn, I0, F, Q, Ts, Gs);
    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure SVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_SVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitSVEdialog;
begin
   TDBrecord('PG0.Exp_params').exp_type := 'tf_SV_effect_on_spiking';
   with TFdialog do
   begin
      create;
      OnEvent:=SVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_muV,10,3,200);
      getRealA(' clamping the Ts ratio',clamp_Ts_ratio,10,3,200);
      getRealA(' clamping muG/Gl ([])',clamp_muGn, 10,3,200);
      setText('______________________________________');
      getRealA(' Min. sV',min_sV,10,3,200);
      getRealA(' Max. sV',max_sV,10,3,200);
      setText('______________________________________');
      getRealA(' Driving Force (mV)',Driving_Force,10,3,200);
      getIntegerA('Number of points ',point_number,6,200);
      getboolean('Checking the conductance ??', check_for_conductance);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Dependence on std Vm';
      Show;
   end;
end;

{$EDIT Massive_mV_sV_Tv_mG} 

{ ==============================================================================
--------------------------------- Scanning the mV_sV_Tv_mG space ---------------------------------------
================================================================================ }


procedure gen_massive_scan_input; 
var iv, is, it, ig, n_tot : integer ;  DmuGn, DmV, DsV, sV1_min, sv1_max, 
         dTs_ratio, muGn, max_Tv, min_Tv, DTvN,compress : real;  vec_ts1:Tvector;
begin
   n_tot := DISCRET_SV*DISCRET_MV*DISCRET_MUG*DISCRET_TS; {total number of points}
   initialize_stimulation_vectors;

   if DISCRET_MV>1 then DmV := (max_muV-min_muV)/(DISCRET_MV-1) else DmV:=0;
   if DISCRET_TS>1 then DTs_ratio := (max_Ts_ratio-min_Ts_ratio)/(DISCRET_TS-1) else DTs_ratio:=0;
   {actually the variation of muGn is used to vary the global autocorrelation time}
   { and we make TvN vary linearly, not muG=(TvN-Ts_ratio)**-1 }
   if DISCRET_MUG>1 then DTvN := (1./min_muGn-1./max_muGn)/(DISCRET_MUG-1) else DTvN:=0;
   //if DISCRET_MUG>1 then DmuGn := (max_muGn-min_muGn)/(DISCRET_MUG-1) else DmuGn:=0;

   for iv:=0 to DISCRET_MV-1 do 
   begin
      muV := min_muV + iv*DmV;
      {here we construct the triangle for the mean and variance}

      sv1_max:=max_sV+iv/DISCRET_MV*(max_sV2-max_sV);
      sv1_min:=min_sV+iv/DISCRET_MV*(min_sV2-min_sV);

      if DISCRET_SV>1 then DsV := (sV1_max-sV1_min)/(DISCRET_SV-1) else DsV:=1;
      for is:=0 to DISCRET_SV-1 do 
      begin 
	       sV := sv1_min + is*DsV;
	       for ig:=0 to DISCRET_MUG-1 do 
	       begin
	          //muGn:=min_muGn +ig*DmuGn;
	          muGn := 1./(1./max_muGn + ig*DTvN);
	          //for it:=0 to DISCRET_TS-1 do 
	          //begin
	          Ts_ratio:=min_Ts_ratio;// +it*DTs_ratio;
	          params_variations_calc(muGn, muV, sV, Ts_ratio, Driving_Force, Rm, Cm, El, I0, F, Q, Ts, Gs);
	          {NOW WE CAN APPEND THE VALUES TO THE VECTORS}
	          put_the_values_into_stimulation_vectors(muGn, muV, sV, Ts_ratio+1./muGn, I0, F, Q, Ts, Gs);
	          //end;
	 end;
      end;
   end;
   create_and_shuffle_the_index_vector(n_tot, REPETITION);
end;


procedure massive_scan_DialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_massive_scan_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure Init_massive_scan_dialog;
begin
   TDBrecord('PG0.Exp_params').exp_type := 'tf_massive_mV_sV_Tv_mG';
   min_Ts_ratio:=3./20.; max_Ts_ratio:=6./20.; {different than for Tv scan}
   min_muGn := 1.17647 ; max_muGn := 6.6666667;
   
   with TFdialog do
   begin
      create;
      OnEvent:=massive_scan_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>GRID Parameters :');
      getIntegerA('=====> DISCRET. muV ',DISCRET_MV,6,200);
      getRealA(' Min. muV',min_muV,10,3,200);
      getRealA(' Max. muV',max_muV,10,3,200);
      getIntegerA('=====> DISCRET. sV ',DISCRET_SV,6,200);
      getRealA(' Min. sV (at min. muV)',min_sV,10,3,200);
      getRealA(' Max. sV (at min. muV)',max_sV,10,3,200);
      getRealA(' Min. sV (at max. muV)',min_sV2,10,3,200);
      getRealA(' Max. sV (at max. muV)',max_sV2,10,3,200);
      getIntegerA('=====> DISCRET. muGn ',DISCRET_MUG,6,200);
      getRealA(' Min. Gtot/Gl',min_muGn,10,3,200);
      getRealA(' Max. Gtot/Gl',max_muGn,10,3,200);
      //getIntegerA('=====> DISCRET. Ts ',DISCRET_TS,6,200);
      setText('=====> Ts (fixed)');
      getRealA(' Ts ratio',min_Ts_ratio,10,3,200);
      //getRealA(' Max. Ts ratio',max_Ts_ratio,10,3,200);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      getboolean('Checking the conductance ??', check_for_conductance);
      setText('=======================================');
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      if location='Setup'then
      begin
      getRealA(' Current muV (mV)',muV,10,3,200);
      getRealA(' Current sV (mV)',sV,10,3,200);
      getRealA(' Current muGn (nS)',muGn,10,3,200);
      getRealA(' Current Ts (ms)',Ts,10,3,200);
      setText('');
      end;
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      Caption:='massive scan mV-sV-Tv-mG space';
      Show;
   end;
end;


{$EDIT Main_dialog}
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure MainDialog_update(n:integer); 
var amplifier : string ;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}     
  if acquisition.IsRunning then acquisition.stop; 
  MainDialog.updatevar;
  TDBrecord('PG0.global').Gain1_int:=gain1_int;
  TDBrecord('PG0.global').Gain2_int:=gain2_int;
  TDBrecord('PG0.global').clamp_int := clamp_int; 
  TDBrecord('PG0.global').f_acq := f_acq; 
  case n of
    101: begin 
              case protocol_choice of
                       1 : VCMembTest_Init;
                       2 : ICMembTest_Init;
                       3 : InitGTEdialog;                
                       4 : InitTvEdialog;                
                       5 : InitGTVEdialog;                
                       6 : InitMUVEdialog;                
                       7 : InitSVEdialog;                
                       8 : Init_massive_scan_dialog;
              end; 
         end;
    111 : begin SetGain1; end;
    112 : begin SetGain2; end;
    200 : if SAVING then acquisition.startandsave else acquisition.start;
    201 : acquisition.stop ;
    301 : comments := '';
    281 : RTneuron.Execute(dll_load);
    282 : RTneuron.Restart;
  end;
  gain1:=TDBrecord('PG0.global').Gain1;
  gain2:=TDBrecord('PG0.global').Gain2;    
  clamp_int:=TDBrecord('PG0.global').clamp_int ;      
  f_acq := TDBrecord('PG0.global').f_acq ; 
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -> dangerous for division, e.g. freq) }
var amplifier : string ;
begin
DB.create;
dll_load := TDBrecord('PG0.global').loadnrnpath ;
dll_load := 'nrn_load_dll("'+dll_load+'nrnmech.dll")';
PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ; // data path
amplifier := TDBrecord('PG0.global').amplifier ;
protocol_choice := 0;
//------------
   with MainDialog do
   begin
      create;
      getRealA('Acquisition freq. (kHz)',f_acq,3,2,785);
      setText('|=== Recording Parameters ===|');
      getRealA('Rs -- Access resistance (MO)',Bridge,4,2,785);
      getRealA('Rm -- Input resistance (MO)',Rm,4,2,785);
      getRealA('Cm -- Membrane capacitance (pF)',Cm,4,2,785);
      getRealA('El -- Resting potential (mV)',El,4,2,785);
      getRealA('Ih -- Holding current (pA)',Holding,4,2,785);
      setText('Last measured at : '+Istr(Hour)+'h '+Istr(Minute)+'m '+Istr(Second)+'s');
      setText('|--------------------------------------------------------|');
      getRealA('desired DV for Rinput  (mV)',expected_DV_for_cond,10,3,200);
      setText('');
      OnEvent := MainDialog_update;
   
      getCommandA(' restart NEURON ',0,282);
      getCommandA(' load NEURON mech ',0,281);
      //getCommandA(' load NEURON model ',0,280); 

      setText(' ================================= ');
      setText(' ---------------< Protocol Selection >----------------- ');
      setText('');
      getStringList('  PROTOCOL  ',ProtoNames,Protonum,protocol_choice,101);  { Onevent flag ->199}
   setText(' ================================= ');
   setText('');
   if amplifier='multiclamp' then 
     begin 
        setText(' ==<| GAIN  |>== ');
        getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_int,111);
        getStringListA('Secondary Output ','1 | 2 | 5 | 10 | 20 | 50 | 100',Gain2_int,112);
        setText('');
     end;
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='Main Dialog';
  end;
Maindialog.show;
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}

var 
    already_initiated : boolean ; // to know if we need to reinitialize the TDBrecord
    global, Exp_params : TDBrecord ;
    vec_params : Tvector ;

procedure read_params;
var size : integer ;  filename : string;
begin
     vec_params.create;
     filename :=TDBrecord('PG0.global').PathOfTheDay+'cell_params';
     if FileExists(filename) then 
     begin
     vec_params.LoadObject(filename);
     f_acq:= vec_params[0]; 
     Rm :=vec_params[1] ;  Cm :=vec_params[2] ; 
     El :=vec_params[3] ;  Bridge :=vec_params[4] ;  Holding:=vec_params[5]; 
     gain1_int:=Round(vec_params[6]) ;   gain1:=vec_params[7] ;
     gain2_int := Round(vec_params[8]) ; gain2:=vec_params[9] ;
     // now the time at which they have been calculated !
     Hour:=Round(vec_params[10]); Minute:=Round(vec_params[11]) ; Second:=Round(vec_params[11]) ; 
     end else begin
     Rm :=100;Cm:=200;Bridge:=15;El:=-70;f_acq:=10;Holding:=0;
     gain1_int:=1;gain1:=1;gain2_int:=1;gain2:=1;
     end; 
     TDBrecord('PG0.global').gain1 := gain1 ;  TDBrecord('PG0.global').gain2 := gain2 ;
end;

procedure global_init;
var PathOfTheDay : string ;
begin

RTneuron.resetParams;
DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
time_detector.create ; detector.create ;

SAVING:=True;
global.create; Exp_Params.create;
 

/// ---- CASE ON LAPTOP
if location='Notebook'then
begin
TDBrecord('PG0.global').amplifier:='nrn_simulation'; // choice of the amplifier
PathOfTheDay := 'C:\Users\yann\Documents\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
TDBrecord('PG0.global').loadnrnPath := 'D:/home/yann/work/elphy/nrn_files/' ; 
end;
if location='Setup'then
begin
/// ---- CASE ON MULTICLAMP
TDBrecord('PG0.global').amplifier:='multiclamp';
PathOfTheDay := 'D:\Yann\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
TDBrecord('PG0.global').loadnrnPath := 'D:/Yann/elphy/nrn_files/' ; 
end;
if location='Linux' then
begin
/// ---- CASE ON LINUX MACHINE
TDBrecord('PG0.global').amplifier:='nrn_simulation';
PathOfTheDay := 'Z:\home\yann\Documents\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
TDBrecord('PG0.global').loadnrnPath := 'Z:/home/yann/work/elphy/nrn_files/' ; 
end;

if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
TDBrecord('PG0.global').PathOfTheDay := PathOfTheDay ;


// those 3 parameters are obvious, we just keep them for compatibility with the other conventions
TDBrecord('PG0.global').clamp_int := 1; // integer that code for 1:IC, 2: VC
TDBrecord('PG0.global').cont_choice := True; // if True -> continus mode, else episode
TDBrecord('PG0.global').stim := False;  // if True acquisition.Fstimulate := True


TDBrecord('PG0.global').main_protocol:='';
TDBrecord('PG0.global').protocol:='transfer_functions';
TDBrecord('PG0.global').saving := True ;


TDBrecord('PG0.global').FadvanceON := True ;  
   
InsertPage(1,'fake');DeleteAllPages('fake');InsertPage(1,'default');DeleteAllPages('default');
Color := cl_gray ;
end;


{
program set_to_zero
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
}

program Launch
init_fluct_const;
global_init ;
read_params;
SetProtocolNames;
init_windows;
Init_Main_Dialog;