 {$EDIT START}                                               
{========================================================================
------- Master file for the optogenetics experiments  ---------
------- phase-locked on the slow cortical oscillation ---------
========================================================================}

Const
   ProtocolCount    = 15 ; 
   OptoCount    = 9 ; 
   location	    = 'Macbook' ; // switch to 'RT-Setup' for experiments !!
   setup	    = 'NEURON-sim' ; // switch to 'RT-Setup' for experiments !!
   
  { ========= COMMON VARIABLES ============ }
var
   protocol_index, setup_index, location_index, opto_index, clamp_index			 : integer ; 
   comments, PathOfTheDay, loadnrnPath, sep, root_dir					 : string ;
   MainDialog, dialog, StimDialog							 : Tdialog ;{ two dialogs for buttons and protocols}
   stim, closedLoop, SAVING , cont_choice						 : boolean ; 
   ProtocolName										 : array[1..protocolCount] of string; ProtoNames, ProtoNum:string;
   DB											 : Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond					 : smallint; {variables to fetch the date and time }
   gain1,gain2										 : real;
   gain1_index,gain2_index								 : integer;
   dll_load										 : string ;
   f_acq										 : real ; // parameters of the patch recording !
   hist, cum_proba									 : Tvector; 
   fraction_of_cumprob_for_Down_transition, fraction_of_cumprob_for_Up_transition	 : real;
   upward_threshold, downward_threshold, spike_threshold, subsampling_freq, Amp_for_Stim : real ;
   CMD_delay, CMD_dur									 : real ;
   UD_dialog										 : Tdialog ;
   Down_cursor, Up_cursor								 : Tcursor ;
   with_LFP, Clamp_stim, Opto_stim							 : boolean;
   Up_State_Stim, Down_State_Stim							 : boolean;
   flag_for_state_stimulation, current_index, Stim_Periodicity				 : integer;
   Delay_for_stim, Dur_for_stim								 : real;
   already_initiated									 : boolean ; // to know if we need to reinitialize the TDBrecord
   global, Exp_params									 : TDBrecord ;
   vec_params										 : Tvector ;
   LocationName										 : array[1..3] of string; LocationNames : string;
   OptoName										 : array[1..OptoCount] of string; OptoNames : string; OptoList : string;
   CurrentsName										 : array[0..5] of string; CurrentsNames : string; CurrentsList : string;
   SetupName										 : array[1..3] of string; SetupNames : string;
   ClampName										 : array[1..2] of string; ClampNames : string;
   min_delay, max_delay, min_duration, max_duration, min_amp, max_amp			 : real ;
   num_delay, num_duration, num_amp, clamp_periodicity					 : integer ;
   excitatory_reversal, inhibitory_reversal, intermediate_reversal, holding_potential	 : real;

   
{ ============================================================================	   
  ----- Protocol And Constants Initialization --------------------------------
  ============================================================================ }
 
procedure SetProtocolNames;
var          
  i:integer;                           
begin
   ProtocolName[1]:= 'Seal-Test'; 
   ProtocolName[2]:= 'Current-Clamp Membrane Test'; 
   ProtocolName[3]:= 'Voltage-Clamp Membrane Test'; 
   ProtocolName[4]:= 'Input Conductance Measure'; 
   ProtocolName[5]:= 'Vm-feedback--Spont-Act-Sampling'; 
   ProtocolName[6]:= 'Vm-feedback--Opto-Stim-vs-Ctrl'; 
   ProtocolName[7]:= 'Vm-feedback--Stim-at-Various-Delays'; 
   ProtocolName[8]:= 'Vm-feedback--Stim-of-Various-Durations'; 
   ProtocolName[9]:= 'Vm-feedback--Stim-of-Various-Amplitudes'; 
   ProtocolName[10]:= 'Isyn-feedback--Spont-Act-Sampling'; 
   ProtocolName[11]:= 'Isyn-feedback--Get-Syn-Currents'; 
   ProtocolName[12]:= 'Isyn-feedback--Opto-Stim-vs-Ctrl'; 
   ProtocolName[13]:= 'Isyn-feedback--Stim-at-Various-Delays'; 
   ProtocolName[14]:= 'Isyn-feedback--Stim-of-Various-Durations'; 
   ProtocolName[15]:= 'Isyn-feedback--Stim-of-Various-Amplitudes'; 
   ProtoNames:=ProtocolName[1];
   ProtoNum :='0|1';
   for i:=2 to ProtocolCount do 
   begin ProtoNames:=ProtoNames+'|'+ProtocolName[i]; ProtoNum:=ProtoNum+'|'+Istr(i); end;
end;    


procedure SetLocations;
begin
   LocationName[1]:= 'RT-Setup'; 
   LocationName[2]:= 'OS-X'; 
   LocationName[3]:= 'Linux';
   LocationNames := 'RT-Setup|OS-X|Linux';
end;

procedure SetClamp;
begin
   ClampName[1]:= 'I-Clamp'; 
   ClampName[2]:= 'V-Clamp';
   ClampNames := 'I-Clamp|V-Clamp';
end;    

procedure SetSetup;
begin
   SetupName[1]:= 'RT-Setup'; 
   SetupName[2]:= 'Data-Replay'; 
   SetupName[3]:= 'NEURON-sim.';
   SetupNames := 'RT-Setup|Data-Replay|NEURON-sim.';
end;    

procedure SetOpto;
var i:integer;                           
begin
   OptoName[1]:= 'None'; 
   OptoName[2]:= 'Photo-Activation PV+'; 
   OptoName[3]:= 'Photo-Inhibition PV+'; 
   OptoName[4]:= 'Photo-Activation SOM+'; 
   OptoName[5]:= 'Photo-Inhibition SOM+'; 
   OptoName[6]:= 'Photo-Activation l5 pyr.'; 
   OptoName[7]:= 'Photo-Inhibition l5 pyr.'; 
   OptoName[8]:= 'Photo-Activation l2/3 pyr.'; 
   OptoName[9]:= 'Photo-Inhibition l2/3 pyr.';
   OptoList :='0';
   for i:=1 to OptoCount do 
   begin OptoNames:=OptoNames+'|'+OptoName[i]; Optolist:=Optolist+'|'+Istr(i); end;
end;    

procedure SetCurrents;
var i:integer;                           
begin
   CurrentsName[0]:= '';
   CurrentsName[1]:= 'Currents at Holding';
   CurrentsName[2]:= 'Excitatory Currents';
   CurrentsName[3]:= 'Inhibitory Currents';
   CurrentsName[4]:= 'Both Alternatively';
   CurrentsName[5]:= 'Intermediate Currents';
   CurrentsList :='0';
   for i:=1 to 4 do 
   begin CurrentsNames:=CurrentsNames+'|'+CurrentsName[i]; Currentslist:=Currentslist+'|'+Istr(i); end;
end;    

procedure init_windows;
begin
   DeleteAllPages('');
   InsertPage(1,'fake');DeleteAllPages('fake');
   InsertPage(1,'Intra-recording \& (phase-locked) Optogenetics');
   Page:=1; color:=cl_gray;
end;

procedure init_csts;
begin
   f_acq := 10. ; 
   upward_threshold :=-60;
   downward_threshold :=-65;
   subsampling_freq := 1.;
   spike_threshold := -30;
   Amp_for_Stim := 5;
   Stim_Periodicity := 2 ;
   Delay_for_stim := 30 ;
   Dur_for_stim := 100   ;
   fraction_of_cumprob_for_Down_transition := 0.3 ;
   fraction_of_cumprob_for_Up_transition := 0.6 ;
   flag_for_state_stimulation := 1;
   clamp_index :=1 ; opto_index :=1;
   min_delay := 0.; max_delay:=200; min_duration:=20; max_duration:=200;
   min_amp:=4.; max_amp:=6.;
   num_delay := 3; num_duration:= 3; num_amp:= 3;
   flag_for_state_stimulation := 1;
   CMD_delay :=-30.; CMD_dur :=370.; clamp_periodicity := 2;
   excitatory_reversal := 80; inhibitory_reversal := -10.;
   intermediate_reversal := (inhibitory_reversal+excitatory_reversal)/2.;
   current_index := 1; holding_potential := -70;
end;
  
{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }

{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }

procedure UpdateCursor(n:integer);
begin
   downward_threshold := Down_Cursor.position[1];
   upward_threshold := Up_Cursor.position[1];
   UD_dialog.update;
end;

procedure UpdateCursor_in_NEURON;
begin
   if not with_LFP then RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   if not with_LFP then RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
end;

procedure FinalPlot_Settings;
begin
   v1.cpy:=1 ; v5.cpy := 1 ; v3.cpy:= 2 ; v4.cpy:= 2 ; v2.cpy:= 3 ; v6.cpy:= 3 ;  {we set the coupling value -D  to couple to future analysis} 
   v1.color := CL_Black ; v2.color := CL_Black ; v3.color := CL_Red ; v4.color := CL_Blue ; v5.color := CL_Red ;
   Down_Cursor.create ; Down_Cursor.style:=cs_Y;
   Up_Cursor.create ; Up_Cursor.style:=cs_Y;
   if ClampName[clamp_index]='I-Clamp' then
   begin
      DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
      Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
   end else
   begin
      DOwn_Cursor.PosMin:=-200;Down_Cursor.PosMax:=1800;
      Up_Cursor.PosMin:=-200;Up_Cursor.PosMax:=1800;
   end;
   Down_Cursor.InstallSource(v1); Down_Cursor.visible:=True;
   Down_Cursor.position[1]:=downward_threshold ;
   Down_Cursor.OnChange:=UpdateCursor;
   Up_Cursor.InstallSource(v1); Up_Cursor.visible:=True;
   Up_Cursor.position[1]:=upward_threshold ;
   Up_Cursor.OnChange:=UpdateCursor;
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ; v4.cpx:=1 ; v5.cpx:=1 ; v6.cpx:=1 ;
end;

procedure Set_DC_Channels_DEMO;       {NOT WORKING YET !!!!}
var 
   i : integer; 
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}
   RTneuron.ResetParams;
   acquisition.ChannelCount := 6; {one channel more in V-Clamp}
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);

   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }
 
   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   
   {===============================================================}
   {        Creating the fake (simulated) cell                     }
   {===============================================================}
   
   RTneuron.FadvanceON:=True; { -->  NEURON calculus }  
   RTneuron.execute('create soma, lfp, fake_comp');
   RTneuron.execute('soma insert pas');
   RTneuron.execute('soma insert ca_ion'); {NEEDED in Voltage-Clamp, to have a non-Vm global variable...}
   RTneuron.execute('soma e_pas=-80.');
   RTneuron.execute('soma L=diam=79.8');
   RTneuron.Execute('soma g_pas = 5e-5');

   { {\===============================================================!{\ }
   { {\        Recording channels                                     !{\ }
   { {\===============================================================!{\ }

   if ClampName[clamp_index]='I-Clamp' then
   begin {Current-Clamp}
      // channel 1 -->  primary ->  Vm
      acquisition.Channels[1].NrnSymbolName:='soma.v(0.5)';
      acquisition.Channels[1].unitY:='mV' ;
      addObject(1,1,v1); v1.title:='Vm(t)';
      // channel 2 -->  secondary ->  Iinj
      {to be removed on Setup RTneuron.DacChan[1].NrnSymbolName:='lfp.v(.5)'}
      acquisition.Channels[2].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[2].unitY:='pA';
   end else {Voltage-Clamp}
   begin
      // channel 1 -->  primary ->  recorded Isyn
      acquisition.Channels[1].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[1].unitY:='pA' ;
      addObject(1,1,v1); v1.title:='Isyn';
      // channel 2 -->  secondary 
      acquisition.Channels[2].NrnSymbolName:='soma.v(0.5)'; {here replaced by pot.}
      { TO BE CHANGED FOR THE SECONDARY : acquisition.Channels[6].NrnSymbolName:='V_CMD';}
      acquisition.Channels[2].unitY:='mV'; v1.title:='V_CMD';
      if closedLoop then addObject(1,2,v2); 
   end;
   
   {===============================================================}
   {        Protocol Specific Mechanisms                           }
   {===============================================================}
   if ClosedLoop then
   begin
      if ClampName[clamp_index]='I-Clamp' then
      begin
	 RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.v_LP'; acquisition.Channels[5].unitY:='mV' ; v5.title:='Vm_low_passed'; addObject(1,1,v5);
      end
      else {Voltage-Clamp}
      begin
	 RTneuron.Execute('soma UD_loop = new Isyn_feedback_for_opto(.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.i_LP'; acquisition.Channels[5].unitY:='pA' ; v5.title:='Isyn_low_passed'; addObject(1,1,v5);
	 { TO BE CHANGED FOR THE COMMAND : acquisition.Channels[6].NrnSymbolName:='soma.cao(0.5)';}
	 acquisition.Channels[6].NrnSymbolName:='vclamp.vc'; acquisition.Channels[6].unitY:='mV' ; v6.title:='Vm'; addObject(1,2,v6);
      end;
      acquisition.Channels[4].NrnSymbolName:='UD_loop.Up_flag'; acquisition.Channels[4].unitY:='mV' ; v4.title:='Up_flag'; addObject(1,1+clamp_index,v4);
      acquisition.Channels[3].NrnSymbolName:='UD_loop.V_LASER'; acquisition.Channels[3].unitY:='mV' ; v3.title:='TTL_Input'; addObject(1,1+clamp_index,v3); 
   end else {fake compartment to still have UD_loop created}
   begin
      if ClampName[clamp_index]='I-Clamp' then  RTneuron.Execute('fake_comp UD_loop = new Vm_feedback_for_opto(.5)')
      else RTneuron.Execute('fake_comp UD_loop = new Isyn_feedback_for_opto(.5)');
   end;
   
   {===============================================================}
   {        Articifially Emulating Vm/lFP                          }
   {===============================================================}
   if SetupName[setup_index]='NEURON-sim.' then
      begin
   	 RTneuron.execute('soma insert hh_hippoc'); { RTneuron.execute('soma insert WangBuszaki'); }
   	 RTneuron.Execute('soma stim = new Exp2Syn_eiNtwk(0.5)');
   	 if ClampName[clamp_index]='V-Clamp' then
   	 begin {Voltage-Clamp}
   	    RTneuron.execute('objref vclamp');
   	    RTneuron.execute('soma vclamp = new myVClamp(0.5)');
   	    RTneuron.execute('vclamp.rs=15.'); {15 MOhm access resistance !}
   	 end;
      end
   else if SetupName[setup_index]='Data-Replay' then {*** only in Current-Clamp for now ***}
      begin
   	 RTneuron.execute('objref vclamp');
   	 RTneuron.execute('soma vclamp = new SEClamp(.5)');
   	 RTneuron.execute('vclamp.rs=1e-2');
   	 RTneuron.execute('vclamp.dur1=1e9');
   	 if not with_LFP then RTneuron.execute('vv.play(&vclamp.amp1, '+Rstr(1./f_acq)+')');
   	 if with_LFP then RTneuron.execute('vv2.play(&lfp.v(0.5), '+Rstr(1./f_acq)+')');
      end;
   
   // Final graphical settings
   FinalPlot_Settings;
end;

procedure Set_DC_channels;
var
   i :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 4; // for the whole classic_electrophy protocols
   RTneuron.execute('create soma, lfp');
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);
   
   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   
   // MEMBRANE POTENTIAL, SENT TO THE DYNAMIC CLAMP LOOP
   RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='soma.v(.5)';
   acquisition.Channels[1].NrnSymbolName:='soma.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
   addObject(1,1,v1); v1.title:='Vm(t)';
   // LFP
   RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='lfp.v(.5)';
   acquisition.Channels[1].NrnSymbolName:='lfp.v(.5)'; acquisition.Channels[1].unitY:='mV' ;
   addObject(1,2,v2); v2.title:='LFP(t)';
   if closedLoop then
      begin
	 RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(.5)');
	 // CHECKING THE OUTPUT OF THE FEEDBACK LOOP , additional inputs for closed-loop setting
	 RTneuron.AdcChan[2].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[2].NrnSymbolName:='TTL_CHECK'; // secondary comes from analogous
	 RTneuron.AdcChan[3].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[3].NrnSymbolName:='UP_CHECK'; // secondary comes from analogous
	 // OUTPUT OF THE FEEDBACK LOOP                                      
	 RTneuron.DacChan[0].NrnSymbolName:='UD_loop.V_LASER'; RTneuron.DacChan[0].setScale(0,32767,0,1000.0/gain1); {command -D  I clamp, stim.i in nA !!! and opposite sign !!!}
	 RTneuron.DacChan[1].NrnSymbolName:='UD_loop.Up_flag'; RTneuron.DacChan[1].setScale(0,32767,0,1000.0/gain1); {command -D  I clamp, stim.i in nA !!! and opposite sign !!!}
	 acquisition.Channels[3].NrnSymbolName:='TTL_CHECK'; acquisition.Channels[3].unitY:='mV' ;
	 acquisition.Channels[4].NrnSymbolName:='UP_CHECK'; acquisition.Channels[4].unitY:='mV' ;
	 addObject(1,3,v3); addObject(1,3,v4); v3.title:='Online-Analysis Quantities';
      end;
   FinalPlot_Settings;
end;

procedure set_dac_to_zero;
begin
   Rtneuron.DacChan[0].UseHoldingValue:=True;    
   Rtneuron.DacChan[1].UseHoldingValue:=True;  
   Rtneuron.DacChan[0].HoldingValue:=0;
   Rtneuron.DacChan[1].HoldingValue:=0;
   with stimulator do
   begin
      stimulator.setValue(0,0,0,0);   
      stimulator.setValue(0,0,1,0);   
      stimulator.setValue(0,1,0,0);  
   end; 
end;

{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments + Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }
 
procedure write_Exp_params; {to be used by all subsequent protocols}
begin
   TDBrecord('PG0.global').f_acq := f_acq ; 
   TDBrecord('PG0.global').PathOftheDay := PathOftheDay ; 
   TDBrecord('PG0.global').loadnrnPath := loadnrnPath ; 
   TDBrecord('PG0.global').location:=LocationName[location_index]; 
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Down_transition := fraction_of_cumprob_for_Down_transition;
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Up_transition := fraction_of_cumprob_for_Up_transition;
   TDBrecord('PG0.Exp_params').upward_threshold := upward_threshold ;
   TDBrecord('PG0.Exp_params').downward_threshold := downward_threshold ;
   TDBrecord('PG0.Exp_params').subsampling_freq := subsampling_freq;
   TDBrecord('PG0.Exp_params').spike_threshold :=  spike_threshold;
   TDBrecord('PG0.Exp_params').Amp_for_Stim := Amp_for_Stim;
   TDBrecord('PG0.Exp_params').Stim_Periodicity := Stim_Periodicity ;
   TDBrecord('PG0.Exp_params').Delay_for_stim := Delay_for_stim  ;
   TDBrecord('PG0.Exp_params').Dur_for_stim := Dur_for_stim    ;
   TDBrecord('PG0.Exp_params').stim := stim;
   TDBrecord('PG0.Exp_params').closedLoop :=closedLoop;
   TDBrecord('PG0.Exp_params').gain1 := gain1 ;
   TDBrecord('PG0.Exp_params').gain2 := gain2;
   TDBrecord('PG0.Exp_params').with_LFP:=with_LFP;
   TDBrecord('PG0.Exp_params').Up_State_Stim:=Up_State_Stim;
   TDBrecord('PG0.Exp_params').Down_State_Stim := Down_State_Stim ;
   TDBrecord('PG0.Exp_params').flag_for_state_stimulation:=flag_for_state_stimulation;
   TDBrecord('PG0.Exp_params').setup:=SetupName[setup_index];
   TDBrecord('PG0.Exp_params').clamp := ClampName[clamp_index];
   TDBrecord('PG0.Exp_params').optogenetics := OptoName[opto_index];
   TDBrecord('PG0.Exp_params').location := LocationName[location_index];
   TDBrecord('PG0.Exp_params').current := CurrentsName[current_index];
   TDBrecord('PG0.Exp_params').min_delay:=min_delay;
   TDBrecord('PG0.Exp_params').max_delay:=max_delay;
   TDBrecord('PG0.Exp_params').num_delay:=num_delay;
   TDBrecord('PG0.Exp_params').min_duration:=min_duration;
   TDBrecord('PG0.Exp_params').max_duration:=max_duration;
   TDBrecord('PG0.Exp_params').num_duration:=num_duration;
   TDBrecord('PG0.Exp_params').min_amp:=min_amp;
   TDBrecord('PG0.Exp_params').max_amp:=max_amp;
   TDBrecord('PG0.Exp_params').num_amp:=num_amp;
   TDBrecord('PG0.Exp_params').CMD_delay :=CMD_delay;
   TDBrecord('PG0.Exp_params').CMD_dur :=CMD_dur;
   TDBrecord('PG0.Exp_params').clamp_periodicity := clamp_periodicity;
   TDBrecord('PG0.Exp_params').excitatory_reversal := excitatory_reversal;
   TDBrecord('PG0.Exp_params').inhibitory_reversal := inhibitory_reversal;
   TDBrecord('PG0.Exp_params').intermediate_reversal := intermediate_reversal;
end;

procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_index];
  DB.Comments := comments ; {comments is a global variable }
  DB.Day := Day ; DB.Month := Month ; DB.Year := Year ;
  DB.Hour := Hour ; DB.Minute := Minute ; DB.SEcond := Second ;    
end;

procedure my_initprocess0;
var protocol, filename  : string ; {variables to fetch the date and time }
begin
   protocol := ProtocolName[protocol_index];
   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
   filename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
   TDBrecord('PG0.Exp_params').exp_type := protocol;
   TDBrecord('PG0.Exp_params').filename := filename;
   write_Exp_params; 
   FillDBinfo(DB); 
   if SAVING then begin CreateDir(filename); acquisition.writeDBfileinfo(DB); end;
   acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
end;

procedure Save_Vector_From_NEURON(neuron_vector, filename: string);
var Path, protocol, st : string ; i : integer;
begin
   protocol := ProtocolName[protocol_index];
   Path := PathOfTheDay ;
   Path := Path+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol+'\';
   openText(1,Path+filename,false);
   for i:=0 to 1999 do
      begin
	 st := Rstr(RTneuron.getNRNvalue(neuron_vector+'['+Istr(i)+']'), 1, 6);
	 writelnText(1,st);
      end;
   closeText(1);
end;

procedure Get_Transitions_Times;
begin
   if closedLoop then
      begin
	 Save_Vector_From_NEURON('UD_loop.up_transition_vec', 'up_transitions.txt');
	 Save_Vector_From_NEURON('UD_loop.down_transition_vec', 'down_transitions.txt');
	 Save_Vector_From_NEURON('UD_loop.stim_vec', 'stim_flag.txt');
	 Save_Vector_From_NEURON('UD_loop.delay_vec', 'delays.txt');
	 Save_Vector_From_NEURON('UD_loop.duration_vec', 'durations.txt');
	 Save_Vector_From_NEURON('UD_loop.amplitude_vec', 'amplitudes.txt');
	 if ClampName[clamp_index]='V-Clamp' then Save_Vector_From_NEURON('UD_loop.cmd_vec', 'Vcmd.txt');
      end;
end;

procedure my_endprocess;
begin
   if SAVING then Get_Transitions_Times;
   set_dac_to_zero;
end;

{$EDIT artificial-UD}
{ ==============================================================================
--------------- CREATING ARTIFICIAL Up & Down States --------------------
================================================================================ }

procedure Initialize_Simulated_Up_and_Down_States;
      // we set a sequence of Up and Down states !!
begin
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim(.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('soma nsI = new NetStim(.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.delay = 0');
   RTneuron.execute('nsE.seed(0)');
   RTneuron.execute('nsI.seed(2)');
   RTneuron.execute('Qe_up = 0.004');
   RTneuron.execute('Qe_down = 0.001');
   RTneuron.execute('Qi_up = -0.003');
   RTneuron.execute('Qi_down = -0.0032');
   {synaptic weights}
   RTneuron.execute('ncE.weight = Qe_up');
   RTneuron.execute('ncI.weight = Qi_up'); {NEGATIVE FLAG !!!}
   {then synaptic times}
   RTneuron.execute('stim.tauE = 5');
   RTneuron.execute('stim.tauI = 10');
   {firing frequencies}
   RTneuron.execute('nsE.interval = 0.8');
   RTneuron.execute('nsI.interval = .5');
   {current to bring at mean}
   RTneuron.execute('objref fih, rand, cvode');
   RTneuron.execute('rand = new Random()');
   RTneuron.execute('rand.normal(300,150*150)');
   RTneuron.execute('cvode = new CVode()');
   RTneuron.execute('fih = new FInitializeHandler(1, "f1()")');
   RTneuron.execute('tt = 0.');
   RTneuron.execute('proc f2() {ncE.weight = (Qe_up-ncE.weight)*Qe_up/(Qe_up-Qe_down) - (Qe_down-ncE.weight)*Qe_down/(Qe_up-Qe_down)}');
   RTneuron.execute('proc f3() {ncI.weight = (Qi_up-ncI.weight)*Qi_up/(Qi_up-Qi_down) - (Qi_down-ncI.weight)*Qi_down/(Qi_up-Qi_down)}');
   RTneuron.execute('proc f1() {for i=0, 500 {tt = tt+rand.repick() cvode.event(tt, "f2() f3()")}}');
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
begin
    case Gain1_index of
    1: Gain1 := 1.0; 2: Gain1 := 2.0;
    3: Gain1 := 5.0; 4: Gain1 := 10.0;
    5: Gain1 := 20.0; 6: Gain1 := 50.0;
    7: Gain1 := 100.0; 8: Gain1 := 200.0;
    9: Gain1 := 500.0; 10: Gain1 := 1000.0;
    11: Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure InitializeChannels;
begin
   if SetupName[setup_index]='RT-Setup' then Set_DC_channels else Set_DC_channels_DEMO;
   if SetupName[setup_index]='NEURON-sim.' then Initialize_Simulated_Up_and_Down_States; // Fake data
   // the initialization
   RTneuron.execute('finitialize(-70)');
end;


{$EDIT Spont-act-sampling}
{ ==============================================================================
--------------- Spontaneous activity sampling --------------------
================================================================================ }

procedure Calculate_Threshold_for_Vm;
var i0, ii : integer; 
begin
   // we create the vectors
   hist.create(t_single,0,100); hist.x0:=-80.;hist.dx:=1.;
   cum_proba.create(t_single,0,100); cum_proba.x0:=-80.;cum_proba.dx:=1.;
   // ========== CORE OF THE CALCULATION =========== //
   Distri(v1, hist, -80, 20);
   // RE-include this code if you want to start the cum. proba form the Peak of the Down state
   ii := 0;
   while ((hist.yvalue[ii]<0.98*hist.ymax) and (ii<hist.Iend)) do ii := ii+1;
   hist.fill1(0., -80., hist.convx(ii+1)); // filling all values previous to Down state peak with 0 values
   DistriFunction(hist, cum_proba); // cumulative distribution
   ii:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Down_transition);
   downward_threshold := cum_proba.convx(ii+1);
   i0:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Up_transition);
   upward_threshold := cum_proba.convx(i0+1);
   UD_dialog.update;
   v1.refresh;
end;

procedure ShowHistograms;
begin
   Down_Cursor.create ; Down_Cursor.style:=cs_X ;
   Up_Cursor.create ; Up_Cursor.style:=cs_X ;
   if ClampName[clamp_index]='I-Clamp' then
   begin
      DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
      Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
      hist.SetWorld(-80, 20, 0, hist.ymax);
      cum_proba.SetWorld(-80, 20, 0, cum_proba.ymax);
   end else
   begin
      DOwn_Cursor.PosMin:=-200;Down_Cursor.PosMax:=1800;
      Up_Cursor.PosMin:=-200;Up_Cursor.PosMax:=1800;
      hist.SetWorld(-100, 1800, 0, hist.ymax);
      cum_proba.SetWorld(-200, 1800, 0, cum_proba.ymax);
   end;
   Down_Cursor.InstallSource(hist); Down_Cursor.visible:=True ;
   Down_Cursor.position[1]:=downward_threshold ; 
   Down_Cursor.OnChange:=UpdateCursor;
   Up_Cursor.position[1]:=upward_threshold ;
   Up_Cursor.InstallSource(hist); Up_Cursor.visible:=True ;
   Up_Cursor.OnChange:=UpdateCursor;
   addObject(1,2,hist); 
   addObject(1,3,cum_proba); 
end;

procedure Set_Threshold;
begin
   FInalPLot_settings;
   v1.refresh;
end;

procedure SAS_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : Calculate_Threshold_for_Vm;
     202 : Set_Threshold;
     203 : ShowHistograms;
     end;
     UD_dialog.update;
end;  

procedure InitSASdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), Round(PageWidth/2), PageHeight);
   Definewindow(1, Round(PageWidth/2), Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=SAS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==* Analyzing the *Vm* during Slow Oscill.  *==__');
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('Subsampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('fraction of cum. proba for transition to Down',fraction_of_cumprob_for_Down_transition,10,3,200);
      getRealA('fraction of cum. proba for transition to Up',fraction_of_cumprob_for_Up_transition,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV)',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV)',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('');
      getCommandA(' Calculate optimal thresholds',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Set cursors',0,202);
      getCommandA('Show Histograms',0,203);
      Caption:='Sampling Spont. Act.';
      Show;
   end;
end;


{$EDIT Vm-feedback-loop-init}
{ ==============================================================================
--------------- INITIALIZE A SINGLE PROTOCOL (COMMON All-Vm Feedback) -----------
================================================================================ }

procedure Init_Vm_feedback_loop;
var setup : string ; i, j : integer;
begin
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
   RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   RTneuron.execute('UD_loop.subsampling_freq = '+Rstr(subsampling_freq));
   RTneuron.execute('UD_loop.spike_threshold = '+Rstr(spike_threshold));
   RTneuron.execute('UD_loop.Amp_for_Stim = '+Rstr(Amp_for_Stim));
   
   // the choice is here !
   if Up_State_Stim then RTneuron.execute('UD_loop.up_stimulation = 0') else RTneuron.execute('UD_loop.up_stimulation = -1');
   if Down_State_Stim then RTneuron.execute('UD_loop.down_stimulation = 0') else RTneuron.execute('UD_loop.down_stimulation = -1');

   if (ProtocolName[protocol_index]='Vm-feedback--Opto-Stim-vs-Ctrl') then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
      end
   else if (ProtocolName[protocol_index]='Vm-feedback--Stim-at-Various-Delays') then
      begin
	 if num_delay>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_delay-1 do RTneuron.execute('v1.append('+Rstr(min_delay+j*(max_delay-min_delay)/(num_delay-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.delay_vec[i]=v1.x[j%'+Istr(num_delay)+'] j=j+1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	       RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
	    end else MessageBox('Need delay_num>1 !');
      end
   else if (ProtocolName[protocol_index]='Vm-feedback--Stim-of-Various-Durations') then
      begin
	 if num_duration>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_duration-1 do RTneuron.execute('v1.append('+Rstr(min_duration+j*(max_duration-min_duration)/(num_duration-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.duration_vec[i]=v1.x[j%'+Istr(num_duration)+'] j=j+1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
	    end else MessageBox('Need delay_num>1 !');
      end
   else if (ProtocolName[protocol_index]='Vm-feedback--Stim-of-Various-Amplitudes') then
      begin
	 if num_duration>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	       RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_amp-1 do RTneuron.execute('v1.append('+Rstr(min_amp+j*(max_amp-min_amp)/(num_amp-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.amplitude_vec[i]=v1.x[j%'+Istr(num_amp)+'] j=j+1 } }' );
	    end else MessageBox('Need delay_num>1 !');
      end;
end;

{$EDIT Test-vs-Ctrl-Vm-Feedback}
{ ==============================================================================
--------------- PHASE-LOCKED OPTOGENTICS IN UP-or-DOWN-STATE  ------------------
================================================================================ }

procedure UD_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUD_dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UD_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity,6,200);
      getRealA('Delay after State start (ms) ', Delay_for_stim,10,3,200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim,10,3,200);
      getRealA('Stimulus amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Delays-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Delays  ------------------
================================================================================ }

procedure UDdelayVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdelayVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdelayVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Delays : Number', num_delay, 6, 200);
      getRealA('Varying Delays : Minimum (ms) ', min_delay, 10, 3, 200);
      getRealA('Varying Delays : Maximum (ms) ', max_delay, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim, 10, 3, 200);
      getRealA('Stimulus Amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Durations-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDdurationVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdurationVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdurationVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Durations : Number', num_duration, 6, 200);
      getRealA('Varying Durations : Minimum (ms) ', min_duration, 10, 3, 200);
      getRealA('Varying Durations : Maximum (ms) ', max_duration, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      getRealA('Stimulus Amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Amplitudes-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDamplitudeVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDamplitudeVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDamplitudeVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Amplitudes : Number', num_amp, 6, 200);
      getRealA('Varying Amplitudes : Minimum (ms) ', min_amp, 10, 3, 200);
      getRealA('Varying Amplitudes : Maximum (ms) ', max_amp, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      getRealA('Stimulus Duration (ms) ',Dur_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT VC-Spont-act-sampling}
{ ==============================================================================
--------------- Spontaneous activity sampling in Voltage-Clamp   ---------------
================================================================================ }

procedure Calculate_Threshold_for_Isyn;
var i0, ii : integer; 
begin
   // we create the vectors
   hist.create(t_single,0,100); hist.x0:=-200.;hist.dx:=20.;
   cum_proba.create(t_single,0,100); cum_proba.x0:=-200.;cum_proba.dx:=20.;
   // ========== CORE OF THE CALCULATION =========== //
   Distri(v1, hist, -200, 1800);
   // RE-include this code if you want to start the cum. proba form the Peak of the Down state
   ii := 0;
   while ((hist.yvalue[ii]<0.98*hist.ymax) and (ii<hist.Iend)) do ii := ii+1;
   hist.fill1(0., -200., hist.convx(ii+1)); // filling all values previous to Down state peak with 0 values
   DistriFunction(hist, cum_proba); // cumulative distribution
   ii:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Down_transition);
   downward_threshold := cum_proba.convx(ii+1);
   i0:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Up_transition);
   upward_threshold := cum_proba.convx(i0+1);
   UD_dialog.update;
   v1.refresh;
end;

procedure VCSAS_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : Calculate_Threshold_for_Isyn;
     202 : Set_Threshold;
     203 : ShowHistograms;
     end;
     UD_dialog.update;
end;  

procedure InitVCSASdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), Round(PageWidth/2), PageHeight);
   Definewindow(1, Round(PageWidth/2), Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCSAS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==* Analyzing the *Isyn* during Slow Oscill.  *==__');
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('Subsampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('fraction of cum. proba for transition to Down',fraction_of_cumprob_for_Down_transition,10,3,200);
      getRealA('fraction of cum. proba for transition to Up',fraction_of_cumprob_for_Up_transition,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA)',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA)',downward_threshold,10,3,200);
      setText('');
      getCommandA(' Calculate optimal thresholds',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Set cursors',0,202);
      getCommandA('Show Histograms',0,203);
      Caption:='Sampling Spont. Act.';
      Show;
   end;
end;

{$EDIT Isyn-feedback-loop-init}
{ ==============================================================================
--------------- INITIALIZE A SINGLE PROTOCOL (COMMON All-Isyn Feedback) -----------
================================================================================ }

procedure Init_Isyn_feedback_loop;
var setup, irec : string ; i, j, new_clamp_period : integer;
begin
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
   RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   RTneuron.execute('UD_loop.subsampling_freq = '+Rstr(subsampling_freq));
   RTneuron.execute('UD_loop.CMD_dur = '+Rstr(CMD_dur));
   RTneuron.execute('UD_loop.CMD_delay = '+Rstr(CMD_delay));
   
   // the choice is here !
   if Up_State_Stim then RTneuron.execute('UD_loop.up_stimulation = 0') else RTneuron.execute('UD_loop.up_stimulation = -1');
   if Down_State_Stim then RTneuron.execute('UD_loop.down_stimulation = 0') else RTneuron.execute('UD_loop.down_stimulation = -1');

   irec := CurrentsName[current_index];
   if Clamp_stim then
   begin
      new_clamp_period := Clamp_Periodicity;
      if irec='Excitatory Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(inhibitory_reversal)+'}}')
      else if irec='Inhibitory Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(excitatory_reversal)+'}}')
      else if irec='Intermediate Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(intermediate_reversal)+'}}')
      else if irec='Both Alternatively' then {alternate excitation and inhibition !}
      begin
	 if Clamp_Periodicity<2 then begin Messagebox('Need Clamp_Periodicity>2, we set Clamp_Periodicity:=2'); Clamp_Periodicity:=2; end;
	 new_clamp_period := Clamp_Periodicity+1;
	 RTneuron.execute('for i=0,1999 {if (i%'+Istr(new_clamp_period)+'==0) {UD_loop.cmd_vec[i]='+Rstr(inhibitory_reversal)+'}}');
	 RTneuron.execute('for i=0,1999 {if (i%'+Istr(new_clamp_period)+'==1) {UD_loop.cmd_vec[i]='+Rstr(excitatory_reversal)+'}}');
      end else
	 begin
	    new_clamp_period := 1; {no need to double the stim because of clamp !}
	    RTneuron.execute('for i=0,1999 {UD_loop.cmd_vec[i]=0.}'); {0 by default -> current at holding !}
	 end;
   end;
   
   if (ProtocolName[protocol_index]='Isyn-feedback--Opto-Stim-vs-Ctrl') then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity*new_clamp_periodiciy)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
	 { RTneuron.execute('for i = 0,1999 {\ UD_loop.cmd_vec[i]= 0'+Rstr(Amp_for_stim)+'!{\'); }
      end
   else if (ProtocolName[protocol_index]='Isyn-feedback--Stim-at-Various-Delays') then
      begin
	 if num_delay>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_delay-1 do RTneuron.execute('v1.append('+Rstr(min_delay+j*(max_delay-min_delay)/(num_delay-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.delay_vec[i]=v1.x[j%'+Istr(num_delay)+'] j=j+1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	    end else MessageBox('Need delay_num>1 !');
      end
   else if (ProtocolName[protocol_index]='Isyn-feedback--Stim-of-Various-Durations') then
      begin
	 if num_amp>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_duration-1 do RTneuron.execute('v1.append('+Rstr(min_duration+j*(max_duration-min_duration)/(num_duration-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.duration_vec[i]=v1.x[j%'+Istr(num_duration)+'] j=j+1 } }' );
	    end else MessageBox('Need delay_num>1 !');
      end;
end;

{$EDIT VC-Get-Synaptic-Currents}
{ ==============================================================================
--------------- Sampling Synaptic CUrrents under Spontaneous activity  ---------
================================================================================ }


procedure VCGSC_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False;  end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitVCGSCdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(PageHeight/2.));
   Definewindow(1, 0, Round(PageHeight/2.), PageWidth, Round(3.*PageHeight/4.));
   Definewindow(1, 0, Round(3.*PageHeight/4.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCGSC_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      getStringList(' Imaging : ', CurrentsNames, Currentslist, current_index,38);
      setText('______________________________________');
      setText('o==> Voltage-Clamp Parameters :');
      getRealA('Holding Potential (mV) +',holding_potential,10,3,200);
      getRealA('Excitatory Reversal (mV) +',excitatory_reversal,10,3,200);
      getRealA('Inhibitory Reversal (mV) +',inhibitory_reversal,10,3,200);
      getRealA('Intermediate Reversal (mV) +',intermediate_reversal,10,3,200);
      getRealA('Clamp Delay wrt Stim. (ms) ', CMD_delay,10,3,200);
      getRealA('Clamp Duration (ms) ', CMD_dur,10,3,200);
      getIntegerA('Clamping Periodicity (1 stim every XX cycles)', Clamp_Periodicity,6,200);
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;


{$EDIT Test-vs-Ctrl-Isyn-Feedback}
{ ==============================================================================
--------------- PHASE-LOCKED OPTOGENTICS IN UP-or-DOWN-STATE  ------------------
================================================================================ }

procedure UD_Isyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False;  end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUD_Isyn_dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCGSC_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      getStringList(' Imaging : ', CurrentsNames, Currentslist, current_index,38);
      setText('______________________________________');
      setText('o==> Voltage-Clamp Parameters :');
      getRealA('Holding Potential (mV) ',holding_potential,10,3,200);
      getRealA('Excitatory Reversal (+mV) +',excitatory_reversal,10,3,200);
      getRealA('Inhibitory Reversal (+mV) +',inhibitory_reversal,10,3,200);
      getRealA('Intermediate Reversal (+mV) +',intermediate_reversal,10,3,200);
      getRealA('Clamp Delay wrt Stim. (ms) ', CMD_delay,10,3,200);
      getRealA('Clamp Duration (ms) ', CMD_dur,10,3,200);
      getIntegerA('Clamping Periodicity (1 stim every XX cycles)', Clamp_Periodicity,6,200);
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity,6,200);
      getRealA('Delay after State start (ms) ', Delay_for_stim,10,3,200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim,10,3,200);
      getRealA('Stimulus Amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Delays-Isyn-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Delays  ------------------
================================================================================ }

procedure UDdelayIsyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdelayIsyn_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdelayIsyn_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> TTL parameters :');
      getRealA('Stimulus Amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Delays : Number', num_delay, 6, 200);
      getRealA('Varying Delays : Minimum (ms) ', min_delay, 10, 3, 200);
      getRealA('Varying Delays : Maximum (ms) ', max_delay, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim, 10, 3, 200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Durations-Isyn-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDdurationIsyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdurationIsyn_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdurationIsyn_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (ms)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> TTL parameters :');
      getRealA('Stimulus Amplitude (mV) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Durations : Number', num_duration, 6, 200);
      getRealA('Varying Durations : Minimum (ms) ', min_duration, 10, 3, 200);
      getRealA('Varying Durations : Maximum (ms) ', max_duration, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Main_dialog}
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure Update_Location;
var Hour2,Minute2,Second2,MilliSecond2 : smallint;
begin
   DecodeDateTime(Now,Year,Month,Day,Hour2,Minute2,Second2,MilliSecond2); {function to fetch date and time}
   case location_index of
     1: begin {setup}
	   PathOfTheDay := 'D:\Yann\DATA_elphy\Exps_Ste_and_Yann\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='\';
	   loadnrnPath := 'D:/home/yann/work/elphy/nrn_files/' ; 
	end; 
     2: begin {osx}
	   PathOfTheDay := 'Z:\Users\yzerlaut\DATA_elphy\Exps_Ste_and_Yann\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='/';
	   loadnrnPath := 'Z:/Users/yzerlaut/work/elphy/nrn_files/' ; 
	end;
     3: begin {linux}
	   PathOfTheDay := 'Z:\home\yann\DATA_elphy\Exps_Ste_and_Yann\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
	   sep :='/';
	   loadnrnPath := 'Z:/home/yann/work/elphy/nrn_files/' ; 
	end;
    end;
   if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
end;

procedure loadNRNmech;
begin
   dll_load := 'nrn_load_dll("'+loadnrnpath+'nrnmech.dll")';
   RTneuron.Execute(dll_load);
end;

procedure load_fake_Vm;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\Cell1_13909028.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/';
      txtfile2:=txtfile2+memo[memo.count];
      RTneuron.execute('objref ff, vv'); RTneuron.execute('vv = new Vector()');
      RTneuron.execute('ff = new File()'); RTneuron.execute('ff.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv.scanf(ff)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure load_fake_LFP;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\LFP1_25632003.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/';
      txtfile2:=txtfile2+memo[memo.count];
      RTneuron.execute('objref ff2, vv2'); RTneuron.execute('vv2 = new Vector()');
      RTneuron.execute('ff2 = new File()'); RTneuron.execute('ff2.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv2.scanf(ff2)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure MainDialog_update(n:integer); 
var proto : string ; memo : Tmemo; ii : integer;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}
   
  { if acquisition.IsRunning then acquisition.stop;  }
  MainDialog.updatevar; 
  case n of
    101: begin
	    proto := ProtocolName[protocol_index];
	    if proto='Vm-feedback--Spont-Act-Sampling'
	       then begin closedLoop:=False;clamp_index:=1;with_LFP:=False;InitSASdialog;InitializeChannels;Init_Vm_feedback_loop;end
	    else if proto='Vm-feedback--Opto-Stim-vs-Ctrl'
	       then begin closedLoop:=True;clamp_index:=1;with_LFP:=False;InitUD_dialog;end
	    else if proto='Vm-feedback--Stim-at-Various-Delays'
	       then begin closedLoop:=True; clamp_index:=1; with_LFP :=False ; InitUDdelayVm_dialog; end
	    else if proto='Vm-feedback--Stim-of-Various-Durations'
	       then begin closedLoop:=True; clamp_index:=1; with_LFP :=False ; InitUDdurationVm_dialog; end
	    else if proto='Vm-feedback--Stim-of-Various-Amplitudes'
	       then begin closedLoop:=True; clamp_index:=1; with_LFP :=False ; InitUDamplitudeVm_dialog; end
	    else if proto='Isyn-feedback--Spont-Act-Sampling'
	       then begin closedLoop:=False;clamp_index:=2;with_LFP:=False;Clamp_Stim:=False;Opto_Stim:=False;InitVCSASdialog;InitializeChannels;Init_Isyn_feedback_loop;end
	    else if proto='Isyn-feedback--Get-Syn-Currents'
	       then begin closedLoop:=True; clamp_index:=2; with_LFP:=False; Clamp_Stim:=True; Opto_Stim:=False; InitVCGSCdialog; end
	    else if proto='Isyn-feedback--Opto-Stim-vs-Ctrl'
	       then begin closedLoop:=True; clamp_index:=2; with_LFP :=False ; InitUD_Isyn_dialog; end
	    else if proto='Isyn-feedback--Stim-at-Various-Delays'
	       then begin closedLoop:=True; clamp_index:=2; with_LFP :=False ; InitUDdelayIsyn_dialog; end
	    else if proto='Isyn-feedback--Stim-of-Various-Durations'
	       then begin closedLoop:=True; clamp_index:=2; with_LFP :=False ; InitUDdurationIsyn_dialog; end;
         end;
    333	: load_fake_Vm;
    334	: load_fake_LFP;
    38: Update_Location;
    111 : SetGain1; 
    200 : begin
	     acquisition.InstallProcess(my_initprocess0, nil, nil, my_endProcess);
	     if SAVING then acquisition.startandsave else acquisition.start;
	  end;
    201 : acquisition.stop ;
    301 : comments := '';
    281 : LoadNRNmech;
    282 : begin RTneuron.Restart; loadNRNmech; end;
  end;
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -D  dangerous for division, e.g. freq) }
var setup : string ;
begin
DB.create;
protocol_index := 0;
//------------
   with MainDialog do
   begin
      create;
      getStringList(' Setup : ', SetupNames,'0|1|2|3',setup_index,37);  { Onevent flag ->199}
      getStringList(' Location : ', LocationNames,'0|1|2|3',location_index,38);  { Onevent flag ->199}
      getStringList(' Optogenetics : ', OptoNames, OptoList, opto_index, 39);  { Onevent flag ->199}
      getStringList(' Ampli-Mode : ', ClampNames, '0|1|2', clamp_index,40);  { Onevent flag ->199}
      if setup_index=2 then getCommandA('load *Vm* Datafile for Replay ',0,333);
      if setup_index=2 then getCommandA('load *LFP* Datafile for Replay ',0,334);
      getRealA('Acquisition freq. (kHz)',f_acq,3,2,785);
      setText('');
      OnEvent := MainDialog_update;
   
      getCommandA(' restart NEURON ',0,282);
      getCommandA(' load NEURON mech ',0,281);
      //getCommandA(' load NEURON model ',0,280); 

      setText(' ================================= ');
      setText(' ---------------< Protocol Selection >----------------- ');
      setText('');
      getStringList('  PROTOCOL  ', ProtoNames, Protonum, protocol_index,101);  { Onevent flag ->199}
   setText(' ================================= ');
   setText('');
   setText(' ==<| GAIN  |>== ');
   getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_index,111);
   setText('');
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='RT-optogenetics';
  end;
Maindialog.show;
end;



{$EDIT write_to_binary_file}

// ==================================================================== //
// ------------- From Elphy DataFile to a Binary File ----------------- //
// ----------- Metadata (TDBrecord,...) written in a JSON file  ------- //
// ==================================================================== //

var elphy_filename, binary_filename, json_filename, dat_directory, new_directory : string ;
var time:TdateTime; var size:longword; var att:integer ;    
     
procedure save_Binary_Json(elphy_filename:string);
var datafile : Tdatafile ; binfile : TbinaryFile; db_info : TDBrecord;
    channelID, episodeID, jj, ii, num : integer ;
    st, st2, name, ext, binary_filename, json_filename, binary_data_path, elphy_data_path : string;
   
begin
  // ---------------------------------------------------------
  // Finding the right path
  // ---------------------------------------------------------
   SplitFileNameEx(elphy_filename, elphy_data_path, name, num, ext);
   binary_data_path := elphy_data_path;
   if Pos('_ELPHY', elphy_data_path)>0 then 
   begin
      Delete(binary_data_path, Pos('_ELPHY', binary_data_path),Length('_ELPHY'));
      if not DirectoryExists(binary_data_path) then createDir(binary_data_path);
   end else MessageBox('Problem with directory:'+elphy_data_path);
   // then making a folder with the protocol name
   binary_data_path := binary_data_path+'\'+name;
   if not DirectoryExists(binary_data_path) then createDir(binary_data_path);
   // then simple name within folder
   binary_filename := binary_data_path+'\data.bin'; // we also change the extension
   json_filename := binary_data_path+'\metadata.json'; // we also change the extension
   // ---------------------------------------------------------
   // Copying the metadata files
   // ---------------------------------------------------------
   st := FirstFile(elphy_data_path+name+'\*.txt');
   while st<>'' do
   begin
      SplitFileNameEx(st, elphy_data_path, name, num, ext);
      if CopyFile(st,binary_data_path+'\'+name+ext) then StatusLineTxt(st+' copied') else MessageBox('File '+st+' not copied');
      st := NextFile;
   end;
   // ---------------------------------------------------------
   // Initializing files
   // ---------------------------------------------------------
   // loading Elphy datafile 
   datafile.create;
   datafile.NewFile(elphy_filename);
   // creating the binary file
   binfile.rewrite(binary_filename);
   // creating the json file
   openText(1, json_filename, False); // False for writing mode
   
   statuslineTxt('==> translating binary and json files for :'+elphy_filename);
   // ---------------------------------------------------------
   // Binary file writing ! 
   // ---------------------------------------------------------
   for episodeID:=1 to datafile.EpCount do
   begin 
      datafile.EpNum := episodeID ;                                                                                           
      for channelID := 1 to datafile.channelcount do
      begin
	 statuslineTxt('channel'+Istr(channelID)+', episode'+Istr(episodeID)+' v1[0]='+Rstr(datafile.v[1][datafile.v[1].Iend]));
	 datafile.v[channelID].SaveBinaryData(binfile, 5);
      end;
   end;
   
   // ---------------------------------------------------------
   // JSON file writing
   // ---------------------------------------------------------
   statuslineTxt('writing JSON file (matadata)');
   writelnText(1,'{'); // and we start the dict() structure
   db_info.create;  
   {we start by the informations stored in the TdbRecord associated to the acquisition file} 
   datafile.ReadDBFileInfo(db_info);
   for jj:=1 to db_info.count do
   begin  
      st:= db_info.Names[jj] ;
      st2:=db_info.Valstring[jj];
      writelnText(1,'"'+st+'":"'+st2+'",');
   TDBrecord('PG0.Exp_params').exp_type := 'Up-state-stim' ;
   end;        
   // then the gain of each channel
   for ii:=1 to datafile.ChannelCount do
      WriteLnText(1, '"gain_'+Istr(ii)+'" : "'+Rstr(datafile.v[ii].dY)+'",');
   // then the unit of each channel
   WriteLnText(1, '"unitX" : "'+datafile.v[1].unitX+'",'); // all channels have the same x unit
   for ii:=1 to datafile.ChannelCount do
      WriteLnText(1, '"unitY_'+Istr(ii)+'" : "'+datafile.v[ii].unitY+'",');
   // Then some other very usefull things:
   WriteLnText(1, '"ChannelCount" : "'+Istr(datafile.ChannelCount)+'",');
   WriteLnText(1, '"EpCount" : "'+Istr(datafile.EpCount)+'",');
   // finally we close the JSON file 
   writelnText(1,'"lastline":"no_value"}'); // we write a last line (just to have no comma)
   CloseText(1);
   // we close everything
   db_info.free; datafile.free; binfile.free;
   statuslineTxt('DONE !! ');
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}


procedure global_init;
var PathOfTheDay : string ;
begin

   RTneuron.resetParams;
   SetLocations; SetSetup; SetOpto; SetClamp;SetProtocolNames;SetCurrents;
   if location='RT-Setup' then begin setup_index :=1; location_index:=1 ; SAVING:=True; end;
   if location='Macbook' then begin location_index:=2 ; SAVING:=False; end;
   if setup='NEURON-sim' then setup_index :=3 else if setup='RT-Setup' then setup_index :=1 else setup_index :=2;
   global.create; Exp_Params.create;
   Update_Location;
   // those 3 parameters are obvious, we just keep them for compatibility with the other conventions
   clamp_index := 1;
   stim:=False;cont_choice:=True;
   TDBrecord('PG0.global').main_protocol:='RT-opto-Up-Down';
   TDBrecord('PG0.global').protocol:='';
   TDBrecord('PG0.Exp_params').exp_type := 'blank-exp';
   gain1 :=1 ; gain2 := 1. ;
   TDBrecord('PG0.global').FadvanceON := True ;  
   Color := cl_gray ;
end;

program LAUNCH_PROTOCOLS
{ see the documentation, for the details of the acquisition and RTneuron functions }
global_init ;
init_csts;
Init_Main_Dialog;
RTneuron.resetParams;
loadNRNmech;

program Convert_a_single_File
global_init;init_csts;
elphy_filename := PathOftheDay+'\*.DAT';
ChooseFile(elphy_filename);
save_Binary_Json(elphy_filename);

program Loop_over_files_in_root_folder
global_init;init_csts;
ChooseDirectory('Choose a ROOT directory to loop on ALL containing files', PathOftheDay, dat_directory);
elphy_filename := FirstFile(dat_directory+'\*.DAT', True, time, size, att);
while (elphy_filename<>'') do 
 begin
    if extractFileExt(elphy_filename)='.DAT' then 
    begin
     save_Binary_Json(elphy_filename);
    end;
    MessageBox(NextFile);
    elphy_filename := NextFile ;
 end;  
MessageBox('Loop over the ROOT folder terminated !');

