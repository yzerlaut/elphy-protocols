{$EDIT START}                                               
{=========================================== =============================
------- Master file for the optogenetics experiments  ---------
------- phase-locked on the slow cortical oscillation ---------
========================================================================}

Const
   ProtocolCount = 17 ; 
   OptoCount	 = 9 ; 
   location	 = 'RT-Setup' ; // switch to 'RT-Setup' for experiments !!
   setup	 = 'RT-Setup' ; // switch to 'RT-Setup' for experiments !!

  {		 = ======== COMMON VARIABLES ============ }
var
   protocol_index, setup_index, location_index, opto_index, clamp_index			 : integer ; 
   comments, PathOfTheDay, loadnrnPath, sep, root_dir					 : string ;
   MainDialog, dialog, StimDialog							 : Tdialog ;{ two dialogs for buttons and protocols}
   stim, closedLoop, SAVING , cont_choice						 : boolean ; 
   ProtocolName										 : array[1..protocolCount] of string; ProtoNames, ProtoNum:string;
   DB											 : Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond					 : smallint; {variables to fetch the date and time }
   gain1,gain2, episode_duration, acquisitionISI					 : real;
   gain1_index,gain2_index, max_EP_num							 : integer;
   dll_load										 : string ;
   f_acq, El, Cm, Rm, Rs, Rs2								 : real ; // parameters of the patch recording !
   hist, cum_proba									 : Tvector; 
   fraction_of_cumprob_for_Down_transition, fraction_of_cumprob_for_Up_transition	 : real;
   upward_threshold, downward_threshold, spike_threshold, subsampling_freq, Amp_for_Stim : real ;
   CMD_delay, CMD_dur, current_pulse							 : real ;
   UD_dialog										 : Tdialog ;
   Down_cursor, Up_cursor								 : Tcursor ;
   with_LFP, Clamp_stim, Opto_stim							 : boolean;
   Up_State_Stim, Down_State_Stim							 : boolean;
   flag_for_state_stimulation, current_index, Stim_Periodicity				 : integer;
   Delay_for_stim, Dur_for_stim								 : real;
   already_initiated									 : boolean ; // to know if we need to reinitialize the TDBrecord
   global, Exp_params									 : TDBrecord ;
   vec_params										 : Tvector ;
   LocationName										 : array[1..3] of string; LocationNames : string;
   OptoName										 : array[1..OptoCount] of string; OptoNames : string; OptoList : string;
   CurrentsName										 : array[0..5] of string; CurrentsNames : string; CurrentsList : string;
   SetupName										 : array[1..3] of string; SetupNames : string;
   ClampName										 : array[1..2] of string; ClampNames : string;
   min_delay, max_delay, min_duration, max_duration, min_amp, max_amp			 : real ;
   num_delay, num_duration, num_amp, clamp_periodicity					 : integer ;
   excitatory_reversal, inhibitory_reversal, intermediate_reversal, holding_potential	 : real;
   detector										 : Tdetector;
   
{ ============================================================================	   
  ----- Protocol And Constants Initialization --------------------------------
  ============================================================================ }
 
procedure SetProtocolNames;
var          
  i:integer;                           
begin
   ProtocolName[1]:= 'Seal-Test'; 
   ProtocolName[2]:= 'VC-Membrane Test'; 
   ProtocolName[3]:= 'IC-Membrane Test'; 
   ProtocolName[4]:= ''; 
   ProtocolName[5]:= 'Vm-feedback--Spont-Act-Sampling';
   ProtocolName[6]:= 'Vm-feedback--Current-Pulses';
   ProtocolName[7]:= 'Vm-feedback--Opto-Stim-vs-Ctrl'; 
   ProtocolName[8]:= 'Vm-feedback--oStim-at-Various-Delays'; 
   ProtocolName[9]:= 'Vm-feedback--oStim-of-Various-Durations'; 
   ProtocolName[10]:= 'Vm-feedback--oStim-of-Various-Amplitudes'; 
   ProtocolName[11]:= ''; 
   ProtocolName[12]:= 'Isyn-feedback--Spont-Act-Sampling'; 
   ProtocolName[13]:= 'Isyn-feedback--Get-Syn-Currents'; 
   ProtocolName[14]:= 'Isyn-feedback--Opto-Stim-vs-Ctrl'; 
   ProtocolName[15]:= 'Isyn-feedback--oStim-at-Various-Delays'; 
   ProtocolName[16]:= 'Isyn-feedback--oStim-of-Various-Durations'; 
   ProtocolName[17]:= 'Isyn-feedback--oStim-of-Various-Amplitudes';
   ProtoNames:=ProtocolName[1];
   ProtoNum :='0|1';
   for i:=2 to ProtocolCount do 
   begin ProtoNames:=ProtoNames+'|'+ProtocolName[i]; ProtoNum:=ProtoNum+'|'+Istr(i); end;
end;    


procedure SetLocations;
begin
   LocationName[1]:= 'RT-Setup'; 
   LocationName[2]:= 'OS-X'; 
   LocationName[3]:= 'Linux';
   LocationNames := 'RT-Setup|OS-X|Linux';
end;

procedure SetClamp;
begin
   ClampName[1]:= 'I-Clamp'; 
   ClampName[2]:= 'V-Clamp';
   ClampNames := 'I-Clamp|V-Clamp';
end;    

procedure SetSetup;
begin
   SetupName[1]:= 'RT-Setup'; 
   SetupName[2]:= 'Data-Replay'; 
   SetupName[3]:= 'NEURON-sim.';
   SetupNames := 'RT-Setup|Data-Replay|NEURON-sim.';
end;    

procedure SetOpto;
var i:integer;                           
begin
   OptoName[1]:= 'None'; 
   OptoName[2]:= 'Photo-Activation PV+'; 
   OptoName[3]:= 'Photo-Inhibition PV+'; 
   OptoName[4]:= 'Photo-Activation SOM+'; 
   OptoName[5]:= 'Photo-Inhibition SOM+'; 
   OptoName[6]:= 'Photo-Activation l5 pyr.'; 
   OptoName[7]:= 'Photo-Inhibition l5 pyr.'; 
   OptoName[8]:= 'Photo-Activation l2/3 pyr.'; 
   OptoName[9]:= 'Photo-Inhibition l2/3 pyr.';
   OptoList :='0';
   OptoNames:='';
   for i:=1 to OptoCount do 
   begin OptoNames:=OptoNames+'|'+OptoName[i]; Optolist:=Optolist+'|'+Istr(i); end;
end;    

procedure SetCurrents;
var i:integer;                           
begin
   CurrentsName[0]:= '';
   CurrentsName[1]:= 'Currents at Holding';
   CurrentsName[2]:= 'Excitatory Currents';
   CurrentsName[3]:= 'Inhibitory Currents';
   CurrentsName[4]:= 'Both Alternatively';
   CurrentsName[5]:= 'Intermediate Currents';
   CurrentsList :='0';
   CurrentsNames :='';
   for i:=1 to 4 do 
   begin CurrentsNames:=CurrentsNames+'|'+CurrentsName[i]; Currentslist:=Currentslist+'|'+Istr(i); end;
end;    

procedure init_windows;
begin
   DeleteAllPages('');
   InsertPage(1,'fake');DeleteAllPages('fake');
   InsertPage(1,'Intra-recording \& (phase-locked) Optogenetics');
   Page:=1; color:=cl_gray;
end;

procedure init_csts;
begin
   f_acq := 10. ;
   El := -70 ; Cm :=200 ; Rm :=100;
   upward_threshold :=-60;
   downward_threshold :=-65;
   subsampling_freq := 1.;
   spike_threshold := -30;
   Amp_for_Stim := 1;
   Stim_Periodicity := 3 ;
   Delay_for_stim := 30 ;
   Dur_for_stim := 100   ;
   fraction_of_cumprob_for_Down_transition := 0.3 ;
   fraction_of_cumprob_for_Up_transition := 0.6 ;
   flag_for_state_stimulation := 1;
   clamp_index :=1 ; opto_index :=1;
   min_delay := 0.; max_delay:=200; min_duration:=20; max_duration:=200;
   min_amp:=4.; max_amp:=6.;
   num_delay := 3; num_duration:= 3; num_amp:= 3;
   flag_for_state_stimulation := 1;
   CMD_delay :=-30.; CMD_dur :=370.; clamp_periodicity := 2;
   current_pulse := -50.;
   excitatory_reversal := 80; inhibitory_reversal := -10.;
   intermediate_reversal := (inhibitory_reversal+excitatory_reversal)/2.;
   current_index := 1; holding_potential := -70; episode_duration := 500;
end;
  
{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }

{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }

procedure UpdateCursor(n:integer);
begin
   downward_threshold := Down_Cursor.position[1];
   upward_threshold := Up_Cursor.position[1];
   UD_dialog.update;
end;

procedure UpdateCursor_in_NEURON;
begin
   if not with_LFP then RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   if not with_LFP then RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
end;

procedure FinalPlot_Settings;
begin
   v1.cpy:=1 ; v5.cpy := 1 ; v3.cpy:= 2 ; v4.cpy:= 2 ; v2.cpy:= 3 ; v6.cpy:= 3 ;  {we set the coupling value -D  to couple to future analysis} 
   v1.color := CL_Black ; v2.color := CL_Black ; v3.color := CL_Red ; v4.color := CL_Blue ; v5.color := CL_Red ; v6.color := CL_Red ;
   Down_Cursor.create ; Down_Cursor.style:=cs_Y;
   Up_Cursor.create ; Up_Cursor.style:=cs_Y;
   Up_cursor.color := CL_Blue; Down_cursor.color := CL_Red;
   if ClampName[clamp_index]='I-Clamp' then
   begin
      DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
      Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
   end else
   begin
      DOwn_Cursor.PosMin:=-200;Down_Cursor.PosMax:=1800;
      Up_Cursor.PosMin:=-200;Up_Cursor.PosMax:=1800;
   end;
   Down_Cursor.InstallSource(v1); 
   Down_Cursor.position[1]:=downward_threshold ;
   Down_Cursor.OnChange:=UpdateCursor;
   Up_Cursor.InstallSource(v1);
   Up_Cursor.position[1]:=upward_threshold ;
   Up_Cursor.OnChange:=UpdateCursor;
   if ClosedLoop then Up_Cursor.visible:=True else Up_Cursor.visible:=False;
   if ClosedLoop then Down_Cursor.visible:=True else Down_Cursor.visible:=False;
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ; v4.cpx:=1 ; v5.cpx:=1 ; v6.cpx:=1 ;
end;

procedure Set_DC_Channels_DEMO;   
var 
   i : integer; 
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}
   RTneuron.ResetParams;
   acquisition.ChannelCount := 6; 
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);

   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }
 
   {===============================================================}
   {        Creating the fake (simulated) cell                     }
   {===============================================================}
   
   RTneuron.FadvanceON:=True; { -->  NEURON calculus }  
   RTneuron.execute('create soma, lfp, fake_comp');
   RTneuron.execute('soma insert pas');
   RTneuron.execute('soma insert ca_ion'); {NEEDED in Voltage-Clamp, to have a non-Vm global variable...}
   RTneuron.execute('soma e_pas=-80.');
   RTneuron.execute('soma L=diam=79.8');
   RTneuron.Execute('soma g_pas = 5e-5');

   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
     acquisition.Channels[i].NrnSymbolName:='soma.v(0.5)'; {by default}
   end;
   
   { {\===============================================================!{\ }
   { {\        Recording channels                                     !{\ }
   { {\===============================================================!{\ }

   if ClampName[clamp_index]='I-Clamp' then
   begin {Current-Clamp}
      // channel 1 -->  primary ->  Vm
      acquisition.Channels[1].NrnSymbolName:='soma.v(0.5)';
      acquisition.Channels[1].unitY:='mV' ;
      addObject(1,1,v1); v1.title:='Vm(t)';
      // channel 2 -->  secondary ->  Iinj
      {to be removed on Setup RTneuron.DacChan[1].NrnSymbolName:='lfp.v(0.5)'}
      acquisition.Channels[2].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[2].unitY:='pA'; v2.title:='Iinj';
      if clamp_stim then addObject(1,2,v2); 
   end else {Voltage-Clamp}
   begin
      // channel 1 -->  primary ->  recorded Isyn
      acquisition.Channels[1].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[1].unitY:='pA' ;
      addObject(1,1,v1); v1.title:='Isyn';
      // channel 2 -->  secondary 
      acquisition.Channels[2].NrnSymbolName:='soma.v(0.5)'; {here replaced by pot.}
      { TO BE CHANGED FOR THE SECONDARY : acquisition.Channels[6].NrnSymbolName:='V_CMD';}
      acquisition.Channels[2].unitY:='mV'; v1.title:='V_CMD';
      if closedLoop then addObject(1,2,v2); 
   end;
   
   {===============================================================}
   {        Protocol Specific Mechanisms                           }
   {===============================================================}
   if ClosedLoop then
   begin
      if ClampName[clamp_index]='I-Clamp' then
      begin
	 RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(0.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.v_LP'; acquisition.Channels[5].unitY:='mV' ; v5.title:='Vm_low_passed'; addObject(1,1,v5);
      end
      else {Voltage-Clamp}
      begin
	 RTneuron.Execute('soma UD_loop = new Isyn_feedback_for_opto(0.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.i_LP'; acquisition.Channels[5].unitY:='pA' ; v5.title:='Isyn_low_passed'; addObject(1,1,v5);
	 { TO BE CHANGED FOR THE COMMAND : acquisition.Channels[6].NrnSymbolName:='soma.cao(0.5)';}
	 acquisition.Channels[6].NrnSymbolName:='vclamp.vc'; acquisition.Channels[6].unitY:='mV' ; v6.title:='Vm'; addObject(1,2,v6);
      end;
      acquisition.Channels[4].NrnSymbolName:='UD_loop.Up_flag'; acquisition.Channels[4].unitY:='mV' ; v4.title:='Up_flag'; 
      acquisition.Channels[3].NrnSymbolName:='UD_loop.V_LASER'; acquisition.Channels[3].unitY:='mV' ; v3.title:='TTL_Input';
      if clamp_stim then begin addObject(1,3,v4);  addObject(1,3,v3); end else begin addObject(1,2,v4);  addObject(1,2,v3); end;
   end else {fake compartment to still have UD_loop created}
   begin
      if ClampName[clamp_index]='I-Clamp' then  RTneuron.Execute('fake_comp UD_loop = new Vm_feedback_for_opto(0.5)')
      else RTneuron.Execute('fake_comp UD_loop = new Isyn_feedback_for_opto(0.5)');
   end;
   
   {===============================================================}
   {        Articifially Emulating Vm/lFP                          }
   {===============================================================}
   if SetupName[setup_index]='NEURON-sim.' then
      begin
   	 RTneuron.execute('soma insert hh_hippoc'); { RTneuron.execute('soma insert WangBuszaki'); }
   	 RTneuron.Execute('soma stim = new Exp2Syn_eiNtwk(0.5)');
   	 if ClampName[clamp_index]='V-Clamp' then
   	 begin {Voltage-Clamp}
   	    RTneuron.execute('objref vclamp');
   	    RTneuron.execute('soma vclamp = new myVClamp(0.5)');
   	    RTneuron.execute('vclamp.rs=5.'); {15 MOhm access resistance !}
   	 end;
      end
   else if SetupName[setup_index]='Data-Replay' then {*** only in Current-Clamp for now ***}
      begin
   	 RTneuron.execute('objref vclamp');
   	 RTneuron.execute('soma vclamp = new SEClamp(0.5)');
   	 RTneuron.execute('vclamp.rs=1e-2');
   	 RTneuron.execute('vclamp.dur1=1e9');
   	 if not with_LFP then RTneuron.execute('vv.play(&vclamp.amp1, '+Rstr(1./f_acq)+')');
   	 if with_LFP then RTneuron.execute('vv2.play(&lfp.v(0.5), '+Rstr(1./f_acq)+')');
      end;
   
   // Final graphical settings
   FinalPlot_Settings;
end;

procedure Set_DC_channels;
var
   i :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   RTneuron.ResetParams;
   acquisition.ChannelCount := 6; 
   RTneuron.Execute('objref UD_loop, stim'); // initialization so that they are put to 'nil' by default

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);
   
   acquisition.Fcontinuous:=cont_choice;
   acquisition.Fstimulate := stim ; {we DON'T stimulate in Elphy!!}
   if stim then
   begin
      acquisition.Fstimulate := True;
      acquisition.TriggerMode:= TM_internal;
      stimulator.ChannelCount:=1;
      stimulator.Channels[1].ChannelType:=TO_Neuron;
      stimulator.setByProg:=true; { mais on met le build ep plus loin }
   end else
   begin
      acquisition.Fstimulate := False;
      stimulator.ChannelCount:=0;
   end;
    
   acquisition.MaxEpCount := max_ep_num ;
   acquisition.EpDuration := episode_duration ;
   
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

   {===============================================================}
   {        Creating the cell                     }
   {===============================================================}
   
   RTneuron.FadvanceON:=closedLoop; { -->  NEURON calculus }  
   RTneuron.execute('create soma, lfp, fake_comp');
   RTneuron.execute('soma insert ca_ion'); {NEEDED in Voltage-Clamp, to have a non-Vm global variable...}

   for i:=1 to acquisition.ChannelCount do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
     acquisition.Channels[i].NrnSymbolName:='soma.v(0.5)'; {by default}
   end;
   
   { {\===============================================================!{\ }
   { {\        Recording channels                                     !{\ }
   { {\===============================================================!{\ }

   if ClampName[clamp_index]='I-Clamp' then
   begin {Current-Clamp}
      // channel 1 -->  primary ->  Vm
      RTneuron.AdcChan[0].NrnSymbolName:='soma.v(0.5)';
      RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1);
      acquisition.Channels[1].NrnSymbolName:='soma.v(0.5)';
      acquisition.Channels[1].unitY:='mV' ;
      addObject(1,1,v1); v1.title:='Vm(t)';
      // channel 2 -->  secondary ->  Iinj (real amplifier output)
      RTneuron.AdcChan[1].NrnSymbolName:='soma.cao(0.5)'; // secondary 
      RTneuron.AdcChan[1].setScale(0,32767,0,20000.0/gain2);
      acquisition.Channels[2].NrnSymbolName:='soma.cao(0.5)';
      acquisition.Channels[2].unitY:='pA'; v2.title:='Iinj';
      // COMMAND channel ->  Iinj (theoretical)
      RTneuron.DacChan[0].NrnSymbolName:='soma.cai(0.5)';
      RTneuron.DacChan[0].setScale(0,32767,0,4000.0); // command -> I clamp
      stimulator.Channels[1].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[5].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[5].unitY:='pA';
      if clamp_stim then addObject(1,2,v2); 
   end else {Voltage-Clamp}
   begin
      // channel 1 -->  primary ->  recorded Isyn
      RTneuron.AdcChan[0].NrnSymbolName:='soma.cai(0.5)';         
      RTneuron.AdcChan[0].setScale(0,32767,0,20000.0/gain1);
      acquisition.Channels[1].NrnSymbolName:='soma.cai(0.5)';
      acquisition.Channels[1].unitY:='pA' ;
      addObject(1,1,v1); v1.title:='Isyn';
      // channel 2 -->  secondary -> V_pipette (real amplifier control)
      RTneuron.AdcChan[1].NrnSymbolName:='soma.v(0.5)';  
      RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain2);
      acquisition.Channels[2].NrnSymbolName:='soma.v(0.5)';
      acquisition.Channels[2].unitY:='mV'; v1.title:='V_CMD';
      // COMMAND channel ->  V_pipette (theoretical)
      RTneuron.DacChan[0].NrnSymbolName:='soma.cao(0.5)';
      RTneuron.DacChan[0].setScale(0,32767,0,200.0); // command -> I clamp
      stimulator.Channels[1].NrnSymbolName:='soma.cao(0.5)';
      acquisition.Channels[6].NrnSymbolName:='soma.cao(0.5)';
      acquisition.Channels[6].unitY:='mV';
      if closedLoop or clamp_stim then addObject(1,2,v2); 
      if stim then addObject(1,2,v6); 
   end;
   
   {===============================================================}
   {        Protocol Specific Mechanisms                           }
   {===============================================================}
   if ClosedLoop then
   begin
      if ClampName[clamp_index]='I-Clamp' then
      begin
	 RTneuron.Execute('soma UD_loop = new Vm_feedback_for_opto(0.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.v_LP';
	 acquisition.Channels[5].unitY:='mV' ;
	 v5.title:='Vm_low_passed'; addObject(1,1,v5);
      end
      else {Voltage-Clamp}
      begin
	 RTneuron.Execute('soma UD_loop = new Isyn_feedback_for_opto(0.5)');
	 acquisition.Channels[5].NrnSymbolName:='UD_loop.i_LP';
	 acquisition.Channels[5].unitY:='pA' ;
	 v5.title:='Isyn_low_passed'; addObject(1,1,v5);
	 { acquisition.Channels[6].NrnSymbolName:='soma.cao(0.5)'; }
	 { acquisition.Channels[6].unitY:='mV' ; v6.title:='Vcmd'; addObject(1,2,v6); }
      end;
      acquisition.Channels[4].NrnSymbolName:='UD_loop.Up_flag';
      acquisition.Channels[4].unitY:='mV' ; v4.title:='Up_flag'; 
      acquisition.Channels[3].NrnSymbolName:='UD_loop.V_LASER';
      acquisition.Channels[3].unitY:='mV' ; v3.title:='TTL_Input';
      // LASER COMMAND OUTPUT
      RTneuron.DacChan[1].NrnSymbolName:='UD_loop.V_LASER';
      RTneuron.DacChan[1].setScale(0,32767,0,10.0); 
      if clamp_stim then begin addObject(1,3,v4); addObject(1,3,v3); end
          else begin addObject(1,2,v4);  addObject(1,2,v3); end;
   end else {fake compartment to still have UD_loop created}
   begin
      if ClampName[clamp_index]='I-Clamp' then  RTneuron.Execute('fake_comp UD_loop = new Vm_feedback_for_opto(0.5)')
      else RTneuron.Execute('fake_comp UD_loop = new Isyn_feedback_for_opto(0.5)');
   end;
   
   // Final graphical settings
   FinalPlot_Settings;

end;

procedure set_dac_to_zero;
begin
   Rtneuron.DacChan[0].UseHoldingValue:=True;    
   Rtneuron.DacChan[1].UseHoldingValue:=True;  
   Rtneuron.DacChan[0].HoldingValue:=0;
   Rtneuron.DacChan[1].HoldingValue:=0;
   with stimulator do
   begin
      stimulator.setValue(0,0,0,0);
      stimulator.setValue(0,0,1,0);
      stimulator.setValue(0,1,0,0);
   end;
end;

{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments + Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }
 
procedure write_Exp_params; {to be used by all subsequent protocols}
begin
   TDBrecord('PG0.global').f_acq := f_acq ; 
   TDBrecord('PG0.global').PathOftheDay := PathOftheDay ; 
   TDBrecord('PG0.global').loadnrnPath := loadnrnPath ; 
   TDBrecord('PG0.global').location:=LocationName[location_index]; 
   TDBrecord('PG0.global').episode_duration :=  episode_duration ;
   TDBrecord('PG0.global').max_EP_num :=max_EP_num ;
   TDBrecord('PG0.global').acquisitionISI:=acquisitionISI ;  // small break between the stims
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Down_transition := fraction_of_cumprob_for_Down_transition;
   TDBrecord('PG0.Exp_params').fraction_of_cumprob_for_Up_transition := fraction_of_cumprob_for_Up_transition;
   TDBrecord('PG0.Exp_params').upward_threshold := upward_threshold ;
   TDBrecord('PG0.Exp_params').downward_threshold := downward_threshold ;
   TDBrecord('PG0.Exp_params').subsampling_freq := subsampling_freq;
   TDBrecord('PG0.Exp_params').spike_threshold :=  spike_threshold;
   TDBrecord('PG0.Exp_params').Amp_for_Stim := Amp_for_Stim;
   TDBrecord('PG0.Exp_params').Stim_Periodicity := Stim_Periodicity ;
   TDBrecord('PG0.Exp_params').Delay_for_stim := Delay_for_stim  ;
   TDBrecord('PG0.Exp_params').Dur_for_stim := Dur_for_stim    ;
   TDBrecord('PG0.Exp_params').stim := stim;
   TDBrecord('PG0.Exp_params').closedLoop :=closedLoop;
   TDBrecord('PG0.Exp_params').gain1 := gain1 ;
   TDBrecord('PG0.Exp_params').gain2 := gain2;
   TDBrecord('PG0.Exp_params').with_LFP:=with_LFP;
   TDBrecord('PG0.Exp_params').Up_State_Stim:=Up_State_Stim;
   TDBrecord('PG0.Exp_params').Down_State_Stim := Down_State_Stim ;
   TDBrecord('PG0.Exp_params').flag_for_state_stimulation:=flag_for_state_stimulation;
   TDBrecord('PG0.Exp_params').setup:=SetupName[setup_index];
   TDBrecord('PG0.Exp_params').clamp := ClampName[clamp_index];
   TDBrecord('PG0.Exp_params').optogenetics := OptoName[opto_index];
   TDBrecord('PG0.Exp_params').location := LocationName[location_index];
   TDBrecord('PG0.Exp_params').current := CurrentsName[current_index];
   TDBrecord('PG0.Exp_params').min_delay:=min_delay;
   TDBrecord('PG0.Exp_params').max_delay:=max_delay;
   TDBrecord('PG0.Exp_params').num_delay:=num_delay;
   TDBrecord('PG0.Exp_params').min_duration:=min_duration;
   TDBrecord('PG0.Exp_params').max_duration:=max_duration;
   TDBrecord('PG0.Exp_params').num_duration:=num_duration;
   TDBrecord('PG0.Exp_params').min_amp:=min_amp;
   TDBrecord('PG0.Exp_params').max_amp:=max_amp;
   TDBrecord('PG0.Exp_params').num_amp:=num_amp;
   TDBrecord('PG0.Exp_params').CMD_delay :=CMD_delay;
   TDBrecord('PG0.Exp_params').CMD_dur :=CMD_dur;
   TDBrecord('PG0.Exp_params').current_pulse :=current_pulse;
   TDBrecord('PG0.Exp_params').clamp_periodicity := clamp_periodicity;
   TDBrecord('PG0.Exp_params').excitatory_reversal := excitatory_reversal;
   TDBrecord('PG0.Exp_params').inhibitory_reversal := inhibitory_reversal;
   TDBrecord('PG0.Exp_params').intermediate_reversal := intermediate_reversal;
end;

procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_index];
  DB.Comments := comments ; {comments is a global variable }
  DB.Day := Day ; DB.Month := Month ; DB.Year := Year ;
  DB.Hour := Hour ; DB.Minute := Minute ; DB.SEcond := Second ;    
end;

procedure my_initprocess0;
var protocol, filename  : string ; {variables to fetch the date and time }
begin
   protocol := ProtocolName[protocol_index];
   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
   filename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
   TDBrecord('PG0.Exp_params').exp_type := protocol;
   TDBrecord('PG0.Exp_params').filename := filename;
   write_Exp_params; 
   FillDBinfo(DB); 
   if SAVING then acquisition.writeDBfileinfo(DB);
   acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol ;
end;

procedure Get_Transitions_Times;
var Path, protocol, st : string ; i, imax : integer;
begin
   protocol := ProtocolName[protocol_index];
   Path := PathOfTheDay ;
   Path := Path+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'_'+protocol+'.txt';
   openText(1,Path,false);
   imax := ROund(RTneuron.getNRNvalue('UD_loop.i_up')); 
   for i:=0 to imax+4 do {4 transitions more for security to catch additional down states}
      begin
	 st := '';
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.up_transition_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.down_transition_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.stim_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.delay_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.duration_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.amplitude_vec'+'['+Istr(i)+']'), 1, 6) + Chr(9);
	 st := st + Rstr(RTneuron.getNRNvalue('UD_loop.cmd_vec'+'['+Istr(i)+']'), 1, 6);
	 writelnText(1,st);
      end;
   closeText(1);
end;

procedure my_endprocess;
begin
   set_dac_to_zero;
   if SAVING and ClosedLoop then Get_Transitions_Times;
end;

{$EDIT artificial-UD}
{ ==============================================================================
--------------- CREATING ARTIFICIAL Up & Down States --------------------
================================================================================ }

procedure Initialize_Simulated_Up_and_Down_States;
      // we set a sequence of Up and Down states !!
begin
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim(0.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('soma nsI = new NetStim(0.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.delay = 0');
   RTneuron.execute('nsE.seed(0)');
   RTneuron.execute('nsI.seed(2)');
   RTneuron.execute('Qe_up = 0.004');
   RTneuron.execute('Qe_down = 0.001');
   RTneuron.execute('Qi_up = -0.003');
   RTneuron.execute('Qi_down = -0.0032');
   {synaptic weights}
   RTneuron.execute('ncE.weight = Qe_up');
   RTneuron.execute('ncI.weight = Qi_up'); {NEGATIVE FLAG !!!}
   {then synaptic times}
   RTneuron.execute('stim.tauE = 5');
   RTneuron.execute('stim.tauI = 10');
   {firing frequencies}
   RTneuron.execute('nsE.interval = 0.8');
   RTneuron.execute('nsI.interval = .5');
   {current to bring at mean}
   RTneuron.execute('objref fih, rand, cvode');
   RTneuron.execute('rand = new Random()');
   RTneuron.execute('rand.normal(300,150*150)');
   RTneuron.execute('cvode = new CVode()');
   RTneuron.execute('fih = new FInitializeHandler(1, "f1()")');
   RTneuron.execute('tt = 0.');
   RTneuron.execute('proc f2() {ncE.weight = (Qe_up-ncE.weight)*Qe_up/(Qe_up-Qe_down) - (Qe_down-ncE.weight)*Qe_down/(Qe_up-Qe_down)}');
   RTneuron.execute('proc f3() {ncI.weight = (Qi_up-ncI.weight)*Qi_up/(Qi_up-Qi_down) - (Qi_down-ncI.weight)*Qi_down/(Qi_up-Qi_down)}');
   RTneuron.execute('proc f1() {for i=0, 500 {tt = tt+rand.repick() cvode.event(tt, "f2() f3()")}}');
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
begin
    case Gain1_index of
    1: Gain1 := 1.0; 2: Gain1 := 2.0;
    3: Gain1 := 5.0; 4: Gain1 := 10.0;
    5: Gain1 := 20.0; 6: Gain1 := 50.0;
    7: Gain1 := 100.0; 8: Gain1 := 200.0;
    9: Gain1 := 500.0; 10: Gain1 := 1000.0;
    11: Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure SetGain2; {TO BE ADJUSTED !!!}
begin
    case Gain2_index of
    1: Gain2 := 1.0; 2: Gain2 := 2.0;
    3: Gain2 := 5.0; 4: Gain2 := 10.0;
    5: Gain2 := 20.0; 6: Gain2 := 50.0;
    7: Gain2 := 100.0; 8: Gain2 := 200.0;
    9: Gain2 := 500.0; 10: Gain2 := 1000.0;
    11: Gain2 := 2000.0;
    end;
end;   {SetGain2}

procedure InitializeChannels;
begin
   if SetupName[location_index]='RT-Setup' then Set_DC_channels else Set_DC_channels_DEMO;
   if SetupName[setup_index]='NEURON-sim.' then Initialize_Simulated_Up_and_Down_States; // Fake data
   // the initialization
   RTneuron.execute('finitialize('+Rstr(El)+')');
end;


{$EDIT seal_test}
{ ==============================================================================
--------------- BUILDING THE SEAL TEST PROCEDURE AND DIALOG --------------------
================================================================================ }

var 
  tseal_vec : Tvector ; rseal_vec : Tvector ; iseal_vec : Tvector ; 
  { vectors to monitor the evolution of the ileak and resistance of the seal in time } 
  seal_memo : Tmemo ;   rseal_graph : Tgraph ; iseal_graph : Tgraph ;
  i_baseline : real ; i_jump : real ; Rseal : real ; t0_seal : real ;
  amp_seal, del_seal, dur_seal : real ;

procedure Build_SealPulse(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  vec.fill(0); vec.fill1(amp_seal,del_seal+vec.Istart,del_seal+dur_seal+vec.Istart);
end;

procedure seal_process;
var tt : Tvector ; amplifier : string ;
begin
    DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in }

    tt.create; Vcopy(v1,tt) ; i_baseline := tt.mean(1,del_seal-1); {constantes a ajuster en fonction des parametres du pulse}
    i_jump := tt.mean(del_seal+20,del_seal+dur_seal-5);
    if (i_jump-i_baseline)<>0 then Rseal := amp_seal/(i_jump-i_baseline)*1000 else Rseal:=0 ; 

    rseal_vec.addtolist(Rseal); iseal_vec.addtolist(i_baseline);
    tseal_vec.addtolist(60*Hour + Minute + Second/60 + MilliSecond/60/1000-t0_seal);
    rseal_vec.refresh;iseal_vec.refresh;tseal_vec.refresh;
    
    rseal_graph.modify(tseal_vec,rseal_vec,tseal_vec.Istart,tseal_vec.Iend);
    rseal_graph.refresh; rseal_graph.SetWorld(tseal_vec.Ymin,rseal_vec.Ymin,tseal_vec.Ymax,rseal_vec.Ymax);
    iseal_graph.modify(tseal_vec,iseal_vec,tseal_vec.Istart,tseal_vec.Iend);
    iseal_graph.refresh; iseal_graph.SetWorld(tseal_vec.Ymin,iseal_vec.Ymin,tseal_vec.Ymax,iseal_vec.Ymax);
    
    seal_memo.lines[3]:='Rseal= '+Rstr(Rseal,6,3)+' Mohm';
    seal_memo.lines[5]:='I baseline= '+Rstr(i_baseline,6,3)+' pA';
    seal_memo.refresh;
end;

procedure Prepare_SealTest;
begin
   closedLoop:=False; opto_stim:=False; clamp_stim:=True;
   with_LFP:=False;
   clamp_index := 2 ; // Voltage Clamp
   cont_choice := False ; 
   episode_duration :=  2*del_seal+dur_seal ;
   max_EP_num :=0;
   stim := True;
   acquisitionISI:=0.5 ;  // small beak between the stims
   {then we initialize the stimulation}
   InitializeChannels; // we can initialize the channels
   stimulator.Channels[1].BuildEp := Build_SealPulse ; 
   stimulator.initVectors;
   acquisition.InstallProcess(my_initprocess0, nil, seal_process, set_dac_to_zero);
end;

procedure SealTest_Event(n:integer);
var amplifier : string ; 
begin    
   ud_dialog.updatevar;
   case n of 
   201 : Prepare_SealTest ;
   end;
end;

procedure SealTest_Init;
begin {when we modify the dialog, we adjust the stimulation params}

  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), Round(PageWidth/3), PageHeight);
  Definewindow(1, Round(PageWidth/3), Round(PageHeight*2/3), Round(2*PageWidth/3), PageHeight);
  Definewindow(1, Round(2*PageWidth/3), Round(PageHeight*2/3), Round(5*PageWidth/6), PageHeight);
  Definewindow(1, Round(5*PageWidth/6), Round(PageHeight*2/3), PageWidth, PageHeight);
  color:=cl_gray;

  amp_seal :=-5; del_seal :=25 ; dur_seal := 100;  {pulse parameters}
  {then we display the channels}
  addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);
  {then memo to display the values}
  seal_memo.create(''); seal_memo.font.name:='Times New Roman'; seal_memo.font.size:=13;
  seal_memo.font.color:=rgb(0,0,0);  seal_memo.font.style:=fs_bold;
  seal_memo.lines[3]:='Rseal= '+Rstr(Rseal,6,3)+' Mohm';
  seal_memo.lines[5]:='I baseline= '+Rstr(i_baseline,6,3)+' pA';
  addObject(1,5,seal_memo);
  {then the graph to display the time evolution of the parameters}
  tseal_vec.create(t_single,0,-1);iseal_vec.create(t_single,0,-1);rseal_vec.create(t_single,0,-1);
  rseal_graph.create(tseal_vec,rseal_vec,0,0); rseal_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
  iseal_graph.create(tseal_vec,iseal_vec,0,0); iseal_graph.Mode := DM_LINE_DIAMOND ;
  addobject(1,3,rseal_graph);  {then we plot the vector}
  addobject(1,4,iseal_graph);  {then we plot the vector} 
  
  {finally the small dialog fot the parameters and the initialisation}
  ud_dialog.create ;
  ud_dialog.getRealA(' Pulse size (mV)',amp_seal,3,1,99);
  ud_dialog.getRealA(' onset (ms)',del_seal,3,1,99);
  ud_dialog.getRealA(' duration (ms)',dur_seal,3,1,99);
  ud_dialog.getCommandA('  init() ',0,999);
  ud_dialog.OnEvent:=SealTest_event ;
  AddDialog(1,6,ud_dialog); 
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in }
  t0_seal := 60*Hour + Minute + Second/60 + MilliSecond/60/1000;
  Prepare_SealTest ; // first initialization
end;

{$EDIT VC_membrane_test}
{ ==============================================================================
--------------- BUILDING THE MEMBRANE TEST IN VOLTAGE CLAMP --------------------
================================================================================ }

{ Membrane Test procedure : Voltage Clamp test }
var
  VCMT_fit : TcurveFitting;  VCMT_memo:Tmemo;  lVer:TlineVer;  lHor:TlineHor;
  VCMT_moy : Taverage; rs_vec : Tvector ; tmem_vec : Tvector ; 
  t0_mem : real ; rs_graph : Tgraph ;  
  mt_cursor : Tcursor ; VCMT_interStim : real ;
  VCMT_amp, VCMT_t1, VCMT_t2, VCMT_t3, VCMT_t4 : real ; {this will define the coltage s}

procedure Build_VCMTstim(seq:longint;var vec:Tvector); 
begin
   vec.fill(0);
   vec.fill1(-VCMT_amp/2,vec.Istart+VCMT_t1,vec.Istart+VCMT_t2);
   vec.fill1(VCMT_amp/2,vec.Istart+VCMT_t2,vec.Istart+VCMT_t3);
   vec.fill1(-VCMT_amp/2,vec.Istart+VCMT_t3,vec.Istart+VCMT_t4);
end;
  
procedure RsCm(var vec_arg:Tvector;var rm,rs,cm,rs2:real;cursor : Boolean); 
  var
    Ibase,Iend,integral_response,DI,Ijump,tau:real;
    integral_resist,integral_capa : real ;
    x0,x,xa,xb,Tint:real;
    xorg:real;

  begin
    Ibase:= vec_arg.mean(VCMT_t2-11,VCMT_t2-1); {mean over 10ms}
    Iend:= vec_arg.mean(VCMT_t3-11,VCMT_t3-1);  {mean over 10ms}
    DI := Iend-Ibase ; {DI positif ou negatif}
    if DI = 0 then DI:=1e-9 ; 
    if DI<0 then 
       begin
          Ijump:=mini(vec_arg,VCMT_t2-5,VCMT_t2+5)-Ibase;
          x0:=miniX(vec_arg,VCMT_t2,VCMT_t2+5);
          xorg:=FirstCrossing(vec_arg,VCMT_t2-5,VCMT_t2+5,Ibase+Ijump/2,false); {false for downward}
       end;
    if DI>0 then 
       begin
          Ijump:=maxi(vec_arg,VCMT_t2-5,VCMT_t2+5)-Ibase;
          x0:=maxiX(vec_arg,VCMT_t2,VCMT_t2+5);
          xorg:=FirstCrossing(vec_arg,VCMT_t2-5,VCMT_t2+5,Ibase+Ijump/2,true); {true for upward}
       end;

    VCMT_fit.Xorigin:=xorg;

    if cursor then begin VCMT_fit.xstartFit:=mt_cursor.position[1]; VCMT_fit.XendFit:=mt_cursor.position[2]; end 
    else begin VCMT_fit.xstartFit:=x0+v1.convX(1); VCMT_fit.XendFit:=VCMT_t3-1;end;

    VCMT_fit.execute; VCMT_fit.refresh ;

    tau:=VCMT_fit.Param['a2']; {in the fit we only use the time constant value}
    if tau<0 then tau:=-1/tau else tau:=1E9;

    Tint := VCMT_t3-VCMT_t2 ; {length of the integral} 
    integral_response := Integral(vec_arg,VCMT_t2,VCMT_t2+Tint,VCMT_t2-20,VCMT_t2-1);
    integral_resist := DI*(Tint+Tau*(exp(-Tint/tau)-1)); {theoretical value given tau and Di, do the calculus}
    integral_capa := integral_response  - integral_resist ;
    {then we can deduce all the parameters :}
    if integral_capa<>0 then rs:=tau*VCMT_amp/integral_capa*1000.0 else RS:=1E6;   { ms*mV / ms*pA *1000 -> Mohm } 
    if DI<>0 then Rm:=VCMT_amp/DI*1000-Rs else Rm:=1E6;  { mV/pA*1000 -> Mohm  }
    Cm:=tau*(Rs+Rm)/(Rm*Rs)*1000; {ms/Mohm*1000-> pF }
    
    lHor.y:=Iend;
    lVer.x:=xOrg;
    with VCMT_memo do
    begin
      lines[3]:='tau='+Rstr(tau,12,3)+' ms';
      lines[4]:='rs= '+Rstr(RS,12,3)+' Mohm';
      lines[5]:='rm= '+Rstr(rm,12,3)+' Mohm';
      lines[6]:='Cm= '+Rstr(Cm,12,3)+' pF';
    end;
    VCMT_memo.refresh;
end;


{ ------------- then, Procedures of the Acquisition Processes (see doc) ----------}   

procedure mt_initprocess;
begin
  VCMT_moy.create(t_single,v1.Istart,v1.Iend);
  VCMT_moy.cpx:=1;  VCMT_moy.cpy:=1;  VCMT_moy.color:=cl_blue;
  VCMT_moy.setWorld(VCMT_t2-5,v1.Ymin,VCMT_t2+5,v1.Ymax);
  addObject(1,1,VCMT_moy);

  VCMT_fit.create('');
  VCMT_fit.standardModel:=fm_expC1 {fm_poly5};
  VCMT_fit.initialize:=true;  VCMT_fit.reset;  VCMT_fit.setYdata(VCMT_moy);  VCMT_fit.MaxIt:=30;

  VCMT_fit.setWorld(VCMT_moy.xmin,VCMT_moy.ymin,VCMT_moy.xmax,VCMT_moy.ymax);
  VCMT_fit.cpx:=1;  VCMT_fit.cpy:=1;  VCMT_fit.matchVector(v1);  VCMT_fit.color:=cl_red;
  addObject(1,1,VCMT_fit);
end;

procedure mt_process;
begin
     VCMT_moy.add(v1); {we add each episode result to the average}
end;

procedure mt_endprocess;
begin
  rsCm(VCMT_moy,rm,rs,cm,rs2,False); { and we process the analysis}
  rs_vec.addtolist(rs); rs_vec.refresh;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in }
  tmem_vec.addtolist(0.001*(1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond -t0_mem)); tmem_vec.refresh;
  rs_graph.modify(tmem_vec,rs_vec,rs_vec.Istart,rs_vec.Iend); rs_graph.refresh ;
  { set_dac_to_zero; }
end;


procedure prepare_mt;
begin
   {we write all the relevant global informations}
   clamp_index := 2 ;
   cont_choice := False ; 
   episode_duration :=  VCMT_t1+VCMT_t4 ;
   max_EP_num := 10 ; // 10 episodes !!
   stim := True ;
   acquisitionISI:= VCMT_interStim ;  // small break between the stims
   TDBrecord('PG0.Exp_Params').clear;
   TDBrecord('PG0.Exp_Params').exp_type:='VC_MembraneTest';
   TDBrecord('PG0.Exp_Params').pulse_amplitude:=VCMT_amp;
   TDBrecord('PG0.Exp_params').t1:=VCMT_t1;
   TDBrecord('PG0.Exp_params').t2:=VCMT_t2;
   TDBrecord('PG0.Exp_params').t3:=VCMT_t3;
   TDBrecord('PG0.Exp_params').t4:=VCMT_t4;
   {then we initialize the stimulation}
   InitializeChannels; // we can initialize the channels
   stimulator.Channels[1].BuildEp := Build_VCMTstim ; 
   stimulator.initVectors;
   acquisition.InstallProcess(my_initprocess0, mt_initprocess, mt_process, mt_endprocess);
end;
         

procedure Set_global_RsRmCm;
begin
     TDBrecord('PG0.Exp_Params').Rs := Rs ;
     TDBrecord('PG0.Exp_Params').Rm := Rm ;
     TDBrecord('PG0.Exp_Params').Cm := Cm ;
end;

procedure VCMT_Event(n:integer);
var amplifier : string ; 
begin    
   ud_dialog.updatevar;
   case n of 
   999	: prepare_mt ; 
   998	: rsCm(VCMT_moy,rm,rs,cm,rs2,True);
   997	: Set_global_RsRmCm;
   end;
end;

procedure VCMembTest_Init; {executed only when ze choose the protocol }
begin
  // initialize windows 
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

   VCMT_amp:=-5; VCMT_t1:=20; VCMT_t2:=40; VCMT_t3:=60; VCMT_t4:=80;  // values charlotte
   VCMT_interStim := 0.25 ;
   TDBrecord('PG0.global').clamp_index := 2 ;
   {then we display the channels}
   addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);

   rs_vec.create(t_single,0,-1) ; tmem_vec.create(t_single,0,-1) ; { we initialize the vector of the rs values }
   rs_graph.create(tmem_vec,rs_vec,0,0); rs_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
   //addobject(1,3,rs_graph);

   lVer.create('',0,cl_black,0); lHor.create('',0,cl_black,0);
   addObject(1,1,lVer); addObject(1,1,lHor);

   VCMT_memo.create(''); VCMT_memo.font.name:='Times New Roman'; VCMT_memo.font.size:=11;
   VCMT_memo.font.color:=rgb(0,0,0);  VCMT_memo.font.style:=fs_bold;
   addObject(1,4,VCMT_memo);

   ud_dialog.create ;
   ud_dialog.getRealA(' Pulse size (mV)',VCMT_amp,3,1,99);
   ud_dialog.getRealA('t1',VCMT_t1,3,1,99);
   ud_dialog.getRealA('t2',VCMT_t2,3,1,99);
   ud_dialog.getRealA('t3',VCMT_t3,3,1,99);
   ud_dialog.getRealA('t4',VCMT_t4,3,1,99);
   ud_dialog.getRealA('inter-Stim-interval (s)',VCMT_interStim,3,1,99);
   ud_dialog.getCommandA('  init() ',0,999);
   ud_dialog.setText('');
   ud_dialog.getCommandA(' Fit "Tau" with cursors ',0,998);
   ud_dialog.getCommandA(' Set Global Rs, Rm & Cm ',0,997);
   ud_dialog.OnEvent:=VCMT_event ;
   AddDialog(1,5,ud_dialog); 

   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in }
   t0_mem := 1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond;

   mt_cursor.create ; mt_cursor.DoubleCursor:=True ; mt_cursor.style:=cs_X ;
   mt_cursor.position[1]:=VCMT_t2 ; mt_cursor.position[2]:=VCMT_t2+3 ; 
   mt_cursor.InstallSource(v1);  mt_cursor.visible:=True ; 
   prepare_mt ; // first initialisation !!! 
end;


{$EDIT IC_membrane_test}
{ ==============================================================================
--------------- BUILDING THE MEMBRANE TEST IN CURRENT CLAMP --------------------
================================================================================ }

{ Membrane Test procedure : Voltage Clamp test }
var
  rm_vec : Tvector ; rm_graph : Tgraph ; 
  ICMT_amp, ICMT_t1, ICMT_t2, ICMT_interStim : real ;
  ICMT_moy : Taverage ; ICMT_fit : TcurveFitting ;
  ICMT_cursor : Tcursor ; ICMT_memo : Tmemo ;
  bridge, holding : real ;
  

procedure Build_ICMTstim(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin 
  vec.fill(0); vec.fill1(ICMT_amp,ICMT_t1+vec.Istart,ICMT_t2+vec.Istart);
end;
  

{procedure to calculate rm and cm, from the average voltage response...}  
procedure IC_RmCm(var vec:Tvector;var rm,cm:real;with_cursor : Boolean); 
  var
    V0,Vjump,Vs,Vbase,tau:real;
    x0:real; x,xa,xb:real; xorg:real; 
    {version valable uniquement pour un pulse n?gatif }
  begin
    V0:=vec.mean(1,ICMT_t1-2);  El :=V0 ;
    ICMT_fit.Xorigin:=ICMT_t1;

    if with_cursor then begin ICMT_fit.xstartFit:=ICMT_cursor.position[1]; ICMT_fit.XendFit:=ICMT_cursor.position[2]; end 
    else begin ICMT_fit.xstartFit:=ICMT_t1; ICMT_fit.XendFit:=ICMT_t2;end;

    ICMT_fit.execute; ICMT_fit.refresh ;
    {Model : a1*exp(a2*x)+a3 ---> a1=-Rm*I0, a3=El+Rm*I0, a2=-1/(Rm*Cm)}
    tau:=ICMT_fit.Param['a2'];  if tau<0 then tau:=-1/tau else tau:=1E9;
    Vs:=ICMT_fit.Param['a1'];
    if Vs<>0 then Rm:=-Vs/ICMT_amp*1000 else Rm:=1e9;
    Cm:=tau/Rm*1000; { pF }

    with ICMT_memo do
    begin
      lines[3]:='tau='+Rstr(tau,12,3)+' ms';
      lines[5]:='rm= '+Rstr(rm,12,3)+' Mohm';
      lines[6]:='Cm= '+Rstr(Cm,12,3)+' pF';
      lines[8]:='El= '+Rstr(El,12,3)+' mV';
    end;
    ICMT_memo.refresh;
  end;                                           


{ ------------- then, Procedures of the Acquisition Processes (see doc) ----------}   
 

procedure mtic_initprocess;
begin
  ICMT_moy.create(t_single,v1.Istart,v1.Iend);
  ICMT_moy.cpx:=1;  ICMT_moy.cpy:=1;  ICMT_moy.color:=cl_blue;
  
  ICMT_fit.create('');
  ICMT_fit.standardModel:=fm_expC1 {fm_poly5};
  ICMT_fit.initialize:=true;  ICMT_fit.reset;  ICMT_fit.setYdata(ICMT_moy);  ICMT_fit.MaxIt:=30;

  { ICMT_fit.setWorld(ICMT_moy.xmin,ICMT_moy.ymin,ICMT_moy.xmax,ICMT_moy.ymax); }
  ICMT_fit.cpx:=1;  ICMT_fit.cpy:=1;  ICMT_fit.matchVector(v1);  ICMT_fit.color:=cl_red;
  addObject(1,1,ICMT_fit);

end;

procedure mtic_process;
begin
     ICMT_moy.add(v1); {we add each episode result to the average}
end;

procedure mtic_endprocess;
begin
  addObject(1,1,ICMT_moy);
 
  IC_RmCm(ICMT_moy,rm,cm,False); { and we process the analysis}
  rm_vec.addtolist(rs); rm_vec.refresh;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in}
  tmem_vec.addtolist(0.001*(1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond -t0_mem)); tmem_vec.refresh;
  rm_graph.modify(tmem_vec,rm_vec,rm_vec.Istart,rm_vec.Iend); rm_graph.refresh ;
  { set_dac_to_zero; }
end;


procedure prepare_icmt;
begin
   {we write all the relevant global informations}
   clamp_index := 1 ; 
   cont_choice := False ; 
   episode_duration :=  ICMT_t1+ICMT_t2 ;
   max_EP_num :=10 ; // 10 episodes !!
   stim := True ;
   acquisitionISI:= ICMT_interStim ;  // small beak between the stims
   TDBrecord('PG0.Exp_Params').clear;
   TDBrecord('PG0.Exp_Params').exp_type:='IC_MembraneTest';
   TDBrecord('PG0.Exp_Params').pulse_amplitude:=ICMT_amp;
   TDBrecord('PG0.Exp_params').t1:=ICMT_t1;
   TDBrecord('PG0.Exp_params').t2:=ICMT_t2;
   {then we initialize the stimulation}
   InitializeChannels; // we can initialize the channels
   stimulator.Channels[1].BuildEp := Build_ICMTstim ; 
   stimulator.initVectors;
   acquisition.InstallProcess(my_initprocess0, mtic_initprocess, mtic_process, mtic_endprocess);
end;

// writing the membrane parameters as a Tvector that will be loaded by other programs
procedure Set_global_RmCm;
begin
     TDBrecord('PG0.global').Rm := Rm;
     TDBrecord('PG0.global').Cm := Cm;
     TDBrecord('PG0.global').El := El;
     TDBrecord('PG0.global').Bridge := Bridge;
     TDBrecord('PG0.global').Holding := Holding;
end;               
         
procedure ICMT_Event(n:integer);
var amplifier : string ; 
begin    
   ud_dialog.updatevar;
   case n of 
   999 : prepare_icmt;
   998 :IC_RmCm(ICMT_moy,rm,cm,True);
   997 :Set_global_RmCm;   
   end;
end;



procedure ICMembTest_Init; {executed only when ze choose the protocol }
begin
  DestroyAllWindows(1);
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DIvideWindow(1,3,3,1);
  color:=cl_gray;

   ICMT_amp:=20; ICMT_t1:=200; ICMT_t2:=500; ICMT_interStim:=1 ; // params
   {then we display the channels}
   addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,2,v3);   
   
   rm_vec.create(t_single,0,-1) ; tmem_vec.create(t_single,0,-1) ; { we initialize the vector of the rs values }
   rm_graph.create(tmem_vec,rm_vec,0,0); rm_graph.Mode := DM_LINE_DIAMOND ; {graph initialisation }
   addobject(1,3,rm_graph);

   ICMT_memo.create(''); ICMT_memo.font.name:='Times New Roman'; ICMT_memo.font.size:=11;
   ICMT_memo.font.color:=rgb(0,0,0);  ICMT_memo.font.style:=fs_bold;
   addObject(1,4,ICMT_memo);

   ICMT_amp := ICMT_amp;
   ud_dialog.create ;
   ud_dialog.getRealA(' Pulse size (pA)',ICMT_amp,3,1,99);
   ud_dialog.getRealA(' Interstim (s)  ',ICMT_interstim,3,1,99);
   ud_dialog.getRealA(' t1  ',ICMT_t1,3,1,99);
   ud_dialog.getRealA(' t2  ',ICMT_t2,3,1,99);
   ud_dialog.getCommandA('  init() ',0,999);
   ud_dialog.setText('');
   ud_dialog.getCommandA(' Fit with cursors ',0,998);
   ud_dialog.setText('');
   ud_dialog.getRealA(' Bridge  (Mohm) ',bridge,3,1,99);
   ud_dialog.getRealA(' Holding (pA) ',holding,3,1,99);
   ud_dialog.getCommandA(' Write membrane parameters ',0,997);
   ud_dialog.OnEvent:=ICMT_event ;
   AddDialog(1,5,ud_dialog); 

   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time, variables declared in main}
   t0_mem := 1000*60*60*Hour + 1000*60*Minute + 1000*Second + MilliSecond;

   ICMT_cursor.create ; ICMT_cursor.Doublecursor:=True ; ICMT_cursor.style:=cs_X ;
   ICMT_cursor.position[1]:=ICMT_t1 ; ICMT_cursor.position[2]:=ICMT_t2 ; 
   ICMT_cursor.InstallSource(v1);  ICMT_cursor.visible:=True ; 
   prepare_icmt ; // first init
end;

{$EDIT Spont-act-sampling}
{ ==============================================================================
--------------- Spontaneous activity sampling --------------------
================================================================================ }
var v1_copy : Tvector;
   
procedure Calculate_Threshold_for_Vm;
var i0, ii : integer; 
begin
   // we create the vectors
   v1_copy.create; Vcopy(v1,v1_copy);
   hist.create(t_single,0,100); hist.x0:=-80.;hist.dx:=1.;
   cum_proba.create(t_single,0,100); cum_proba.x0:=-80.;cum_proba.dx:=1.;
   // ========== CORE OF THE CALCULATION =========== //
   Distri(v1_copy, hist, -80, 20);
   v1_copy.show;
   // RE-include this code if you want to start the cum. proba form the Peak of the Down state
   ii := 0;
   while ((hist.yvalue[ii]<0.98*hist.ymax) and (ii<hist.Iend)) do ii := ii+1;
   hist.fill1(0., -80., hist.convx(ii+1)); // filling all values previous to Down state peak with 0 values
   DistriFunction(hist, cum_proba); // cumulative distribution
   ii:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Down_transition);
   downward_threshold := cum_proba.convx(ii+1);
   i0:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Up_transition);
   upward_threshold := cum_proba.convx(i0+1);
   UD_dialog.update;
   v1.refresh;
end;

procedure ShowHistograms;
begin
   Down_Cursor.create ; Down_Cursor.style:=cs_X ;
   Up_Cursor.create ; Up_Cursor.style:=cs_X ;
   if ClampName[clamp_index]='I-Clamp' then
   begin
      DOwn_Cursor.PosMin:=-80;Down_Cursor.PosMax:=-10;
      Up_Cursor.PosMin:=-80;Up_Cursor.PosMax:=-10;
      hist.SetWorld(-80, 20, 0, hist.ymax);
      cum_proba.SetWorld(-80, 20, 0, cum_proba.ymax);
   end else
   begin
      DOwn_Cursor.PosMin:=-200;Down_Cursor.PosMax:=1800;
      Up_Cursor.PosMin:=-200;Up_Cursor.PosMax:=1800;
      hist.SetWorld(-100, 1800, 0, hist.ymax);
      cum_proba.SetWorld(-200, 1800, 0, cum_proba.ymax);
   end;
   Down_Cursor.InstallSource(hist); Down_Cursor.visible:=True ;
   Down_Cursor.position[1]:=downward_threshold ; 
   Down_Cursor.OnChange:=UpdateCursor;
   Up_Cursor.position[1]:=upward_threshold ;
   Up_Cursor.InstallSource(hist); Up_Cursor.visible:=True ;
   Up_Cursor.OnChange:=UpdateCursor;
   addObject(1,2,hist); 
   addObject(1,3,cum_proba); 
end;

procedure Set_Threshold;
begin
   FInalPLot_settings;
   v1.refresh;
end;

procedure SAS_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : Calculate_Threshold_for_Vm;
     202 : Set_Threshold;
     203 : ShowHistograms;
     end;
     UD_dialog.update;
end;  

procedure InitSASdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), Round(PageWidth/2), PageHeight);
   Definewindow(1, Round(PageWidth/2), Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=SAS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==* Analyzing the *Vm* during Slow Oscill.  *==__');
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('Subsampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('fraction of cum. proba for transition to Down',fraction_of_cumprob_for_Down_transition,10,3,200);
      getRealA('fraction of cum. proba for transition to Up',fraction_of_cumprob_for_Up_transition,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV)',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV)',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('');
      getCommandA(' Calculate optimal thresholds',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Set cursors',0,202);
      getCommandA('Show Histograms',0,203);
      Caption:='Sampling Spont. Act.';
      Show;
   end;
end;


{$EDIT Vm-feedback-loop-init}
{ ==============================================================================
--------------- INITIALIZE A SINGLE PROTOCOL (COMMON All-Vm Feedback) -----------
================================================================================ }

procedure Init_Vm_feedback_loop;
var setup : string ; i, j : integer;
begin
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
   RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   RTneuron.execute('UD_loop.subsampling_freq = '+Rstr(subsampling_freq));
   RTneuron.execute('UD_loop.spike_threshold = '+Rstr(spike_threshold));
   RTneuron.execute('UD_loop.CMD_dur = '+Rstr(CMD_dur));
   RTneuron.execute('UD_loop.CMD_delay = '+Rstr(CMD_delay));
   
   
   // the choice is here ! {except conductance measurements}
   if Up_State_Stim then RTneuron.execute('UD_loop.up_stimulation = 0') else RTneuron.execute('UD_loop.up_stimulation = -1');
   if Down_State_Stim then RTneuron.execute('UD_loop.down_stimulation = 0') else RTneuron.execute('UD_loop.down_stimulation = -1');

   if (ProtocolName[protocol_index]='Vm-feedback--Opto-Stim-vs-Ctrl') then
   begin
      RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
      RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
      RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
      RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
   end
   else if (ProtocolName[protocol_index]='Vm-feedback--Current-Pulses') then
   begin
      RTneuron.execute('for i = 0,1999 { UD_loop.cmd_vec[i]= '+Rstr(current_pulse)+' }' );
   end
   else if (ProtocolName[protocol_index]='Vm-feedback--oStim-at-Various-Delays') then
   begin
      if num_delay>1 then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('objref v1' );
	 RTneuron.execute('v1 = new Vector()');
	 for j:=0 to num_delay-1 do RTneuron.execute('v1.append('+Rstr(min_delay+j*(max_delay-min_delay)/(num_delay-1))+')');
	 RTneuron.execute('j=0');
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.delay_vec[i]=v1.x[j%'+Istr(num_delay)+'] j=j+1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
      end else MessageBox('Need delay_num>1 !');
   end
   else if (ProtocolName[protocol_index]='Vm-feedback--oStim-of-Various-Durations') then
   begin
      if num_duration>1 then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('objref v1' );
	 RTneuron.execute('v1 = new Vector()');
	 for j:=0 to num_duration-1 do RTneuron.execute('v1.append('+Rstr(min_duration+j*(max_duration-min_duration)/(num_duration-1))+')');
	 RTneuron.execute('j=0');
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.duration_vec[i]=v1.x[j%'+Istr(num_duration)+'] j=j+1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
      end else MessageBox('Need delay_num>1 !');
   end
   else if (ProtocolName[protocol_index]='Vm-feedback--oStim-of-Various-Amplitudes') then
   begin
      if num_duration>1 then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	 RTneuron.execute('objref v1' );
	 RTneuron.execute('v1 = new Vector()');
	 for j:=0 to num_amp-1 do RTneuron.execute('v1.append('+Rstr(min_amp+j*(max_amp-min_amp)/(num_amp-1))+')');
	 RTneuron.execute('j=0');
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.amplitude_vec[i]=v1.x[j%'+Istr(num_amp)+'] j=j+1 } }' );
      end else MessageBox('Need delay_num>1 !');
   end;

end;

{$EDIT Input-Conductance-Measurement}
{ ==============================================================================
--------------- Measurement of Input Conductance -------------------------------
================================================================================ }

procedure Gmeasure_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin 
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      InitializeChannels; Init_Vm_feedback_loop; 
	   end;
	      // then initialization
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitGmeasuredialog;
begin
   CMD_delay := 50.; CMD_dur:=100; 
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(PageHeight/2.));
   Definewindow(1, 0, Round(PageHeight/2.), PageWidth, Round(3.*PageHeight/4.));
   Definewindow(1, 0, Round(3.*PageHeight/4.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=Gmeasure_DialogEvent;
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Current-Pulse parameters :');
      getRealA('Pulse amplitude (pA) ',current_pulse,10,3,200);
      getRealA('Pulse delay (ms) ', CMD_delay,10,3,200);
      getRealA('Pulse duration (ms) ', CMD_dur,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Current-Pulse Stim.';
      Show;
   end;
end;

{$EDIT Test-vs-Ctrl-Vm-Feedback}
{ ==============================================================================
--------------- PHASE-LOCKED OPTOGENTICS IN UP-or-DOWN-STATE  ------------------
================================================================================ }

procedure UD_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUD_dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UD_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      getRealA('spike-cut threshold (mV) ',spike_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity,6,200);
      getRealA('Delay after State start (ms) ', Delay_for_stim,10,3,200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim,10,3,200);
      getRealA('Stimulus amplitude (V)',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Delays-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Delays  ------------------
================================================================================ }

procedure UDdelayVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdelayVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdelayVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Delays : Number', num_delay, 6, 200);
      getRealA('Varying Delays : Minimum (ms) ', min_delay, 10, 3, 200);
      getRealA('Varying Delays : Maximum (ms) ', max_delay, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim, 10, 3, 200);
      getRealA('Stimulus Amplitude (V) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Durations-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDdurationVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdurationVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdurationVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Durations : Number', num_duration, 6, 200);
      getRealA('Varying Durations : Minimum (ms) ', min_duration, 10, 3, 200);
      getRealA('Varying Durations : Maximum (ms) ', max_duration, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      getRealA('Stimulus Amplitude (V) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Amplitudes-Vm-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDamplitudeVm_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Vm_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDamplitudeVm_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDamplitudeVm_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Vm threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Vm threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Amplitudes : Number', num_amp, 6, 200);
      getRealA('Varying Amplitudes : Minimum (ms) ', min_amp, 10, 3, 200);
      getRealA('Varying Amplitudes : Maximum (ms) ', max_amp, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      getRealA('Stimulus Duration (ms) ',Dur_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT VC-Spont-act-sampling}
{ ==============================================================================
--------------- Spontaneous activity sampling in Voltage-Clamp   ---------------
================================================================================ }

procedure Calculate_Threshold_for_Isyn;
var i0, ii : integer; 
begin
   // we create the vectors
   hist.create(t_single,0,100); hist.x0:=-200.;hist.dx:=20.;
   cum_proba.create(t_single,0,100); cum_proba.x0:=-200.;cum_proba.dx:=20.;
   // ========== CORE OF THE CALCULATION =========== //
   Distri(v1, hist, -200, 1800);
   // RE-include this code if you want to start the cum. proba form the Peak of the Down state
   ii := 0;
   while ((hist.yvalue[ii]<0.98*hist.ymax) and (ii<hist.Iend)) do ii := ii+1;
   hist.fill1(0., -200., hist.convx(ii+1)); // filling all values previous to Down state peak with 0 values
   DistriFunction(hist, cum_proba); // cumulative distribution
   ii:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Down_transition);
   downward_threshold := cum_proba.convx(ii+1);
   i0:= cum_proba.getFirstEvent(fraction_of_cumprob_for_Up_transition);
   upward_threshold := cum_proba.convx(i0+1);
   UD_dialog.update;
   v1.refresh;
end;

procedure VCSAS_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : Calculate_Threshold_for_Isyn;
     202 : Set_Threshold;
     203 : ShowHistograms;
     end;
     UD_dialog.update;
end;  

procedure InitVCSASdialog;
begin
   CMD_delay :=-30.; CMD_dur :=370.; clamp_periodicity := 2;
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), Round(PageWidth/2), PageHeight);
   Definewindow(1, Round(PageWidth/2), Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCSAS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==* Analyzing the *Isyn* during Slow Oscill.  *==__');
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('Subsampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('fraction of cum. proba for transition to Down',fraction_of_cumprob_for_Down_transition,10,3,200);
      getRealA('fraction of cum. proba for transition to Up',fraction_of_cumprob_for_Up_transition,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA)',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA)',downward_threshold,10,3,200);
      setText('');
      getCommandA(' Calculate optimal thresholds',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Set cursors',0,202);
      getCommandA('Show Histograms',0,203);
      Caption:='Sampling Spont. Act.';
      Show;
   end;
end;

{$EDIT Isyn-feedback-loop-init}
{ ==============================================================================
--------------- INITIALIZE A SINGLE PROTOCOL (COMMON All-Isyn Feedback) -----------
================================================================================ }

procedure Init_Isyn_feedback_loop;
var setup, irec : string ; i, j, new_clamp_period : integer;
begin
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('UD_loop.upward_threshold = '+Rstr(upward_threshold));
   RTneuron.execute('UD_loop.downward_threshold = '+Rstr(downward_threshold));
   RTneuron.execute('UD_loop.subsampling_freq = '+Rstr(subsampling_freq));
   RTneuron.execute('UD_loop.CMD_dur = '+Rstr(CMD_dur));
   RTneuron.execute('UD_loop.CMD_delay = '+Rstr(CMD_delay));
   
   // the choice is here !
   if Up_State_Stim then RTneuron.execute('UD_loop.up_stimulation = 0') else RTneuron.execute('UD_loop.up_stimulation = -1');
   if Down_State_Stim then RTneuron.execute('UD_loop.down_stimulation = 0') else RTneuron.execute('UD_loop.down_stimulation = -1');

   irec := CurrentsName[current_index];
   new_clamp_period := 1; {by defulat, no need to double the stim because of clamp (hodling pot.) }
   if Clamp_stim then
   begin
      new_clamp_period := Clamp_Periodicity;
      if irec='Excitatory Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(inhibitory_reversal)+'}}')
      else if irec='Inhibitory Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(excitatory_reversal)+'}}')
      else if irec='Intermediate Currents' then RTneuron.execute('for i=0,1999 {if (i%'+Istr(Clamp_Periodicity)+'==1) {UD_loop.cmd_vec[i]='+Rstr(intermediate_reversal)+'}}')
      else if irec='Both Alternatively' then {alternate excitation and inhibition !}
      begin
	 if Clamp_Periodicity<2 then begin Messagebox('Need Clamp_Periodicity>2, we set Clamp_Periodicity:=2'); Clamp_Periodicity:=2; end;
	 new_clamp_period := Clamp_Periodicity+1;
	 RTneuron.execute('for i=0,1999 {if (i%'+Istr(new_clamp_period)+'==0) {UD_loop.cmd_vec[i]='+Rstr(inhibitory_reversal)+'}}');
	 RTneuron.execute('for i=0,1999 {if (i%'+Istr(new_clamp_period)+'==1) {UD_loop.cmd_vec[i]='+Rstr(excitatory_reversal)+'}}');
      end else RTneuron.execute('for i=0,1999 {UD_loop.cmd_vec[i]=0.}');
   end;

   if (ProtocolName[protocol_index]='Isyn-feedback--Opto-Stim-vs-Ctrl') then
      begin
	 RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity*new_clamp_period)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	 RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	 RTneuron.execute('for i = 0,1999 { UD_loop.amplitude_vec[i]='+Rstr(Amp_for_stim)+'}');
	 { RTneuron.execute('for i = 0,1999 {\ UD_loop.cmd_vec[i]= 0'+Rstr(Amp_for_stim)+'!{\'); }
      end
   else if (ProtocolName[protocol_index]='Isyn-feedback--oStim-at-Various-Delays') then
      begin
	 if num_delay>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity*new_clamp_period)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_delay-1 do RTneuron.execute('v1.append('+Rstr(min_delay+j*(max_delay-min_delay)/(num_delay-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.delay_vec[i]=v1.x[j%'+Istr(num_delay)+'] j=j+1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.duration_vec[i]='+Rstr(Dur_for_stim)+'}');
	    end else MessageBox('Need delay_num>1 !');
      end
   else if (ProtocolName[protocol_index]='Isyn-feedback--oStim-of-Various-Durations') then
      begin
	 if num_amp>1 then
	    begin
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity*new_clamp_period)+'==1) { UD_loop.stim_vec[i]=1 } }' );
	       RTneuron.execute('for i = 0,1999 { UD_loop.delay_vec[i]='+Rstr(Delay_for_stim)+'}');
	       RTneuron.execute('objref v1' );
	       RTneuron.execute('v1 = new Vector()');
	       for j:=0 to num_duration-1 do RTneuron.execute('v1.append('+Rstr(min_duration+j*(max_duration-min_duration)/(num_duration-1))+')');
	       RTneuron.execute('j=0');
	       RTneuron.execute('for i = 0,1999 { if (i%'+Istr(Stim_Periodicity)+'==1) { UD_loop.duration_vec[i]=v1.x[j%'+Istr(num_duration)+'] j=j+1 } }' );
	    end else MessageBox('Need delay_num>1 !');
      end;
end;

{$EDIT VC-Get-Synaptic-Currents}
{ ==============================================================================
--------------- Sampling Synaptic CUrrents under Spontaneous activity  ---------
================================================================================ }


procedure VCGSC_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False;  end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitVCGSCdialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(PageHeight/2.));
   Definewindow(1, 0, Round(PageHeight/2.), PageWidth, Round(3.*PageHeight/4.));
   Definewindow(1, 0, Round(3.*PageHeight/4.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCGSC_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      getStringList(' Imaging : ', CurrentsNames, Currentslist, current_index,38);
      setText('______________________________________');
      setText('o==> Voltage-Clamp Parameters :');
      getRealA('Holding Potential (mV) +',holding_potential,10,3,200);
      getRealA('Excitatory Reversal (mV) +',excitatory_reversal,10,3,200);
      getRealA('Inhibitory Reversal (mV) +',inhibitory_reversal,10,3,200);
      getRealA('Intermediate Reversal (mV) +',intermediate_reversal,10,3,200);
      getRealA('Clamp Delay wrt Stim. (ms) ', CMD_delay,10,3,200);
      getRealA('Clamp Duration (ms) ', CMD_dur,10,3,200);
      getIntegerA('Clamping Periodicity (1 stim every XX cycles)', Clamp_Periodicity,6,200);
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;


{$EDIT Test-vs-Ctrl-Isyn-Feedback}
{ ==============================================================================
--------------- PHASE-LOCKED OPTOGENTICS IN UP-or-DOWN-STATE  ------------------
================================================================================ }

procedure UD_Isyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False;  end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUD_Isyn_dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(PageHeight/2.));
   Definewindow(1, 0, Round(PageHeight/2.), PageWidth, Round(3.*PageHeight/4.));
   Definewindow(1, 0, Round(3.*PageHeight/4.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=VCGSC_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      getStringList(' Imaging : ', CurrentsNames, Currentslist, current_index,38);
      setText('______________________________________');
      setText('o==> Voltage-Clamp Parameters :');
      getRealA('Holding Potential (mV) ',holding_potential,10,3,200);
      getRealA('Excitatory Reversal (+mV) +',excitatory_reversal,10,3,200);
      getRealA('Inhibitory Reversal (+mV) +',inhibitory_reversal,10,3,200);
      getRealA('Intermediate Reversal (+mV) +',intermediate_reversal,10,3,200);
      getRealA('Clamp Delay wrt Stim. (ms) ', CMD_delay,10,3,200);
      getRealA('Clamp Duration (ms) ', CMD_dur,10,3,200);
      getIntegerA('Clamping Periodicity (1 stim every XX cycles)', Clamp_Periodicity,6,200);
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (pA) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (pA) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity,6,200);
      getRealA('Delay after State start (ms) ', Delay_for_stim,10,3,200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim,10,3,200);
      getRealA('Stimulus Amplitude (V) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Delays-Isyn-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Delays  ------------------
================================================================================ }

procedure UDdelayIsyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdelayIsyn_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdelayIsyn_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> TTL parameters :');
      getRealA('Stimulus Amplitude (V) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Delays : Number', num_delay, 6, 200);
      getRealA('Varying Delays : Minimum (ms) ', min_delay, 10, 3, 200);
      getRealA('Varying Delays : Maximum (ms) ', max_delay, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus duration (ms) ', Dur_for_stim, 10, 3, 200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Varying-Durations-Isyn-Feedback}
{ ==============================================================================
--------------- Protocol to Vary Durations  ------------------
================================================================================ }

procedure UDdurationIsyn_DialogEvent(n:integer);
begin
   UD_dialog.updatevar;
   case n of
     201 : begin
	      if flag_for_state_stimulation=1 then begin {stimulation in Up state}
		 Up_State_Stim:=True; Down_State_Stim:=False; end
	      else if flag_for_state_stimulation=2 then begin {stimulation in Up state}
		 Down_State_Stim:=True; Up_State_Stim:=False; end;
	      // then initialization
	      InitializeChannels; Init_Isyn_feedback_loop;
	   end;
     203 : updatecursor_in_NEURON;
     end;
     UD_dialog.update;
end;  

procedure InitUDdurationIsyn_Dialog;
begin
   init_windows;
   Definewindow(1, 0, 0, PageWidth, Round(2.*PageHeight/3.));
   Definewindow(1, 0, Round(2.*PageHeight/3.), PageWidth, PageHeight);
   Page:=1; color:=cl_gray;
   with UD_dialog do
   begin
      create;
      OnEvent:=UDdurationIsyn_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('__==** Optogenetical Stim. Phase-locked to the Slow Oscill.  **==__');
      setText('______________________________________');
      getStringList(' Stimulation in : ','Up State|Down State','1|2',flag_for_state_stimulation,37);  { Onevent flag ->199}
      setText('______________________________________');
      setText('o==> Real-Time analysis parameters :');
      getRealA('SubSampling Frequency (kHz)',subsampling_freq,10,3,200);
      getRealA('Isyn threshold for Down-to-Up transitions (mV) ',upward_threshold,10,3,200);
      getRealA('Isyn threshold for Up-to-Down transitions (mV) ',downward_threshold,10,3,200);
      setText('______________________________________');
      setText('o==> TTL parameters :');
      getRealA('Stimulus Amplitude (V) ',Amp_for_Stim,10,3,200);
      setText('______________________________________');
      setText('o==> Stimulation parameters :');
      getIntegerA('Varying Durations : Number', num_duration, 6, 200);
      getRealA('Varying Durations : Minimum (ms) ', min_duration, 10, 3, 200);
      getRealA('Varying Durations : Maximum (ms) ', max_duration, 10, 3, 200);
      getIntegerA('Periodicity (1 stim every XX cycles)', Stim_Periodicity, 6, 200);
      getRealA('Stimulus Delay (ms) ', Delay_for_stim, 10, 3, 200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize Exp. ',0,201); { OnEvent flag -D  201 }
      setText('');
      getCommandA(' Update cursors',0,203); { OnEvent flag -D  201 }
      Caption:='Real-Time-opto Up&Down';
      Show;
   end;
end;

{$EDIT Main_dialog}
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure Update_Location;
var Hour2,Minute2,Second2,MilliSecond2 : smallint;
begin
   DecodeDateTime(Now,Year,Month,Day,Hour2,Minute2,Second2,MilliSecond2); {function to fetch date and time}
   case location_index of
     1: begin {setup}
	   PathOfTheDay := 'D:\Yann\DATA_elphy\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='\';
	   loadnrnPath := 'D:/yann/elphy/nrn_files/' ; 
	end; 
     2: begin {osx}
	   PathOfTheDay := 'Z:\Users\yzerlaut\DATA_elphy\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
	   sep :='/';
	   loadnrnPath := 'Z:/Users/yzerlaut/work/elphy/nrn_files/' ; 
	end;
     3: begin {linux}
	   PathOfTheDay := 'Z:\home\yann\DATA_elphy\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
	   sep :='/';
	   loadnrnPath := 'Z:/home/yann/work/elphy/nrn_files/' ; 
	end;
    end;
   if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
end;

procedure loadNRNmech;
begin
   dll_load := 'nrn_load_dll("'+loadnrnpath+'nrnmech.dll")';
   RTneuron.Execute(dll_load);
end;

procedure load_fake_Vm;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\Cell1_13909028.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      { for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/'; }
      { txtfile2:=txtfile2+memo[memo.count]; }
      RTneuron.execute('objref ff, vv'); RTneuron.execute('vv = new Vector()');
      RTneuron.execute('ff = new File()'); RTneuron.execute('ff.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv.scanf(ff)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure load_fake_LFP;
var txtfile, txtfile2 : string ; memo : Tmemo; ii : integer;
begin
   txtfile := 'Z:\Users\yzerlaut\DATA\Data_Ste_Zucca\LFP1_25632003.txt';
   if ChooseFile(txtfile) then
   begin
      memo.create;
      splitString(txtfile, '\', memo);
      { for ii:=1 to memo.count-1 do txtfile2:=txtfile2+memo[ii]+'/'; }
      { txtfile2:=txtfile2+memo[memo.count]; }
      RTneuron.execute('objref ff2, vv2'); RTneuron.execute('vv2 = new Vector()');
      RTneuron.execute('ff2 = new File()'); RTneuron.execute('ff2.ropen("'+txtfile2+'")');
      RTneuron.execute('print " File loading [...] "'); RTneuron.execute('vv2.scanf(ff2)');
      RTneuron.execute('print "====================================================== "');
      RTneuron.execute('print " File loaded ! "');
      RTneuron.execute('print "====================================================== "');
   end else MessageBox('No datafile provided !');
end;

procedure MainDialog_update(n:integer); 
var proto : string ; memo : Tmemo; ii : integer;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}
   
  { if acquisition.IsRunning then acquisition.stop;  }
  MainDialog.updatevar; 
  case n of
    101: begin
	    proto := ProtocolName[protocol_index];
	    if proto='Seal-Test'
	       then begin SealTest_Init; end
	    else if proto='VC-Membrane Test'
	       then begin stim:=True; closedLoop:=False; opto_stim:=False; clamp_stim:=True; with_LFP:=False; VCMembTest_Init; end
	    else if proto='IC-Membrane Test'
	       then begin stim:=True; closedLoop:=False; opto_stim:=False; clamp_stim:=True; with_LFP:=False; ICMembTest_Init; end
	    else if proto='Vm-feedback--Spont-Act-Sampling'
	       then begin stim:=False; closedLoop:=False;opto_stim:=False;clamp_index:=1;with_LFP:=False;InitSASdialog;InitializeChannels;Init_Vm_feedback_loop;end
	    else if proto='Vm-feedback--Current-Pulses'
	       then begin stim:=False; closedLoop:=True;opto_stim:=False;clamp_index:=1; clamp_stim :=True; with_LFP:=False; InitGmeasuredialog; end
	    else if proto='Vm-feedback--Opto-Stim-vs-Ctrl'
	       then begin stim:=False; closedLoop:=True;opto_stim:=True;clamp_index:=1;with_LFP:=False; clamp_stim :=False; InitUD_dialog; end
	    else if proto='Vm-feedback--oStim-at-Various-Delays'
	       then begin stim:=False; closedLoop:=True;opto_stim:=True; clamp_index:=1; with_LFP :=False ; clamp_stim :=False; InitUDdelayVm_dialog; end
	    else if proto='Vm-feedback--oStim-of-Various-Durations'
	       then begin stim:=False; closedLoop:=True;opto_stim:=True; clamp_index:=1; with_LFP :=False ; clamp_stim :=False; InitUDdurationVm_dialog; end
	    else if proto='Vm-feedback--oStim-of-Various-Amplitudes'
	       then begin stim:=False; closedLoop:=True;opto_stim:=True; clamp_index:=1; with_LFP :=False ; clamp_stim :=False; InitUDamplitudeVm_dialog; end
	    else if proto='Isyn-feedback--Spont-Act-Sampling'
	       then begin stim:=False;closedLoop:=False;clamp_index:=2;with_LFP:=False;Clamp_Stim:=False;Opto_Stim:=False;InitVCSASdialog;InitializeChannels;Init_Isyn_feedback_loop;end
	    else if proto='Isyn-feedback--Get-Syn-Currents'
	       then begin stim:=False;closedLoop:=True; clamp_index:=2; with_LFP:=False; Clamp_Stim:=True; Opto_Stim:=False; InitVCGSCdialog; end
	    else if proto='Isyn-feedback--Opto-Stim-vs-Ctrl'
	       then begin stim:=False;closedLoop:=True; clamp_index:=2; with_LFP :=False ;opto_stim:=True; Clamp_Stim:=True; InitUD_Isyn_dialog; end
	    else if proto='Isyn-feedback--oStim-at-Various-Delays'
	       then begin stim:=False;closedLoop:=True; clamp_index:=2; with_LFP :=False ;opto_stim:=True; InitUDdelayIsyn_dialog; end
	    else if proto='Isyn-feedback--oStim-of-Various-Durations'
	       then begin stim:=False;closedLoop:=True; clamp_index:=2; with_LFP :=False ;opto_stim:=True; InitUDdurationIsyn_dialog; end;
         end;
    333	: load_fake_Vm;
    334	: load_fake_LFP;
    38: Update_Location;
    111 : SetGain1; 
    200 : begin
	     acquisition.InstallProcess(my_initprocess0, nil, nil, my_endProcess);
	     if SAVING then acquisition.startandsave else acquisition.start;
	  end;
    201 : acquisition.stop ;
    301 : comments := '';
    281 : LoadNRNmech;
    282 : begin RTneuron.Restart; loadNRNmech; end;
  end;
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -D  dangerous for division, e.g. freq) }
var setup : string ;
begin
DB.create;
protocol_index := 0;
//------------
   with MainDialog do
   begin
      create;
      getStringList(' Setup : ', SetupNames,'0|1|2|3',setup_index,37);  { Onevent flag ->199}
      getStringList(' Location : ', LocationNames,'0|1|2|3',location_index,38);  { Onevent flag ->199}
      getStringList(' Optogenetics : ', OptoNames, OptoList, opto_index, 39);  { Onevent flag ->199}
      getStringList(' Ampli-Mode : ', ClampNames, '0|1|2', clamp_index,40);  { Onevent flag ->199}
      if setup_index=2 then getCommandA('load *Vm* Datafile for Replay ',0,333);
      if setup_index=2 then getCommandA('load *LFP* Datafile for Replay ',0,334);
      getRealA('Acquisition freq. (kHz)',f_acq,3,2,785);
      setText('');
      OnEvent := MainDialog_update;
   
      getCommandA(' restart NEURON ',0,282);
      getCommandA(' load NEURON mech ',0,281);
      //getCommandA(' load NEURON model ',0,280); 

      setText(' ================================= ');
      setText(' ---------------< Protocol Selection >----------------- ');
      setText('');
      getStringList('  PROTOCOL  ', ProtoNames, Protonum, protocol_index,101);  { Onevent flag ->199}
   setText(' ================================= ');
   setText('');
   setText(' ==<| GAIN  |>== ');
   getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_index,111);
   setText('');
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='RT-optogenetics';
  end;
Maindialog.show;
end;



{$EDIT write_to_binary_file}

// ==================================================================== //
// ------------- From Elphy DataFile to a Binary File ----------------- //
// ----------- Metadata (TDBrecord,...) written in a JSON file  ------- //
// ==================================================================== //

var elphy_filename, binary_filename, json_filename, dat_directory, new_directory : string ;
var time:TdateTime; var size:longword; var att:integer ;    
     
procedure save_Binary_Json(elphy_filename:string);
var datafile : Tdatafile ; binfile : TbinaryFile; db_info : TDBrecord;
    channelID, episodeID, jj, ii, num : integer ;
    st, st2, name, ext, binary_filename, json_filename, binary_data_path, elphy_data_path : string;
   
begin
  // ---------------------------------------------------------
  // Finding the right path
  // ---------------------------------------------------------
   SplitFileNameEx(elphy_filename, elphy_data_path, name, num, ext);
   binary_data_path := elphy_data_path;
   if Pos('_ELPHY', elphy_data_path)>0 then 
   begin
      Delete(binary_data_path, Pos('_ELPHY', binary_data_path),Length('_ELPHY'));
      if not DirectoryExists(binary_data_path) then createDir(binary_data_path);
   end else MessageBox('Problem with directory:'+elphy_data_path);
   // then creating the folder if it does not exists
   if not DirectoryExists(binary_data_path) then createDir(binary_data_path);
   // then simple name within folder
   binary_filename := binary_data_path+name+'.bin'; // we also change the extension
   json_filename := binary_data_path+name+'.json'; // we also change the extension
   // ---------------------------------------------------------
   // Copying the metadata files
   // ---------------------------------------------------------
   st := elphy_data_path+name+'.txt';
   if CopyFile(st,binary_data_path+name+'.txt') then StatusLineTxt(st+' copied') else MessageBox('File '+st+' not copied');
   // ---------------------------------------------------------
   // Initializing files
   // ---------------------------------------------------------
   // loading Elphy datafile 
   datafile.create;
   datafile.NewFile(elphy_filename);
   // creating the binary file
   binfile.rewrite(binary_filename);
   // creating the json file
   openText(1, json_filename, False); // False for writing mode
   
   statuslineTxt('==> translating binary and json files for :'+elphy_filename);
   // ---------------------------------------------------------
   // Binary file writing ! 
   // ---------------------------------------------------------
   for episodeID:=1 to datafile.EpCount do
   begin 
      datafile.EpNum := episodeID ;                                                                                           
      for channelID := 1 to datafile.channelcount do
      begin
	 statuslineTxt('channel'+Istr(channelID)+', episode'+Istr(episodeID)+' v1[0]='+Rstr(datafile.v[1][datafile.v[1].Iend]));
	 datafile.v[channelID].SaveBinaryData(binfile, 5);
      end;
   end;
   
   // ---------------------------------------------------------
   // JSON file writing
   // ---------------------------------------------------------
   statuslineTxt('writing JSON file (metadata)');
   writelnText(1,'{'); // and we start the dict() structure
   db_info.create;  
   {we start by the informations stored in the TdbRecord associated to the acquisition file} 
   datafile.ReadDBFileInfo(db_info);
   for jj:=1 to db_info.count do
   begin  
      st:= db_info.Names[jj] ;
      st2:=db_info.Valstring[jj];
      writelnText(1,'"'+st+'":"'+st2+'",');
   end;        
   // then the gain of each channel
   for ii:=1 to datafile.ChannelCount do
      WriteLnText(1, '"gain_'+Istr(ii)+'" : "'+Rstr(datafile.v[ii].dY)+'",');
   // then the unit of each channel
   WriteLnText(1, '"unitX" : "'+datafile.v[1].unitX+'",'); // all channels have the same x unit
   for ii:=1 to datafile.ChannelCount do
      WriteLnText(1, '"unitY_'+Istr(ii)+'" : "'+datafile.v[ii].unitY+'",');
   // Then some other very usefull things:
   WriteLnText(1, '"ChannelCount" : "'+Istr(datafile.ChannelCount)+'",');
   WriteLnText(1, '"EpCount" : "'+Istr(datafile.EpCount)+'",');
   // finally we close the JSON file 
   writelnText(1,'"lastline":"no_value"}'); // we write a last line (just to have no comma)
   CloseText(1);
   // we close everything
   db_info.free; datafile.free; binfile.free;
   statuslineTxt('DONE !! ');
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}


procedure global_init;
var PathOfTheDay : string ;
begin

   RTneuron.resetParams;
   SetLocations; SetSetup; SetOpto; SetClamp;SetProtocolNames;SetCurrents;
   if location='RT-Setup' then begin setup_index :=1; location_index:=1 ; SAVING:=True; end;
   if location='Macbook' then begin location_index:=2 ; SAVING:=False; end;
   if setup='NEURON-sim' then setup_index :=3 else if setup='RT-Setup' then setup_index :=1 else setup_index :=2;
   global.create; Exp_Params.create;
   Update_Location;
   // those 3 parameters are obvious, we just keep them for compatibility with the other conventions
   clamp_index := 1;
   stim:=False;cont_choice:=True;
   TDBrecord('PG0.global').main_protocol:='RT-opto-Up-Down';
   TDBrecord('PG0.global').protocol:='';
   TDBrecord('PG0.Exp_params').exp_type := 'blank-exp';
   gain1 :=1 ; gain2 := 1. ;
   TDBrecord('PG0.global').FadvanceON := True ;  
   Color := cl_gray ;
end;

program LAUNCH_PROTOCOLS
{ see the documentation, for the details of the acquisition and RTneuron functions }
global_init ;
init_csts;
Init_Main_Dialog;
RTneuron.resetParams;
set_dac_to_zero;
loadNRNmech;

program Convert_a_single_File
global_init;init_csts;
elphy_filename := PathOftheDay+'\*.DAT';
ChooseFile(elphy_filename);
save_Binary_Json(elphy_filename);

program Loop_over_files_in_root_folder
global_init;init_csts;
ChooseDirectory('Choose a ROOT directory to loop on ALL containing files', PathOftheDay, dat_directory);
elphy_filename := FirstFile(dat_directory+'\*.DAT', True, time, size, att);
while (elphy_filename<>'') do 
 begin
    if extractFileExt(elphy_filename)='.DAT' then 
    begin
     save_Binary_Json(elphy_filename);
    end;
    MessageBox(NextFile);
    elphy_filename := NextFile ;
 end;  
MessageBox('Loop over the ROOT folder terminated !');

