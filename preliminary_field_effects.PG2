{$EDIT FE_start}
{========================================================================
------- Master file for the field effects experiments -------- ---------
========================================================================}

Const
   ProtocolCount = 8 ; 
   CONTINUOUS_TIMER = 0.5 ; 

var  { ========= COMMON VARIABLES ============ }
   protocol_choice : integer; 
   amplifier, comments, PathOfTheDay, root_dir : string ; 
   MainDialog, Stim_dialog : Tdialog ;{ two dialogs for buttons and protocols}
   stim, SAVING : boolean ; 
   ProtocolName:array[1..protocolCount] of string; ProtoNames:string;
   DB:Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; {variables to fetch the date and time }
   gain1,gain2,gain3 : real; gain1_int,gain2_int, gain3_int,clamp_int:integer;cont_choice:boolean;  
   dll_load : string ;
   continu_flag : boolean ;
   detector : Tdetector; // detector use througout the protocols in cqse of continuous mode for online analysis


{ ============================================================================
 ---- Protocol names and graphical settings ----------------------------------
 ============================================================================= }
 
 
procedure SetProtocolNames;
var          
  i:integer;
begin
  ProtocolName[1]:= 'Passive-Recording';
  ProtocolName[2]:= 'Efield-Pulses';
  ProtocolName[3]:= 'Efield-Sinusoids';
  ProtocolName[4]:= 'Efield+Patch Pulses';
  ProtocolName[5]:= 'current_field_charact';
  ProtocolName[6]:= 'get_the_pol';
  ProtocolName[7]:= 'track_the_AP';
  ProtocolName[8]:= 'IVcurve+field';
  ProtoNames:=ProtocolName[1];
  for i:=2 to ProtocolCount do ProtoNames:=ProtoNames+'|'+ProtocolName[i];
end;    

procedure init_windows;
begin
  deleteallpages('default');
  InsertPage(1,'Efield exps');
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight/2));
  Definewindow(1, 0, Round(PageHeight/2), PageWidth, Round(3*PageHeight/4));
  Definewindow(1, 0, Round(PageHeight*3/4), PageWidth, PageHeight);
  color:=cl_gray;
end;


{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments+Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }


procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  //DB.clone(TDBrecord('PG0.global'));        
  DB.s:=''+CRLF;                                     
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,TDBrecord('PG0.global').count+jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  DB.protocol:=ProtocolName[protocol_choice];
  DB.Comments := comments ; {comments is a global variable }
end;

procedure my_initprocess0;
begin
  FillDBinfo(DB); 
  if acquisition.saving then acquisition.writeDBfileinfo(DB);
end;

{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }


{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }


procedure Init_AcqChannels; 
var 
   gain1, gain2, gain3, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   Clamp_int, max_ep_num :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   {we load the informations from the global TDBrecord }
   Continu:=TDBrecord('PG0.global').cont_choice;
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   gain3 := TDBrecord('PG0.global').gain3 ;
   stim:=TDBrecord('PG0.global').stim;
   max_ep_num := TDBrecord('PG0.global').max_EP_num ;
   f_acq := TDBrecord('PG0.global').f_acq ;
   epdur := TDBrecord('PG0.global').episode_duration;
   acquisitionISI := TDBrecord('PG0.global').acquisitionISI ;  
   {we delete previous graphical display}
   ClearObjects(1,1);
   ClearObjects(1,2);
   ClearObjects(1,3);

   { see the documentation, for the details of the acquisition and RTneuron functions }
   RTneuron.ResetParams;
   RTneuron.FadvanceON := False ; 
   acquisition.Fcontinuous:=Continu; {boolean true ->continuous acquisition, False -> episode mode}
   acquisition.PeriodPerChannel:=1./f_acq ; {in ms}

    if stim then acquisition.Fstimulate := True
    else acquisition.Fstimulate:=False;  { we stimulate or not }
    
    acquisition.ChannelCount := 6 ;
    acquisition.MaxEpCount := max_ep_num ;
    if not acquisition.Fcontinuous then begin acquisition.EpDuration := epdur;  acquisition.ISI := acquisitionISI ; end;
    
    acquisition.TriggerMode:= TM_internal; //TM_immediate;
    acquisition.Channels[1].ChannelType:= TI_Neuron; { here we set that we read the acquisition from NEURON }
    acquisition.Channels[2].ChannelType:= TI_Neuron;
    
    acquisition.Channels[1].DownSamplingFactor:=1;
    acquisition.Channels[2].DownSamplingFactor:=1;
    
    if Clamp_int=1 then { IF CURRENT-CLAMP }
    begin { we link the analogous signal to the NEURON variables with the right gain }
      RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='Vm';    // primary     
      RTneuron.AdcChan[1].setScale(0,32767,0,20000.0/gain2); RTneuron.AdcChan[1].NrnSymbolName:='Iinj'; // secondary 
      acquisition.Channels[1].NrnSymbolName:='Vm'; acquisition.Channels[1].unitY:='mV' ;
      acquisition.Channels[2].NrnSymbolName:='Iinj'; acquisition.Channels[2].unitY:='pA' ;
    end;                                                                                                        
    if Clamp_int=2 then { IF VOLTAGE CLAMP }
    begin
      RTneuron.AdcChan[0].setScale(0,32767,0,20000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='Iinj';         
      RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain2); RTneuron.AdcChan[1].NrnSymbolName:='Vm';  
      acquisition.Channels[1].NrnSymbolName:='Iinj'; acquisition.Channels[1].unitY:='pA' ;
      acquisition.Channels[2].NrnSymbolName:='Vm'; acquisition.Channels[2].unitY:='mV' ;
    end; { we will call this function each time we modify a gain }
    
    {the declaration for the axoclamp is independent of the clamp of the neuron}
    {then the declaration of the endogenous field electrodes channels}
       
    {then graphical options}
    v1.cpx:=1 ; v2.cpx:=1 ; v1.cpy := 1 ; v2.cpy:= 2; {we set the coupling value -> to couple to future analysis}
    
    addObject(1,1,v1);  addObject(1,2,v2);  
    
end;

{ ==============================================================================
-- Setting the fake Acquisition channels for testing using RTneuron-Simulation --
================================================================================ }

procedure Init_AcqChannels_DC; { setting the channels for the RTneuron-simulation mode}
var 
   Continu, stim :boolean;
   Clamp_int, max_ep_num :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   {we load the informations from the global TDBrecord }
   Continu:=TDBrecord('PG0.global').cont_choice;
   stim:=TDBrecord('PG0.global').stim;
   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2); ClearObjects(1,3);

   { see the documentation, for the details of the acquisition and RTneuron functions }
   RTneuron.ResetParams;
   RTneuron.FadvanceON := False ; 
   acquisition.Fcontinuous:=True; {boolean true ->continuous acquisition, False -> episode mode}
   acquisition.PeriodPerChannel:=0.1 ; {in ms}

    if stim then acquisition.Fstimulate := True
    else acquisition.Fstimulate:=False;  { we stimulate or not }
    
    acquisition.ChannelCount := 6 ;
    acquisition.MaxEpCount := max_ep_num ;
    
    acquisition.TriggerMode:= TM_internal; //TM_immediate;
    acquisition.Channels[1].ChannelType:= TI_Neuron; { here we set that we read the acquisition from NEURON }
    acquisition.Channels[2].ChannelType:= TI_Neuron;
    acquisition.Channels[3].ChannelType:= TI_Neuron;
    acquisition.Channels[4].ChannelType:= TI_Neuron; 
    
    acquisition.Channels[1].DownSamplingFactor:=1;
    acquisition.Channels[2].DownSamplingFactor:=1;
    acquisition.Channels[3].DownSamplingFactor:=1;
    acquisition.Channels[4].DownSamplingFactor:=1;
    
    if Clamp_int=1 then { IF CURRENT-CLAMP }
    begin { we link the analogous signal to the NEURON variables with the right gain }
      RTneuron.Execute('create soma');    // primary     
      RTneuron.AdcChan[1].setScale(0,32767,0,20000.0/gain2); RTneuron.AdcChan[1].NrnSymbolName:='Iinj'; // secondary 
      acquisition.Channels[1].NrnSymbolName:='Vm'; acquisition.Channels[1].unitY:='mV' ;
      acquisition.Channels[2].NrnSymbolName:='Iinj'; acquisition.Channels[2].unitY:='pA' ;
    end;                                                                                                        
    if Clamp_int=2 then { IF VOLTAGE CLAMP }
    begin
      RTneuron.AdcChan[0].setScale(0,32767,0,20000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='Iinj';         
      RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain2); RTneuron.AdcChan[1].NrnSymbolName:='Vm';  
      acquisition.Channels[1].NrnSymbolName:='Iinj'; acquisition.Channels[1].unitY:='pA' ;
      acquisition.Channels[2].NrnSymbolName:='Vm'; acquisition.Channels[2].unitY:='mV' ;
    end; { we will call this function each time we modify a gain }
    
    {the declaration for the axoclamp is independent of the clamp of the neuron}
    {then the declaration of the endogenous field electrodes channels}
    
    RTneuron.AdcChan[2].setScale(0,32767,0,5000.0); RTneuron.AdcChan[2].NrnSymbolName:='I_field'; // 10V/2kOhm is the max
    acquisition.Channels[3].NrnSymbolName:='I_field'; acquisition.Channels[3].unitY:='uA' ;
    {then graphical options}
    v1.cpx:=1 ; v2.cpx:=1 ; v1.cpy := 1 ; v2.cpy:= 2; v3.cpx:= 1; v3.cpy:= 3; {we set the coupling value -> to couple to future analysis}
    
    addObject(1,1,v1);  addObject(1,2,v2);   addObject(1,3,v3);
    
end;


{ ==============================================================================
--------- Setting the Stimulation channels -------------------------------------
================================================================================ }


procedure Init_StimChannels; { crucial function as well }
var Continu, fadvanceON, field_stim, patch_stim :boolean;
    Clamp_int:integer;
    gain1, gain2, gain3 : real ;
begin { We link the Elphy stimulation to the NEURON variable, then the NEURON variable to the analogous command }

   Continu:=TDBrecord('PG0.global').cont_choice;
   Clamp_int:=TDBrecord('PG0.global').clamp_int;
   patch_stim := TDBrecord('PG0.global').patch_stim;
   field_stim := TDBrecord('PG0.global').Efield_stim;
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   gain3 := TDBrecord('PG0.global').gain3 ;
   
   stimulator.setByProg:=true; { mais on met le build ep plus loin }
   
   if patch_stim and field_stim then 
   begin { ---------------------------- > two stimulations}
       stimulator.ChannelCount:=2 ;
       {stimulation on neuron}
       stimulator.Channels[1].ChannelType:=TO_Neuron;
       {electric field stimulation created by the current}
       stimulator.Channels[2].ChannelType:=TO_Neuron;

   // then we plot it, the current stim with the current grqph qnd the extrqnl stim in its windoz
   acquisition.Channels[3].ChannelType:= TI_Neuron; acquisition.Channels[3].DownSamplingFactor:=1;
   acquisition.Channels[4].ChannelType:= TI_Neuron; acquisition.Channels[4].DownSamplingFactor:=1;

       if Clamp_int=1 then { IF CURRENT CLAMP }
       begin
          RTneuron.DacChan[0].NrnSymbolName:='Ith'; RTneuron.DacChan[0].setScale(0,32767,0,4000.0); // command -> I clamp
          stimulator.Channels[1].NrnSymbolName:='Ith';
         acquisition.Channels[3].NrnSymbolName:='I_field_th'; acquisition.Channels[3].unitY:='uA' ;
        end;
       if Clamp_int=2 then { IF VOLTAGE CLAMP }
       begin
           RTneuron.DacChan[0].NrnSymbolName:='Vth'; RTneuron.DacChan[0].setScale(0,32767,0,200.0); // command -> V clamp
           stimulator.Channels[1].NrnSymbolName:='Vth';
       end;
       { then independently of the clamp type, the exletric stimmulation !}
       RTneuron.DacChan[1].NrnSymbolName:='I_field_th'; RTneuron.DacChan[1].setScale(0,32767,0,10.0*gain3); // command -> I clamp
       stimulator.Channels[2].NrnSymbolName:='I_field_th'; 
   
       v3.cpx:= 1; v3.cpy:= 3;  addObject(1,2,v3); // with the secondqry channel
       acquisition.Channels[4].NrnSymbolName:='I_field_th'; acquisition.Channels[4].unitY:='uA' ;
       v4.cpx:= 1; v4.cpy:= 3;  addObject(1,3,v4);
   end
   else  { ---------------------------- > only one stimulation}
   begin
      stimulator.ChannelCount:=1;
      stimulator.Channels[1].ChannelType:=TO_Neuron;
      if patch_stim then 
      begin
       if Clamp_int=1 then { IF CURRENT CLAMP }
       begin
          RTneuron.DacChan[0].NrnSymbolName:='Ith'; RTneuron.DacChan[0].setScale(0,32767,0,4000.0); // command -> I clamp
          stimulator.Channels[1].NrnSymbolName:='Ith';
       end;
       if Clamp_int=2 then { IF VOLTAGE CLAMP }
       begin
           RTneuron.DacChan[0].NrnSymbolName:='Vth'; RTneuron.DacChan[0].setScale(0,32767,0,200.0); // command -> V clamp
           stimulator.Channels[1].NrnSymbolName:='Vth';
       end;
      
      end
      else {field_stim}
      begin
      { then independently of the clamp type, the exletric stimmulation !}
       RTneuron.DacChan[1].NrnSymbolName:='I_field_th'; RTneuron.DacChan[1].setScale(0,32767,0,10.0*gain3); // command -> I clamp
       stimulator.Channels[1].NrnSymbolName:='I_field_th'; 
       acquisition.Channels[3].NrnSymbolName:='I_field_th'; acquisition.Channels[3].unitY:='uA' ;
       v3.cpx:= 1; v3.cpy:= 3;  addObject(1,3,v3);
       end;   
   end;
   fadvanceon := TDBrecord('PG0.global').FadvanceON ; // to make NEURON calculate or not !
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
var Gain1_int:integer;
begin
    gain1_int:=TDBrecord('PG0.global').Gain1_int;
    case Gain1_int of
    1: TDBrecord('PG0.global').Gain1 := 1.0; 2: TDBrecord('PG0.global').Gain1 := 2.0;
    3: TDBrecord('PG0.global').Gain1 := 5.0; 4: TDBrecord('PG0.global').Gain1 := 10.0;
    5: TDBrecord('PG0.global').Gain1 := 20.0; 6: TDBrecord('PG0.global').Gain1 := 50.0;
    7: TDBrecord('PG0.global').Gain1 := 100.0; 8: TDBrecord('PG0.global').Gain1 := 200.0;
    9: TDBrecord('PG0.global').Gain1 := 500.0; 10: TDBrecord('PG0.global').Gain1 := 1000.0;
    11: TDBrecord('PG0.global').Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure SetGain2;
var Gain2_int:integer;
begin
    gain2_int:=TDBrecord('PG0.global').Gain2_int;
    case Gain2_int of
    1: TDBrecord('PG0.global').Gain2 := 1.0;   2: TDBrecord('PG0.global').Gain2 := 2.0; 
    3: TDBrecord('PG0.global').Gain2 := 5.0;  4: TDBrecord('PG0.global').Gain2 := 10.0;
    5: TDBrecord('PG0.global').Gain2 := 20.0;   6: TDBrecord('PG0.global').Gain2 := 50.0; 
    7: TDBrecord('PG0.global').Gain2 := 100.0;
    end;
end;   {SetGain2}

procedure SetGain3; {axoclamp settings}
var Gain3_int:integer;
begin
    gain3_int:=TDBrecord('PG0.global').Gain3_int;
    case Gain3_int of
    1: TDBrecord('PG0.global').Gain3 := 1; 
    2: TDBrecord('PG0.global').Gain3 := 10;
    3: TDBrecord('PG0.global').Gain3 := 100; 
    4: TDBrecord('PG0.global').Gain3 := 1000; 
    end;
end;   {SetGain}

procedure InitializeChannels;
var amplifier : string ;
begin
	 amplifier := TDBrecord('PG0.global').amplifier ;
	 if amplifier='multiclamp' then
	 begin
	    Init_AcqChannels;
	    if acquisition.Fstimulate then Init_StimChannels;
	 end;
end;

procedure set_dac_to_zero;
begin
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;  
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);   
    stimulator.setValue(0,0,1,0);   
    stimulator.setValue(0,1,0,0);  
end; 
end;


ProcessCont  { COMMON to all continuous processes }
begin
detector.update(v1.Iend);
end;

{$EDIT ef_pulses}
{ ==============================================================================
--------- BUILDING THE FIELD PULSES STIMULATION PROCEDURES AND DIALOGS ---------
================================================================================ }


{ ------------ Single Pulse ----------------------}

var amp_sp_ef, del_sp_ef, dur_sp_ef :real; 

procedure Build_SinglePulse_EF(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  vec.fill(0); vec.fill1(amp_sp_EF,del_sp_EF+vec.Istart,del_sp_EF+dur_sp_EF+vec.Istart);
end;



{ ------------ Triple Pulses ----------------------}
var 
   amp1_tp_EF, amp2_tp_EF, amp3_tp_EF, del_tp_EF, dur1_tp_EF, dur2_tp_EF, dur3_tp_EF :real; 
procedure Build_TriplePulse_EF(seq:longint;var vec:Tvector);  
begin 
   vec.fill(0); 
   vec.fill1(amp1_tp_EF,del_tp_EF+vec.Istart,del_tp_EF+dur1_tp_EF+vec.Istart);
   vec.fill1(amp2_tp_EF,del_tp_EF+dur1_tp_EF+vec.Istart,del_tp_EF+dur1_tp_EF+dur2_tp_EF+vec.Istart);
   vec.fill1(amp3_tp_EF,del_tp_EF+dur1_tp_EF+dur2_tp_EF+vec.Istart,del_tp_EF+dur1_tp_EF+dur2_tp_EF+dur3_tp_EF+vec.Istart);
end;

var
   amp_sp_min, amp_sp_max : real ;
   nsteps_sp, subnsteps_sp : integer ;
   
procedure Build_Varying_EFsteps(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
var amp : real; n : integer ;
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  n := Floor((seq-1)/subnsteps_sp);
  amp := amp_sp_min + (amp_sp_max-amp_sp_min)*n/(nsteps_sp-1); 
  vec.fill(0); vec.fill1(amp,del_sp_EF+vec.Istart,del_sp_EF+dur_sp_EF+vec.Istart);
end;


procedure Pulse_Efield_event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   Stim_dialog.updatevar;
   case n of 
   201 : begin {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_EF+dur_sp_EF ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.global').acquisitionISI := 0.2 ; // long intestim to have the time to manually change the stim 
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='single_pulse_efield';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_sp_EF;
         TDBrecord('PG0.Exp_params').start_at:=del_sp_EF;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp_EF;
	       {then we initialize the stimulation}
	       InitializeChannels;
	       stimulator.Channels[1].BuildEp := Build_SinglePulse_EF ; 
       	 stimulator.initVectors;
         end;
   203 : begin {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_EF+dur_sp_EF ;
         TDBrecord('PG0.global').max_EP_num :=subnsteps_sp*nsteps_sp;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.global').acquisitionISI := 0.4 ; // long intestim to have the time to manually change the stim 
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='varying_pulses_efield';
         TDBrecord('PG0.Exp_Params').pulse_amplitude_min:=amp_sp_min;
         TDBrecord('PG0.Exp_Params').pulse_amplitude_max:=amp_sp_max;
         TDBrecord('PG0.Exp_Params').nsteps:=nsteps_sp;
         TDBrecord('PG0.Exp_Params').subnsteps:=subnsteps_sp;
         TDBrecord('PG0.Exp_params').start_at:=del_sp_EF;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp_EF;
	       {then we initialize the stimulation}
	       InitializeChannels;
	       stimulator.Channels[1].BuildEp := Build_Varying_EFsteps ; 
       	 stimulator.initVectors;
         end;
   end;
end;


procedure Init_PulsesDialog_EF;
var pn:integer;
begin
   amp_sp_EF := 100.0; del_sp_EF:=1000.0; dur_sp_EF:=2000.0;
   amp1_tp_EF := 50.0; amp2_tp_EF := -50.0; amp3_tp_EF := 50.0; 
   del_tp_EF  := 50.0; dur1_tp_EF:= 200.0; dur2_tp_EF:= 400.0; dur3_tp_EF:= 200.0; 
   amp_sp_min := 1; amp_sp_max := 2;  nsteps_sp:=5; subnsteps_sp:=4;
   pn:=1;
   with Stim_dialog do
   begin
   create;
   Caption := 'Efield stimulation';
   OnEvent := Pulse_Efield_event;
   setText(' ==<| Single Pulse Stimulation |> ');
   getRealA('Amplitude (uA)',amp_sp_EF,10,3,200);
   getRealA('Onset/Delay (ms)',del_sp_EF,10,3,200);
   getRealA('Duration (ms)',dur_sp_EF,10,3,200);
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   setText(' ==<| Triple Pulse Stimulation |> ');
   getRealA('Onset/Delay (ms)',del_tp_EF,10,3,200);
   getRealA('Amplitude 1 (uA)',amp1_tp_EF,10,3,200);
   getRealA('Amplitude 2 (uA)',amp1_tp_EF,10,3,200);
   getRealA('Amplitude 3 (uA)',amp1_tp_EF,10,3,200);
   getRealA('Duration 1 (ms)',dur1_tp_EF,10,3,200);
   getRealA('Duration 2 (ms)',dur1_tp_EF,10,3,200);
   getRealA('Duration 3 (ms)',dur1_tp_EF,10,3,200);
   getCommandA(' init() ',0,202); { OnEvent flag -> 201 }
   setText(' ==<| Varying Pulses Stimulation |> ');
   setText(' (pulse set by single pulse) ');
   getRealA('Amplitude min (uA)',amp_sp_min,10,3,200);
   getRealA('Amplitude max (uA)',amp_sp_max,10,3,200);
   getIntegerA('Number of Steps',nsteps_sp,10,200);
   getIntegerA('Steps # per level',subnsteps_sp,10,200);
   getCommandA(' init() ',0,203); { OnEvent flag -> 201 }
   end;                                      
   Stim_dialog.show;
end;



{$EDIT ef_sin}
{ ==============================================================================
--------- BUILDING THE SINUSOIDS STIMULATION PROCEDURES AND DIALOGS -------------
================================================================================ }


var 
  amp_sin, freq_sin, phase_sin : real ; // for single sin
  singlesin_dialog, multiplesin_dialog, chirp_dialog : Tdialog ;
  min_amp_sin, max_amp_sin, freq_start, freq_end : real;  freq_step_num, global_freq_index : integer ; // for multiple sin
  freq_vec, amp_freq_vec : Tvector; t0_trial : real;
  chirp_amp, chirp_freq_start, chirp_freq_end, chirp_duration : real;

//=================================================
// ------- SINGLE SINUSOIDS PROTOCOL
//=================================================

procedure Build_sin(seq:longint;var vec:Tvector); {Build a sinewave into vec }
begin
vec.sinewave(amp_sin,1.0/freq_sin,phase_sin) ; 
end;

procedure prepare_singlesin;
begin
         TDBrecord('PG0.global').cont_choice := True ; 
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='ef_single_sin';
         TDBrecord('PG0.Exp_Params').sin_amplitude:=amp_sin;
         TDBrecord('PG0.Exp_params').frequency:=freq_sin;
         TDBrecord('PG0.Exp_Params').phase_shift:=phase_sin;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
     detector.create; detector.InitTimer(v1, CONTINUOUS_TIMER);

         stimulator.Channels[1].BuildEp := Build_Sin ; 
         stimulator.initVectors;
end;
         
         
procedure SingleSin_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   singlesin_dialog.updatevar;
   case n of 
   201 : prepare_singlesin;
   end;
end;

//=================================================
// ------- CHIRP PROTOCOL
//=================================================

procedure Build_chirp(seq:longint;var vec:Tvector);
var ii:integer ; freq : real ;
begin
  for ii:=vec.Istart to vec.Iend do
  begin
      freq := chirp_freq_start+SQR(ii-vec.Istart)/SQR(vec.Iend-vec.Istart)*(chirp_freq_end-chirp_freq_start) ;   // freq prop. to t^2
      vec[ii] := chirp_amp*Sin(2.*PI*freq/1000.*vec.ConvX(ii));  // ms -> s
  end;
end;

procedure prepare_chirp;
var bf, ii : integer; freq : real ;
begin
         {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.global').episode_duration :=  chirp_duration ;
         TDBrecord('PG0.global').max_EP_num := 1 ; // 1 episodes !!
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= 0.2 ;  // small break between the stims
         if amplifier='nrn_simulation' then TDBrecord('PG0.global').FadvanceON := True else TDBrecord('PG0.global').FadvanceON := False;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='ef_chirp_stimulation';
         TDBrecord('PG0.Exp_Params').chirp_amplitude:=amp_sin;
         TDBrecord('PG0.Exp_params').chirp_frequency_start:=chirp_freq_start;
         TDBrecord('PG0.Exp_Params').chirp_frequency_end:=chirp_freq_end;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := Build_Chirp ; 
         stimulator.initVectors;
end;
         
         
procedure Chirp_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   chirp_dialog.updatevar;
   case n of 
   201 : prepare_chirp;
   end;
end;

//=================================================
// ------- MULTIPLE SINUSOIDS PROTOCOL
//=================================================


var current_stop_value : integer ;
var exp_freq_vec, exp_time_vec, exp_amp_vec : Tvector; // for saving freq and time
   var string_for_saving :  string;

procedure check_for_stop_acq(n:integer);
begin
    if not continu_flag then acquisition.stop;
    if n>current_stop_value then acquisition.stop ;

end;

procedure initialize_a_single_exp;
begin
      global_freq_index :=global_freq_index+1;
      freq_sin := freq_vec[global_freq_index];
      amp_sin := amp_freq_vec[global_freq_index];
      stim_dialog.update; // to see the values of the amp and frequencies                                      
      current_stop_value := Round((1+5./freq_sin)/CONTINUOUS_TIMER); // 5s min, +5periods in case of long period

       exp_freq_vec.addtolist(freq_sin); // for recording
       exp_amp_vec.addtolist(amp_sin);
       
     RTneuron.execute('finitialize()'); // reinitializing NEURON
     stimulator.Channels[1].BuildEp := Build_Sin ; 
     stimulator.initVectors;
     // then Tdetector settings, we redo it for security !
     detector.create; detector.InitTimer(v1, CONTINUOUS_TIMER);
     detector.AddEvent(check_for_stop_acq, 0.);
end;

procedure multiplesin_endprocess;
begin
   exp_time_vec.addtolist(v1.Xend);
   detector.update(v1.Iend);
   if (global_freq_index<freq_step_num) and (continu_flag=True) then
   begin
      initialize_a_single_exp;
      acquisition.InstallProcess(nil, nil, nil, multiplesin_endprocess); // need to make disapear the myinitprocess0
      if SAVING then acquisition.startandsave(True) else acquisition.start;  
   end
   else begin // we need to save the vectors
      continu_flag:=False;   // we prevent restarting !
      exp_freq_vec.SaveAsObject(acquisition.genericfilename+'_freq');
      exp_time_vec.SaveAsObject(acquisition.genericfilename+'_time');
      exp_amp_vec.SaveAsObject(acquisition.genericfilename+'_amp');
   end;
end;


procedure Shuffle_2Vector(var vec1, vec2:Tvector);   // identically shuffles 2 vectors...
var ii,i1,i2:integer; temp1, temp2:real;
begin
    for ii:=0 to 10*vec1.Iend do 
    begin
        i1:= 1+Random(vec1.Iend-1); i2:= 1+Random(vec1.Iend-1);
        temp1:= vec1[i1]; vec1[i1]:=vec1[i2]; vec1[i2]:=temp1;
        temp2:= vec2[i1]; vec2[i1]:=vec2[i2]; vec2[i2]:=temp2;
    end;
end;

procedure launch_multiple_sim; // also handle the case of the interrupted experiment
begin
   exp_freq_vec.create(t_double, 0, -1);
   exp_time_vec.create(t_double, 0, -1);
   exp_time_vec.addtolist(0);  // we add zero !
   exp_amp_vec.create(t_double, 0, -1);
   string_for_saving := TDBrecord('PG0.global').PathOfTheDay+'multiple_sin';
   InitializeChannels; // we can initialize the channels
   initialize_a_single_exp;   
   acquisition.InstallProcess(nil, nil, nil, multiplesin_endprocess);
  if SAVING then acquisition.startandsave else acquisition.start;
end; { launch_multiple_sim }

  
procedure prepare_multiplesin;
var ii : integer ; exponent : real;
begin
     freq_vec.create(t_double, 1, freq_step_num);
     amp_freq_vec.create(t_double, 1, freq_step_num);
     for ii:=1 to freq_step_num do
     begin
          exponent := LN(freq_start)+(ii-1)/(freq_step_num-1)*(LN(freq_end)-LN(freq_start)) ;
          freq_vec[ii] := Exp(exponent) ;
          exponent := LN(min_amp_sin)+(ii-1)/(freq_step_num-1)*(LN(max_amp_sin)-LN(min_amp_sin)) ;
          amp_freq_vec[ii] := Exp(exponent) ;
     end;
     Shuffle_2Vector(freq_vec, amp_freq_vec); // then we shuffle the order of frequencies
     
     t0_trial :=0;
     SAVING := True ; 
     global_freq_index := 0 ; // we start the sequence of stimulation
     continu_flag := True;
     maindialog.update;
     stim_dialog.update;
     
     {we write all the relevant global informations}
     TDBrecord('PG0.global').cont_choice := True ;  // single sinusiod in continuous mode
     TDBrecord('PG0.global').Efield_stim := True ;
     TDBrecord('PG0.global').patch_stim := False ;
     TDBrecord('PG0.global').stim := True ;
     TDBrecord('PG0.Exp_Params').clear;
     TDBrecord('PG0.Exp_Params').exp_type:='ef_multiple_sin';
     TDBrecord('PG0.Exp_Params').freq_start:=freq_start;
     TDBrecord('PG0.Exp_params').freq_stop:=freq_end;
     TDBrecord('PG0.Exp_Params').min_amp_freq:=min_amp_sin;
     TDBrecord('PG0.Exp_params').max_amp_freq:=max_amp_sin;
     {then we initialize the stimulation}
end;
         
        
procedure EF_Sin_Event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   Stim_dialog.updatevar;
   case n of 
   201 : prepare_singlesin;
   202 : prepare_chirp;
   203 : prepare_multiplesin;
   204 : launch_multiple_sim;
   end;
end;
 
//=================================================
// ------- THEN DIALOG
//=================================================

procedure Init_SinDialog_EF;
begin
    amp_sin := 40 ;  freq_sin := 10 ;  phase_sin := 0 ; // for single sin
    freq_start := 0.1 ;  freq_end := 200 ; freq_step_num := 10 ; // for multiple sin
    min_amp_sin := 40 ; max_amp_sin := 40 ;
    chirp_freq_start := 0.001 ;  chirp_freq_end := 100 ; chirp_amp := 40 ; chirp_duration := 10000 ; // for multiple sin
    
   with Stim_dialog do
   begin
   create;
   Caption := 'Efield stimulation';
   OnEvent := EF_Sin_Event;
   
   setText(' ==<| Single Sinusoid Stimulation |> ');
   getRealA('Amplitude (pA or mV)',amp_sin,10,3,200);
   getRealA('frequency (Hertz)',freq_sin,10,3,200);
   getRealA('phase shift (Rd)',phase_sin,10,3,200);
   setText('(watch here to see multiple_sin variations)');
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   
   setText(' ==<| Chirp Stimulation |> ');
   getRealA('Amplitude (pA or mV)',chirp_amp,10,3,200);
   getRealA('frequency start (Hz)',chirp_freq_start,10,3,200);
   getRealA('frequency end (Hz)',chirp_freq_end,10,3,200);
   getRealA('duration (ms)',chirp_duration,10,3,200);
   getCommandA(' init() ',0,202); { OnEvent flag -> 202 }
   
      setText(' ==<| Multiple Sinusoids Stimulation |> ');
      getRealA('start frequency (Hz)',freq_start,10,3,200);
      getRealA('stop frequency (Hz)',freq_end,10,3,200);
      getIntegerA('number of freq steps',freq_step_num,10,200);
      setText(' Increasing amplitude with frequency ');
      getRealA(' min amplitude at low freq (pA or mV)',min_amp_sin,10,3,200);
      getRealA(' max amplitude at high freq (pA or mV)',max_amp_sin,10,3,200);
      getCommandA(' init() ',0,203); { OnEvent flag -> 201 }
      getCommandA(' START ',0,204); { OnEvent flag -> 301 }
      getIntegerA('Index of the current step',global_freq_index,10,200);
   end;
   Stim_dialog.show;
end;

{$EDIT efield_and_patch_pulses}
{ ==============================================================================
---- BUILDING THE DOUBLE PULSES (Field qnd patch) PROCEDURES AND DIALOGS -------
================================================================================ }


{ ------------ Single Pulse ----------------------}

var amp_sp_ap, del_sp_ap, dur_sp_ap :real; 

procedure Build_SinglePulse_ap(seq:longint;var vec:Tvector);  {pulse procedure called at each buildep}
begin { we fill of 0, except between the t0+delay and t0+delay+duration }
  vec.fill(0); vec.fill1(amp_sp_ap,del_sp_ap+vec.Istart,del_sp_ap+dur_sp_ap+vec.Istart);
end;

procedure SinglePulse_patch_event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   Stim_dialog.updatevar;
   case n of 
   201 : begin
	 {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_ap+dur_sp_ap ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='single_pulse';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_sp_ap;
         TDBrecord('PG0.Exp_params').start_at:=del_sp_ap;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp_ap;
	       {then we initialize the stimulation}
	       InitializeChannels;
	       stimulator.Channels[1].BuildEp := Build_SinglePulse_ap ; 
       	 stimulator.initVectors;
         end;
   end;
end;


procedure Init_PulsesDialog_ap;
var pn:integer;
begin
   amp_sp_ap := 50.0; del_sp_ap:=100.0; dur_sp_ap:=800.0;

   pn:=1;
   with Stim_dialog do
   begin
   create;
   Caption := 'Patch stimulation';
   OnEvent := SinglePulse_patch_event;
   setText(' ==<| Single Pulse Stimulation |> ');
   getRealA('Amplitude (pA or mV)',amp_sp_ap,10,3,200);
   getRealA('Onset/Delay (ms)',del_sp_ap,10,3,200);
   getRealA('Duration (ms)',dur_sp_ap,10,3,200);
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   show;
   end;
end;

{$EDIT current_field_charact}
{ ==============================================================================
- Characterizing the relationship between applied current and measured field  --
================================================================================ }


{we use the procedures of ef_pulses}

var vfield_baseline, vfield_jump, Iinj_baseline, Iinj_jump, Rsys : real ;  ce_memo : Tmemo ;
    field_vector, current_vector : Tvector ; field_current_graph : Tgraph ;
    conductivity_flag : integer ; distance_electrodes : real;
    

procedure currentfield_process;
var vfield_vec, Iinj_vec : Tvector ;
begin
    Iinj_vec.create; Vcopy(v3,Iinj_vec) ; // injected current on channel 3
    Iinj_baseline := Iinj_vec.mean(1,del_sp_EF-1); {constantes a ajuster en fonction des parametres du pulse}
    Iinj_jump := Iinj_vec.mean(del_sp_EF+dur_sp_EF/2.-1,del_sp_EF+dur_sp_EF-1)-Iinj_baseline;
    vfield_vec.create; Vcopy(v1,vfield_vec) ; // field recording on channel 1
    vfield_baseline := vfield_vec.mean(1,del_sp_EF-1); {constantes a ajuster en fonction des parametres du pulse}
    vfield_jump := vfield_vec.mean(del_sp_EF+dur_sp_EF/2.-1,del_sp_EF+dur_sp_EF-1)-vfield_baseline;
    {we add this to the list}
    field_vector.addtolist(vfield_jump) ;
    current_vector.addtolist(Iinj_jump) ;
    field_current_graph.refresh ;
      
    ce_memo.lines[2]:='I jump = '+Rstr(Iinj_jump,6,1)+' uA';
    ce_memo.lines[3]:='Ve jump = '+Rstr(Vfield_jump,6,2)+' mV';
    ce_memo.refresh;
end;

procedure write_current_field_charact;
var ii:integer; st, stf : string ; Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint;
begin
    stf := TDBrecord('PG0.global').PathOfTheDay ; 
    stf := stf+'conduct.txt'; // we first write a general file
    openText(1,stf,false);
    for ii := 0 to field_vector.Iend-1 do begin st:=Rstr(current_vector[ii],1,6)+chr(9); writeText(1, st); end;
    writeText(1, Chr(10)); // newline
    for ii := 0 to field_vector.Iend-1 do begin st:=Rstr(field_vector[ii],1,6)+chr(9); writeText(1, st); end;
    closeText(1);   
    // then we copy it with the conductivity flag and date
    case conductivity_flag of
    1 : CopyFile(stf,stf+'low.txt');
    2 : CopyFile(stf,stf+'middle.txt');
    3 : CopyFile(stf,stf+'high.txt');
    end;
    DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
    CopyFile(stf,stf+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'.txt');  // to keep a copy
end;

procedure Current_Field_event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   Stim_dialog.updatevar;
   case n of 
   201 : begin
	 {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_EF+dur_sp_EF ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.global').acquisitionISI := 5 ; // long intestim to have the time to manually change the stim 
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='current-field-charact';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_sp_EF;
         TDBrecord('PG0.Exp_params').start_at:=del_sp_EF;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp_EF;
         TDBrecord('PG0.Exp_Params').conductivity := conductivity_flag ;
         TDBrecord('PG0.Exp_Params').electrode_distance := distance_electrodes ;
         {some initialization}
         field_vector.create; 
         current_vector.create; 
         field_current_graph.create(current_vector, field_vector, 0, -1) ;
         field_current_graph.Autolimit := True ;
         field_current_graph.show ;
	       {then we initialize the stimulation}
	       InitializeChannels; addObject(1,1,ce_memo);
	       stimulator.Channels[1].BuildEp := Build_SinglePulse_EF ; 
       	 stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, nil, currentfield_process, set_dac_to_zero);
         end;
   203 : write_current_field_charact;
   end;
end;


procedure Init_CurrentField_Dialog_EF;
var pn:integer;
begin
   amp_sp_EF := 5000.0; del_sp_EF:=100.0; dur_sp_EF:=800.0;
   distance_electrodes := 1000;
   with Stim_dialog do
   begin
   create;
   Caption := 'Current-Field characterization';
   OnEvent := Current_Field_event;
   setText(' ==<| Pulse Stimulation |> ');
   getRealA('Amplitude (pA or mV)',amp_sp_EF,10,3,200);
   getRealA('Onset/Delay (ms)',del_sp_EF,10,3,200);
   getRealA('Duration (ms)',dur_sp_EF,10,3,200);
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   setText('');
   getRealA('Distance (um)',distance_electrodes,10,3,200);
   getStringList('Solution : ','low conductivity|middle conductivity|high conductivity', conductivity_flag,202) ;
   getCommandA(' Write File ',0,203); { OnEvent flag -> 201 }
   end;
   ce_memo.create(''); ce_memo.font.name:='Times New Roman'; ce_memo.font.size:=13;
   ce_memo.font.color:=rgb(0,0,0);  ce_memo.font.style:=fs_bold;
   ce_memo.lines[2]:='I jump = '+Rstr(Iinj_jump,6,1)+' uA';
   ce_memo.lines[3]:='Ve jump = '+Rstr(Vfield_jump-vfield_baseline,6,2)+' mV';
   Stim_dialog.show;                   
   SAVING := True ;
end;


{$EDIT get_the_pol}
{ ==============================================================================
- Characterizing the the membrane polarization for a given field  --
================================================================================ }

// we use the procedures of ef_pulses and current_field_charact

var gtp_mean_vm, gtp_mean_i : Taverage ; Dvm_vector : Tvector ;
    v_baseline, v_jump : real ;
    i_vm_graph : Tgraph ;

procedure GetThePol_initprocess;
begin
    gtp_mean_i.reset;
    gtp_mean_i.StdOn := True ;
    gtp_mean_vm.reset;
    gtp_mean_vm.StdOn := True ;
end;

procedure GetThePol_process;
begin
    gtp_mean_i.add(v3);
    gtp_mean_vm.add(v1);
end;


procedure GetThePol_endprocess;
var v_vec, Iinj_vec : Tvector ;
begin
    Iinj_vec.create; Vcopy(gtp_mean_i,Iinj_vec) ; // injected current on channel 3
    Iinj_baseline := Iinj_vec.mean(1,del_sp_EF-1); {constantes a ajuster en fonction des parametres du pulse}
    Iinj_jump := Iinj_vec.mean(del_sp_EF+dur_sp_EF/2.-1,del_sp_EF+dur_sp_EF-1)-Iinj_baseline;
    v_vec.create;
    Vcopy(gtp_mean_vm,v_vec) ; 
    v_baseline := v_vec.mean(1,del_sp_EF-1); {constantes a ajuster en fonction des parametres du pulse}
    v_jump := v_vec.mean(del_sp_EF+dur_sp_EF/2.-1,del_sp_EF+dur_sp_EF-1)-v_baseline;
    {we add this to the list}
    Dvm_vector.addtolist(v_jump) ;
    current_vector.addtolist(Iinj_jump) ;
    i_vm_graph.refresh ;
       
    ce_memo.lines[2]:='I jump = '+Rstr(Iinj_jump,6,1)+' uA';
    ce_memo.lines[3]:='Vm jump = '+Rstr(v_jump,6,2)+' mV';
    ce_memo.refresh;
    set_dac_to_zero;
end;

procedure write_GetThePol;
var ii:integer; st, stf : string ; Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint;
begin
    stf := TDBrecord('PG0.global').PathOfTheDay ; 
    stf := stf+'polarization.txt'; // we first write a general file
    openText(1,stf,false);
    for ii := 0 to DVm_vector.Iend-1 do begin st:=Rstr(current_vector[ii],1,6)+chr(9); writeText(1, st); end;
    writeText(1, Chr(10)); // newline
    for ii := 0 to Dvm_vector.Iend-1 do begin st:=Rstr(Dvm_vector[ii],1,6)+chr(9); writeText(1, st); end;
    closeText(1);   
    // then we copy it with the conductivity flag and date
    case conductivity_flag of
    1 : CopyFile(stf,stf+'low.txt');
    2 : CopyFile(stf,stf+'middle.txt');
    3 : CopyFile(stf,stf+'high.txt');
    end;
    DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
    CopyFile(stf,stf+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+'.txt');  // to keep a copy
end;


procedure GetThePol_event(n:integer); 
begin {when we modify the dialog, we adjust the stimulation params}
   Stim_dialog.updatevar;
   case n of 
   201 : begin {we write all the relevant global informations}
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_EF+dur_sp_EF ;
         TDBrecord('PG0.global').max_EP_num :=10 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := False ;
         TDBrecord('PG0.global').acquisitionISI := 1 ; // no need of long stim interval 
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='get_the_pol';
         TDBrecord('PG0.Exp_Params').pulse_amplitude:=amp_sp_EF;
         TDBrecord('PG0.Exp_params').start_at:=del_sp_EF;
         TDBrecord('PG0.Exp_Params').pulse_duration:=dur_sp_EF;
	       {then we initialize the stimulation}
	       InitializeChannels;
	       stimulator.Channels[1].BuildEp := Build_SinglePulse_EF ; 
       	 stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, GetThePol_initprocess, GetThePol_process, GetThePol_endprocess);
         end;
   203 : write_GetThePol;
   end;
end;


procedure Init_GetThePol;
var pn:integer;
begin
   {some initialization}
   Dvm_vector.create; 
   current_vector.create; 
   i_vm_graph.create(current_vector, Dvm_vector, 0, -1) ;
   i_vm_graph.Autolimit := True ;
   i_vm_graph.show ;
   gtp_mean_vm.create(t_single, 0, 1);
   gtp_mean_vm.color := CL_Red ;
   gtp_mean_vm.LineWidth := 3 ;
   AddObject(1, 1, gtp_mean_vm);
   AddObject(1, 1, gtp_mean_vm.VstdUp);
   AddObject(1, 1, gtp_mean_vm.VstdDw);
   gtp_mean_i.create(t_single, 0, 1);
   gtp_mean_i.color := CL_Red ;
   gtp_mean_i.LineWidth := 3 ;
   AddObject(1, 3, gtp_mean_i);
   AddObject(1, 3, gtp_mean_i.VstdUp);
   AddObject(1, 3, gtp_mean_i.VstdDw);
   amp_sp_EF := 5000.0; del_sp_EF:=200.0; dur_sp_EF:=800.0;
   pn:=1;
   
   with Stim_dialog do
   begin
   create;
   Caption := 'Polarization';
   OnEvent := GetThePol_event;
   setText(' ==<| Get the Polarization |> ');
   getRealA('Onset/Delay (ms)',del_sp_EF,10,3,200);
   getRealA('Duration (ms)',dur_sp_EF,10,3,200);
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   setText('');
   getStringList('Solution : ','low conductivity|middle conductivity|high conductivity', conductivity_flag,202) ;
   getCommandA(' Write File ',0,203); { OnEvent flag -> 201 }
   end;
   ce_memo.create(''); ce_memo.font.name:='Times New Roman'; ce_memo.font.size:=13;
   ce_memo.font.color:=rgb(0,0,0);  ce_memo.font.style:=fs_bold;
   Stim_dialog.show;
   SAVING :=True ;
end;

{$EDIT track_the_AP}
{ ==============================================================================
- What is the current pulse needed to trigger an AP for a given field  --
================================================================================ }


var Iamp_trackAP0, Iamp_trackAP, Eamp_trackAP, del_trackAP, dur_trackAP :real; 
    Iamp_list, recorded_t : Tvector ; current_string : string ;
    
    
// the two start and decay time should be different 
procedure Build_IPulse_trackAP(seq:longint;var vec:Tvector);  
begin 
  vec.fill(0); vec.fill1(Iamp_trackAP,vec.Xstart+del_trackAP,del_trackAP+dur_trackAP+vec.Xstart);
end;
procedure Build_EPulse_trackAP(seq:longint;var vec:Tvector);  
begin 
  vec.fill(0); vec.fill1(Eamp_trackAP,vec.Xstart+del_trackAP,del_trackAP+dur_trackAP+vec.Xstart);
end;


procedure initialize_trackAP;
begin                   
         Iamp_list.create; recorded_t.create;
         recorded_t.AddToList(0); recorded_t.AddToList(0);
         Iamp_trackAP := Iamp_trackAP0 ;
         Iamp_list.AddToList(0); Iamp_list.AddToList(Iamp_trackAP);
         TDBrecord('PG0.global').cont_choice := True ;  // this in continuous mode !!!
         TDBrecord('PG0.global').episode_duration :=  2*del_sp_ap+dur_sp_ap ;
         TDBrecord('PG0.global').max_EP_num :=0 ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;   // flags fot the initialize channels !!!
         TDBrecord('PG0.global').patch_stim := True ;
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='track_the_ap';
         TDBrecord('PG0.Exp_Params').current_pulse_duration:=dur_sp_ap;
end;



procedure launch_trackAP;
begin
     {then we initialize the stimulation}
	   InitializeChannels;
     stimulator.Channels[1].BuildEp := Build_IPulse_trackAP ;  // channel 1 is Im, see channels_settings
     stimulator.Channels[2].BuildEp := Build_EPulse_trackAP ; 
   	 stimulator.initVectors;
end;


var THdetect : Tdetector;spiketimes : Tvector ;

procedure InitTHdetect;
var 
threshold : real ;refrac : real ; yinit : real;
begin
   spiketimes.create(t_single,0,-1);
   threshold := -50.0; // threshold at : ... mV 
   refrac := 0.003 ; // at least ... s between two events
   yinit := -60.0 ;
   THdetect.create;
   THdetect.InitCrossings(v1,spiketimes,TRUE,FALSE,threshold,threshold,refrac,yinit,FALSE);
end;

procedure trackAP_InitProcess; {executer avec acquisition.start, mais apres tout, ici tous les objets ont ete initialises, donc on peut les utiliser}
begin
   InitTHdetect;
   t0_trial := v1.Xend ; // to get the time that has last since the experiment start
end;


procedure trackAP_processCont; // procedure appelle environ tous les 40ms
begin
if continu_flag=False or (v1.Xend-t0_trial>2*dur_trackAP) then acquisition.stop ;
end;

var global_step : integer ;

procedure trackAP_EndProcess; 
var iamp_jump : real ;
begin 
      THdetect.Update(v1.Iend); // code en dur, similaire a calculsum
      global_step := global_step+1 ;
      // CALCULUS TO DETERMINE THE NEW  current
      // ---- if there is a spike we decrease
      if spiketimes.Iend>=1  then Iamp_trackAP := Iamp_trackAP-Abs( (Iamp_list[Iamp_list.Iend-1] - Iamp_trackAP)/2.) ;
      // ---- if there is no spike  we increase
      if spiketimes.Iend=0 then 
      begin
           if Iamp_trackAP>=Iamp_list.Ymax then iamp_jump := Abs(Iamp_list[Iamp_list.Iend-1] - Iamp_trackAP)  // still a big jump
           else iamp_jump := Abs(Iamp_list[Iamp_list.Iend-1] - Iamp_trackAP)/2. ; // smaller and smaller jump
      Iamp_trackAP := Iamp_trackAP +iamp_jump ;
      end;
              
      Iamp_list.AddToList(Iamp_trackAP); Iamp_list.SaveAsObject(current_string+'_iamp') ;
      recorded_t.addtolist(v1.Xend-t0_trial);recorded_t.SaveAsObject(current_string+'_t') ;
    t0_trial := v1.Xend ; 
    if continu_flag then begin acquisition.startandsave(true); end;   
end;


procedure Init_trackAP_Dialog;
var pn:integer;
begin
   Iamp_trackAP0 := 100 ; //pA
   Eamp_trackAP:=5000 ;  del_trackAP := 200 ;  dur_trackAP :=500 ;
   pn:=1;
   with Stim_dialog do
   begin
   create;
   Caption := 'Track AP';
   OnEvent := SinglePulse_patch_event;
   setText(' <| Track Action Potential Triggering |> ');
   getRealA('initial value (pA)',Iamp_trackAP0,10,3,200);
   getRealA('Onset/Delay (ms)',del_trackAP,10,3,200);
   getRealA('Duration (ms)',dur_trackAP,10,3,200);
   getCommandA(' init() ',0,201); { OnEvent flag -> 201 }
   getBooleanA(' continu ?', continu_flag, 200);
   show;
   end;
end;

{$EDIT iv_curve_with_field}
{ ==============================================================================
- To insure that the observed polarization is due to a change in transmembrane
potential (and not a problem of reference), we check that the reversal potential
of the Sodium channels is left unchanged ! To do so, we do iv-curves with the field
stimulation ON)  --------------------------------------------------------------
================================================================================ }

// we use single_pulse_EF to generate the field stimulation, 
//   different start and stop than the VC stimulation

var
   v_start_iv, v_start0_iv , v_step_iv : real ; {step parameters }
   max_step_iv : integer ; int_repet : integer ; int_step : integer ;{ index for the number of steps }
   IV_moy :  Taverage ; iv_dialog2 : Tdialog ; iv_dialog : Tdialog ;
   iv_v : Tvector ; iv_i : Tvector ; iv_graph : Tgraph ;
   del_iv, dur_iv, interstim_iv : real ;


procedure ProcessIV(seq:longint;var vec:Tvector);
var dv : real;
begin 
   dv := (seq-1)*v_step_iv ;
   vec.fill(0); 
   vec.fill1(v_start_iv+dv,del_iv+vec.Istart,del_iv+dur_iv+vec.Istart);
end;

procedure iv_initprocess;
begin
   iv_i.create(t_single,0,-1);
   iv_i.X0:=v_start_iv ; iv_i.DX := v_step_iv ;
   iv_i.Mode := DM_LINE_DIAMOND ;
   iv_i.Show;
end;

procedure ivcurve_process;
var tt:Tvector ;
begin 
  tt.create; Vcopy(v1,tt) ; 
  iv_i.addtolist(tt.mean(del_iv+dur_iv/2,del_iv+4*dur_iv/5));
  iv_i.invalidate ;
  //iv_i.SetWorld(iv_i.X0,iv_i.Ymin,iv_i.Xmax,iv_i.Ymax);
end;

procedure prepare_iv;
begin
         {we write all the relevant global informations}
         amplifier := TDBrecord('PG0.global').amplifier ;
         TDBrecord('PG0.global').clamp_int := 2 ; // VC
         TDBrecord('PG0.global').cont_choice := False ; 
         TDBrecord('PG0.global').episode_duration :=  2*del_iv+dur_iv ;
         TDBrecord('PG0.global').max_EP_num :=max_step_iv ;
         TDBrecord('PG0.global').stim := True ;
         TDBrecord('PG0.global').Efield_stim := True ;
         TDBrecord('PG0.global').patch_stim := True ;
         TDBrecord('PG0.global').acquisitionISI:= interstim_iv ;  // small beak between the stims
         TDBrecord('PG0.Exp_Params').clear;
         TDBrecord('PG0.Exp_Params').exp_type:='iv_curve_with_field';
         TDBrecord('PG0.Exp_Params').v_start_iv:=v_start_iv;
         TDBrecord('PG0.Exp_params').v_step_iv:=v_step_iv;
         TDBrecord('PG0.Exp_Params').step_number:=max_step_iv;
         {then we initialize the stimulation}
         InitializeChannels; // we can initialize the channels
         stimulator.Channels[1].BuildEp := ProcessIV ; 
	       stimulator.Channels[2].BuildEp := Build_SinglePulse_EF ; 
         stimulator.initVectors;
         acquisition.InstallProcess(my_initprocess0, iv_initprocess, ivcurve_process, set_dac_to_zero);
end;
         
procedure IVcurve_Event(n:integer);
var amplifier : string ; 
begin    
   Stim_dialog.updatevar;
   case n of 
   201 : prepare_iv ;
   end;
end;


procedure IVcurve_Init;
begin
   amp_sp_EF := 5000.0; del_sp_EF:=100.0; dur_sp_EF:=800.0;
   v_start_iv := -20; v_step_iv :=10 ;  int_repet:=0 ; max_step_iv := 12 ;
   interstim_iv := 1 ; del_iv := 450 ; dur_iv := 150 ;
   with Stim_dialog do
   begin
      create;
      OnEvent :=IVcurve_event ;
      setText(' ==<| IV curve Parameters |> ');
      getRealA('starting value (mV)',v_start_iv,10,3,200);
      getRealA('Step absolute (mV)',v_step_iv,10,3,200);
      getIntegerA('Number of Steps',max_step_iv,10,200);
      getRealA('Onset/Delay (ms)',del_iv,10,3,200);
      getRealA('Duration (ms)',dur_iv,10,3,200);
      getRealA('interstim (s)',interstim_iv,10,3,200);
      setText(' ==<| Field Stim Parameters |> ');
      getRealA('Amplitude (pA or mV)',amp_sp_EF,10,3,200);
      getRealA('Onset/Delay (ms)',del_sp_EF,10,3,200);
      getRealA('Duration (ms)',dur_sp_EF,10,3,200);
      setText('');
      getCommandA('init protocol',0,201);
      caption := 'IV with field';
   end;
   prepare_iv;
   Stim_dialog.show;
   SAVING:=True;
end;




{$EDIT main_dialog}
{ ==============================================================================
--------- LAUNCHING THE EXPERIMENT ----------------------------------------------
================================================================================ }

procedure launch_exp;
var Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; protocol, PathOfTheDay, sep, amplifier : string ; {variables to fetch the date and time }
begin
  amplifier := TDBrecord('PG0.global').amplifier ;
  if amplifier='nrn_simulation' then acquisition.Fcontinuous:=True ; // NEURON doesn't support well episode mode

  protocol := TDBrecord('PG0.Exp_params').exp_type ;
  PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
  acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+  '_'+protocol ;
  
  if SAVING then acquisition.startandsave else acquisition.start;
end;
 
{ ==============================================================================
--------- loading the NEURON files  --------------------------------------------
================================================================================ }

procedure load_nrn_files;   // load the NEURON model
var clamp_int : integer ; full_path : string ;
begin
clamp_int := TDBrecord('PG0.global').clamp_int ;
if clamp_int=1 then full_path := TDBrecord('PG0.global').loadnrnPath+'Iclamp_hh.hoc'
else full_path := TDBrecord('PG0.global').loadnrnPath+'Vclamp_hh.hoc';
RTneuron.execute('load_file("'+full_path+'")');
end;
          
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure MainDialog_update(n:integer); 
var amplifier : string ;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}     
  if acquisition.IsRunning then acquisition.stop; 
  MainDialog.updatevar;
  TDBrecord('PG0.global').Gain1_int:=gain1_int;
  TDBrecord('PG0.global').Gain2_int:=gain2_int;
  TDBrecord('PG0.global').Gain3_int:=gain3_int;
  clamp_int:=TDBrecord('PG0.global').clamp_int; 
  
  case n of
    101: begin 
              Page := 1 ;               
              case protocol_choice of
		             1 : begin Stim_dialog.close ; TDBrecord('PG0.global').stim:=False;TDBrecord('PG0.global').cont_choice:=True;
                     InitializeChannels;
                     acquisition.InstallProcess(nil, nil, nil, set_dac_to_zero);
                     end;
		             2 : Init_PulsesDialog_EF; 
		             3 : Init_SinDialog_EF;
		             5 : Init_CurrentField_Dialog_EF;
		             6 : Init_GetThePol;
		             7 : Init_trackAP_Dialog;
		             8 : IVcurve_Init;
              end;
         end;
    111 : begin SetGain1; InitializeChannels;  end;
    112 : begin SetGain2; InitializeChannels;  end;
    113 : begin SetGain3; InitializeChannels;  end;
    200 : launch_exp;
    201 : acquisition.stop ;
    301 : comments := '';
    280 : load_nrn_files ;
    281 : RTneuron.Execute(dll_load);
    282 : RTneuron.Restart;
  end;
  gain1:=TDBrecord('PG0.global').Gain1;gain2:=TDBrecord('PG0.global').Gain2;gain3:=TDBrecord('PG0.global').Gain3;    
  clamp_int:=TDBrecord('PG0.global').clamp_int ;      
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -> dangerous for division, e.g. freq) }
var amplifier : string ;
begin
DB.create;
dll_load := TDBrecord('PG0.global').loadnrnpath ; dll_load := 'nrn_load_dll("'+dll_load+'nrnmech.dll")';
PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ; // data path
//------------ MAIN dialog
   with MainDialog do
   begin
   create;
   OnEvent := MainDialog_update;
   amplifier := TDBrecord('PG0.global').amplifier ; 
   setText(' ================================= ');
   setText(' ---------------< Protocol Selection >----------------- ');
   setText('');
   getStringList(' PROTOCOL  ',ProtoNames,'1|2|3|4',protocol_choice,101);  { Onevent flag ->199}
   setText(' ================================= ');
   getStringList(' IC / VC  ','  Iclamp  |  Vclamp ','1|2',clamp_int,102);  { Onevent flag ->199}
   setText('');
   if amplifier='multiclamp' then 
     begin 
	setText(' ==<| GAIN  multiclamp|>== ');
	getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_int,111);
	getStringListA('Secondary Output ','1 | 2 | 5 | 10 | 20 | 50 | 100',Gain2_int,112);
	setText(' ==<| SCALE  stim. unit|>== ');
	getStringListA('Range (uA/V) ','1 | 10 | 100 | 1000',Gain3_int,113);
	setText('');
     end;
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   getBoolean('continu ? (close loop!)', continu_flag);

   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='Main Dialog';
  end;
Maindialog.show;
Stim_dialog.create ;
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}


var 
    already_initiated : boolean ; // to know if we need to reinitialize the TDBrecord
    global, Exp_params : TDBrecord ;

procedure global_init;
var ii:integer; PathOfTheDay : string ;
  Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; {variables to fetch the date and time }
begin
RTneuron.resetParams;
ii:=1;
global.create;
global.amplifier:='multiclamp'; // choice of the amplifier
DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
PathOfTheDay := 'D:\yann\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; // 'Z:/home/yann/experiments/DATA/'; 
if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
global.PathOfTheDay := PathOfTheDay ;
global.loadnrnPath := 'Z:/home/yann/experiments/myelphy/nrn_files/' ;
global.root_path :='Z:/home/yann/experiments/myelphy/' ;
global.sep:='/_';  // separator for loading files  (has to change between linux and mswin)
global.f_acq:=10; // in kHz
global.gain1:=1; // gain of the first channel
global.int_gain1:=ii; // integer coding for this gain
global.gain2:=1; // gain of the second channel
global.int_gain2:=ii; //
global.gain3:=1; // gain of the second channel
global.int_gain3:=1; //
global.clamp_int := ii; // integer that code for 1:IC, 2: VC
global.cont_choice := True; // if True -> continus mode, else episode
global.stim := False;  // if True acquisition.Fstimulate := True
global.main_protocol:='';
global.protocol:='';
global.saving := False ;
global.Rs := 0;
global.Rm := 0;
global.Cm :=0;
global.episode_duration := 100 ;
global.max_EP_num :=0 ;
global.acquisitionISI:=0.1 ; 
global.FadvanceON := False ;
Exp_Params.create;
already_initiated :=True;
InsertPage(1,'fake');DeleteAllPages('fake');InsertPage(1,'default');DeleteAllPages('default');
Color := cl_gray ;
end;

program Launch_from_file
global_init ;
SetProtocolNames;
init_windows;
Init_Main_Dialog;


program Launch_from_main
SetProtocolNames;
init_windows;
Init_Main_Dialog;

program set_output_to_zero
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;    

