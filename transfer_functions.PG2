{$EDIT TF_START}
{========================================================================
------- Master file for the transfer functions experiments ---------
========================================================================}

Const
   ProtocolCount    = 9 ; 
   CONTINUOUS_TIMER = 0.5 ; {timer for Tdetect update}
   LOCATION = 'Setup';


var
   MainDialog, dialSetupog, StimDialog : Tdialog ;{ two dialogs for buttons and protocols}
   stim, SAVING : boolean ; protocol_choice:integer; comments:string;
   ProtocolName:array[1..protocolCount] of string; ProtoNames, ProtoNum:string;
   DB:Tdbrecord ;  {for metadata information, storing comments, ... }
   Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; {variables to fetch the date and time }
   gain1,gain2 : real; gain1_int,gain2_int,clamp_int:integer;cont_choice:boolean;  
   dll_load : string ;
   detector, time_detector : Tdetector ;
   Rm, Cm, Bridge, El, Holding, f_acq : real ; // parameters of the patch recording !

{ ============================================================================
 ---- Protocol names and graphical settings ----------------------------------
 ============================================================================= }
                                             
 
procedure SetProtocolNames;
var          
  i:integer;                           
begin
  ProtocolName[1]:= 'Balanced_Ge-Gi_Shotnoise';
  ProtocolName[2]:= 'Massive_Transfer_Function';
  ProtocolName[3]:= 'Input Conductance Effect'; 
  ProtocolName[4]:= 'Autocorrelation Time Impact'; 
  ProtocolName[5]:= 'Tv and Gtot Comod. Effect'; 
  ProtocolName[6]:= 'muV relationship'; 
  ProtocolName[7]:= 'sV relationship'; 
  ProtocolName[8]:= 'Massive : muV-sV-Tv-muG'; 
  ProtocolName[9]:= 'Input_by_self_Spikes'; 
  ProtoNames:=ProtocolName[1];ProtoNum :='0|1';
  for i:=2 to ProtocolCount do 
  begin ProtoNames:=ProtoNames+'|'+ProtocolName[i];
  ProtoNum:=ProtoNum+'|'+Istr(i); end;
end;    


procedure init_windows;
begin
  deleteallpages('default');
  InsertPage(1,'transfer_functions');
  Definewindow(1, 0, 0, PageWidth, Round(PageHeight/3.));
  Definewindow(1, 0, Round(PageHeight/3), PageWidth, Round(PageHeight*2/3));
  Definewindow(1, 0, Round(PageHeight*2/3), PageWidth, PageHeight);
  DivideWindow(1,3,1,2); // for ge and gi
  Page:=1; color:=cl_gray;
end;


{$EDIT Info_recording}
{ ============================================================================
 ---- File saving and Comments+Information storing ---------------------------
this is stored in a TDBrecord object attached to the .DAT file
 ============================================================================= }
 

procedure FillDBinfo(var DB: TDBrecord); {procedure to write the metadata !}
var jj:integer; st:string;
begin
  DB.clear; 
  DB.s:=''+CRLF;                                     
  DB.info_spec:='+ specific infos about the protocol :';  
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    DB.ImplicitValue[st]:=TDBrecord('PG0.global').ImplicitValue[st] ;
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    //DB.AddField(st,jj+1);
    DB.ImplicitValue[st]:=TDBrecord('PG0.Exp_params').ImplicitValue[st] ;
  end;                                                                      
  //DB.protocol:=ProtocolName[protocol_choice];
  //DB.Comments := comments ; {comments is a global variable }
  //DB.Day := Day ; DB.Month := Month ; DB.Year := Year ;
  //DB.Hour := Hour ; DB.Minute := Minute ; DB.SEcond := Second ;    
end;

procedure save_metadata_as_txt;
var jj:integer; st, st2:string;
begin
   openText(1,acquisition.genericFilename+'.json',false);
   writelnText(1,'{');
  for jj:=1 to TDBrecord('PG0.global').count do
  begin  
    st:= TDBrecord('PG0.global').Names[jj] ;
    st2:=TDBrecord('PG0.global').Valstring[jj] ;
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;                                                                      
  for jj:=1 to TDBrecord('PG0.Exp_params').count do
  begin  
    st:= TDBrecord('PG0.Exp_params').Names[jj] ;
    st2:=TDBrecord('PG0.Exp_params').Valstring[jj];
    writelnText(1,'"'+st+'":"'+st2+'",');
  end;        
  for jj:=1 to ChannelCount do WriteLnText(1, '"DY'+Istr(jj)+'" : "'+Rstr(v[jj].dY)+'",');
  writelnText(1,'"lastline":"no_value"');
  writelnText(1,'}');
  closeText(1);                                                              
end;

procedure my_initprocess0;
var Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint; PathOfTheDay, sep, protocol  : string ; {variables to fetch the date and time }
begin
  PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ;
  protocol := TDBrecord('PG0.Exp_params').exp_type ;
  DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
  acquisition.genericfilename := PathOfTheDay+Istr(Hour)+'_'+Istr(Minute)+'_'+Istr(Second)+  '_'+protocol ;
  FillDBinfo(DB); 
  if acquisition.saving then  acquisition.writeDBfileinfo(DB);
end;

{$EDIT channels_settings} 
{ Acquisition + Stimulation + Gain settings }


{ ==============================================================================
--------- Setting the Acquisition channels -------------------------------------
================================================================================ }



procedure Set_DC_Channels_DEMO;
var 
   i : integer; f_acq:real;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 4; // vm, Iinj, ge, gi

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);

   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }
 
   RTneuron.FadvanceON:=True; { in dynamic clamp -> NEURON calculus }  
   RTneuron.execute('create soma');
   RTneuron.execute('insert pas');
   RTneuron.execute('e_pas = -65');
   RTneuron.execute('L=diam=79.8');
   RTneuron.Execute('g_pas = 5e-5');
   RTneuron.execute('insert WangBuszaki');
   
   RTneuron.Execute('objref stim');
   RTneuron.Execute('soma stim = new ExpSyn_eiNtwk(.5)');
   for i:=1 to 6 do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   acquisition.Channels[1].unitY:='mV'; addObject(1,1,v1); v1.title:='V_intra(t)';
   acquisition.Channels[1].NrnSymbolName:='soma.v(.5)';
   acquisition.Channels[2].unitY:='nA'; addObject(1,2,v2); v1.title:='Iinj(t)';
   acquisition.Channels[2].NrnSymbolName:='stim.i';
   acquisition.Channels[3].unitY:='uS'; addObject(1,3,v3);  v3.title:='Ge(t)';
   acquisition.Channels[3].NrnSymbolName:='stim.ge';
   acquisition.Channels[4].unitY:='uS'; addObject(1,4,v4); v4.title:='Gi(t)';
	 acquisition.Channels[4].NrnSymbolName:='stim.gi';
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ; v4.cpx:=1 ; v5.cpx:=1 ;
   v1.cpy:=1 ; v2.cpy := 2 ; v3.cpy:=3 ;  v4.cpy:=4 ; {we set the coupling value -> to couple to future analysis} 
   v2.color := CL_Olive ; v3.color := CL_Blue ; v4.color := CL_Red ; 
end;

procedure Set_DC_channels;
var 
   gain1, gain2, epdur, f_acq, acquisitionISI :real;
   Continu, stim :boolean;
   Clamp_int, max_ep_num, i :integer;
begin {-- we set all the variables of the acquisition class, then we create 
      the NEURON variables and link it to the analogous variables
       -- the NEURON files are loaded thanks to main dialog buttons}

   acquisition.ChannelCount := 6; // for the whole classic_electrophy protocols

   {we delete previous graphical display}
   ClearObjects(1,1); ClearObjects(1,2);
   
   acquisition.Fcontinuous:=true;
   acquisition.Fstimulate := False ; {we DON'T stimulate in Elphy!!}
   gain1 := TDBrecord('PG0.global').gain1 ;
   gain2 := TDBrecord('PG0.global').gain2 ;
   f_acq := TDBrecord('PG0.global').f_acq ;
   acquisition.PeriodPerChannel:=1./f_acq ; { in ms }

   RTneuron.Execute('create soma');
   RTneuron.Execute('objref stim');
   RTneuron.Execute('soma stim = new ExpSyn_eiNtwk(.5)');
   
   for i:=1 to 6 do 
   begin 
     acquisition.Channels[i].ChannelType := TI_Neuron;
     acquisition.Channels[i].DownSamplingFactor:=1;
   end;
   // FILTERED MEMBRANE POTENTIAL (EXITS FROM SCOPE !!!)
   RTneuron.AdcChan[1].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[1].NrnSymbolName:='soma.v(.5)';    // primary points on v
   // HIGH FREQUENCY MEMBRANE POTENTIAL
   RTneuron.AdcChan[0].setScale(0,32767,0,1000.0/gain1); RTneuron.AdcChan[0].NrnSymbolName:='v_hf';
   
   RTneuron.AdcChan[2].setScale(0,32767,0,20000.0/gain2); RTneuron.AdcChan[2].NrnSymbolName:='Iinj'; // secondary comes from analogous
   RTneuron.DacChan[0].NrnSymbolName:='stim.i'; RTneuron.DacChan[0].setScale(0,32767,0,-4.0); {command -> I clamp, stim.i in nA !!! and opposite sign !!!}
   
   acquisition.Channels[1].NrnSymbolName:='v_hf'; acquisition.Channels[1].unitY:='mV' ;
   acquisition.Channels[2].NrnSymbolName:='Iinj'; acquisition.Channels[2].unitY:='pA' ;
   acquisition.Channels[1].unitY:='mV'; addObject(1,1,v1); v1.title:='V_intra(t)';
   // For real data, 2-> real current, 5 -> theoretical current
   acquisition.Channels[5].unitY:='nA'; addObject(1,2,v5); v5.title:='Ith(t)';
   acquisition.Channels[5].NrnSymbolName:='stim.i';
   acquisition.Channels[3].unitY:='uS'; addObject(1,3,v3);  v3.title:='Ge(t)';
   acquisition.Channels[3].NrnSymbolName:='stim.ge';
   acquisition.Channels[4].unitY:='uS'; addObject(1,4,v4); v4.title:='Gi(t)';
	 acquisition.Channels[4].NrnSymbolName:='stim.gi';
   v1.cpx:=1 ; v2.cpx:=1 ; v3.cpx:=1 ;v4.cpx:=1 ; v5.cpx:=1 ;
   v1.cpy:=1 ; v2.cpy := 2 ; v3.cpy:=3 ;  v4.cpy:=4 ; {we set the coupling value -> to couple to future analysis} 
end;

{ =========================================================================
------------------- GAIN settings ----------------------------------------
===========================================================================  }

procedure SetGain1;
var Gain1_int:integer;
begin

    gain1_int:=TDBrecord('PG0.global').Gain1_int;
    case Gain1_int of
    1: TDBrecord('PG0.global').Gain1 := 1.0; 2: TDBrecord('PG0.global').Gain1 := 2.0;
    3: TDBrecord('PG0.global').Gain1 := 5.0; 4: TDBrecord('PG0.global').Gain1 := 10.0;
    5: TDBrecord('PG0.global').Gain1 := 20.0; 6: TDBrecord('PG0.global').Gain1 := 50.0;
    7: TDBrecord('PG0.global').Gain1 := 100.0; 8: TDBrecord('PG0.global').Gain1 := 200.0;
    9: TDBrecord('PG0.global').Gain1 := 500.0; 10: TDBrecord('PG0.global').Gain1 := 1000.0;
    11: TDBrecord('PG0.global').Gain1 := 2000.0;
    end;
end;   {SetGain1}

procedure SetGain2;
var Gain2_int:integer;
begin
    gain2_int:=TDBrecord('PG0.global').Gain2_int;
    case Gain2_int of
    1: TDBrecord('PG0.global').Gain2 := 1.0;   2: TDBrecord('PG0.global').Gain2 := 2.0; 
    3: TDBrecord('PG0.global').Gain2 := 5.0;  4: TDBrecord('PG0.global').Gain2 := 10.0;
    5: TDBrecord('PG0.global').Gain2 := 20.0;   6: TDBrecord('PG0.global').Gain2 := 50.0; 
    7: TDBrecord('PG0.global').Gain2 := 100.0;
    end;
end;   {SetGain2}


procedure InitializeChannels;
var amplifier : string ;
begin
         amplifier := TDBrecord('PG0.global').amplifier ;
         if amplifier='nrn_simulation' then Set_DC_channels_DEMO;
         if amplifier='multiclamp' then Set_DC_channels;
         time_detector.create ; detector.create ;   // needs to be created
end;


procedure set_dac_to_zero;
begin
RTneuron.execute('stim.stop_flag=1'); {trying to use the stop flag !!!}
RTneuron.execute('fadvance()');
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
Rtneuron.DacChan[1].HoldingValue:=0;
Rtneuron.DacChan[1].UseHoldingValue:=True;  
with stimulator do
  begin
    stimulator.setValue(0,0,0,0);   
    stimulator.setValue(0,0,1,0);   
    stimulator.setValue(0,1,0,0);  
end; 
end;


ProcessCont  // COMMON to all continuous processes
begin
time_detector.update(v1.Iend);
detector.update(v1.Iend);
end;

{$EDIT balanced_shotnoise_exp} 
{ ==============================================================================
----- Response to a shotnoise of excitatory and inhibitory conductance ---------
================================================================================ }


var
   TFdialog : Tdialog;
   spiketimes : Tvector ;
   stop_flag : boolean ;
   max_spikes_number : integer ;

{ *** Balanced Conductance Shotnoise Stim *** }
var
   freq_ge, freq_gi, qe, qi, Te, Ti, Ee, Ei	: real; { excitatory time constant}
   Nexc, Ninh	: integer;   SEED : integer;  vsum : Tvector; ind : integer ;

procedure initTFparameters;
begin
   freq_ge :=1.6; freq_gi :=4; Nexc := 2000; Ninh := 500;
   qe:=0.6;  { nS }  
   Te:=5; {ms}
   qi:= 1.1;  { uS }  Ti:=5; {ms}
   Ee:= 0; Ei:= -80; SEED :=1 ;
   max_spikes_number :=20;
end;

procedure write_shotnoise_params;
begin
    TDBrecord('PG0.Exp_params').Te:=Te ; 
    TDBrecord('PG0.Exp_params').Ee:=Ee ; TDBrecord('PG0.Exp_params').Qe:=Qe ;
    TDBrecord('PG0.Exp_params').f_exc:=freq_ge ; TDBrecord('PG0.Exp_params').seed_exc:=SEED ;
    TDBrecord('PG0.Exp_params').Ti:=Ti ; 
    TDBrecord('PG0.Exp_params').Ei:=Ei ; TDBrecord('PG0.Exp_params').Qi:=Qi ;
    TDBrecord('PG0.Exp_params').f_inh:=freq_gi ; TDBrecord('PG0.Exp_params').seed_inh:=SEED+1 ;
end;

procedure At_threshold_event(n:integer);
begin
    Statuslinetxt('Spike Number at t: '+Istr(spiketimes.Iend));
    if n>max_spikes_number then begin acquisition.stop ; end;
end; 

procedure tf_InitProcess; {executer avec acquisition.start, mais apres tout, ici tous les objets ont ete initialises, donc on peut les utiliser}
var 
threshold : real ;refrac : real ; yinit : real;
begin
   spiketimes.create(t_single,0,-1);
   threshold := -30.0 ; // threshold at : ... mV 
   refrac := 0.003 ; // at least ... s between two events
   yinit := -80.0 ;
   detector.create;
   detector.InitCrossings(v1,spiketimes,TRUE,FALSE,threshold,threshold,refrac,yinit,FALSE);
   detector.addevent(At_threshold_event,0);
end;


procedure tf_EndProcess; 
begin // we set the stimulation variable in NEURON to 0 !
   detector.Update(v1.Iend);
   set_dac_to_zero;
end;


procedure InitGeGi_exp(f_exc, f_inh:real; SEED:integer);
begin
   // Elphy Params initialization
   InitializeChannels;
   RTneuron.FadvanceON:=True;
   TDBrecord('PG0.Exp_params').exp_type := 'tf_balanced_shotnoise' ;
   write_shotnoise_params;
   acquisition.InstallProcess(my_initProcess0, tf_initprocess, nil, tf_endprocess);

   // NEURON initialization 
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   
   // parameters of the synapses
   RTneuron.execute('stim.tauE = '+Rstr(Te));
   RTneuron.execute('stim.tauI = '+Rstr(Ti));
   RTneuron.execute('stim.Ee = '+Rstr(Ee)); RTneuron.execute('stim.Ei = '+Rstr(Ei));
   
   // configuring the excitatory presynaptic events
   RTneuron.execute('nsE = new NetStim(.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); RTneuron.execute('nsE.seed('+Rstr(SEED)+')');
   if f_exc*Nexc<>0 then RTneuron.execute('nsE.interval = 1000/'+Rstr(f_exc*Nexc)) else RTneuron.execute('nsE.interval = 1e30');
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.weight = 0.001*'+Rstr(Qe));
   // configuring the inhibitory presynaptic events
   RTneuron.execute('nsI = new NetStim(.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1'); RTneuron.execute('nsI.seed('+Rstr(SEED+1)+')');
   if f_inh*Ninh<>0 then RTneuron.execute('nsI.interval = 1000/'+Rstr(f_inh*Ninh)) else RTneuron.execute('nsI.interval = 1e30');
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.weight = -0.001*'+Rstr(Qi));
   
   RTneuron.execute('finitialize()');
end;


{ ==============================================================================
--------- BUILDING THE Experiment DIALOG  --------------------------------------------
================================================================================ }


procedure TFdialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : InitGeGi_exp(freq_ge,freq_gi,SEED);
     end; 
     TFdialog.update;
end;  

procedure InitTFdialog;
begin
   initTFparameters;
   with TFdialog do
   begin
      create;
      OnEvent:=TFdialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText(' |  __---   Transfer Function Experiments   ---__  | ');
      setText('Conductance Shotnoise from a balanced Network');
      setText('______________________________________');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      setText('');
      getIntegerA('SEED (int)',SEED,6,200);
      setText('o==> EXCITATION');
      getIntegerA('Nexc (# exc synapses)',Nexc,6,200);
      getRealA('excitatory quantal (nS)',qe,10,2,200);
      getRealA('Tau_E (ms)',Te,10,2,200);
      getRealA('Ee (revers. pot.) (mV)',Ee,10,2,200);
      setText('o==> INHIBITION');
      getIntegerA('Ninh (# inh synapses)',Ninh,6,200);
      getRealA('inhibitory quantal (nS)',qi,10,2,200);
      getRealA('Tau_I (ms)',Ti,10,2,200);
      getRealA('Ei (revers. pot.) (mV)',Ei,10,2,200);
      setText('');
      setText(' === frequencies ===');
      getRealA('excitatory frequency (Hz)',freq_ge,10,3,200);
      getRealA('inhibitory frequency (Hz)',freq_gi,10,3,200);
      getCommandA(' Initialize() ',0,201); { OnEvent flag -> 201 }
   end;
   TFdialog.show;
end;


{$EDIT massive_TF_scan} 
{ ==============================================================================
---- Doing a massive frequency scan to determine the final transfer function ---
================================================================================ }

var vec_fe_full,vec_fi_full : Tvector ;
var global_step : integer ;  continu_flag : boolean ;
var fe_min0,fe_max0,fe_min1,fe_max1,fi_min,fi_max, t0_trial, t0_full, max_authorized_time :real;
var grid_seed : integer ; 
var recorded_fe,recorded_fi,recorded_t,recorded_fout : Tvector ;
var rest_flag,jump_to_next:boolean ; // flag pour alterner de la stimulation et des periods de repos...

procedure init_massivetf_const;
begin                      
   vec_fe_full.create(t_single,0,-1); vec_fi_full.create(t_single,0,-1);
   fe_min0 := 0.1 ; fe_max0 := 10; fe_min1 := 5 ; fe_max1 := 20;
   fi_min := 0.1 ; fi_max := 15;  jump_to_next:=False ;
   max_authorized_time := 3 ; // in s
   recorded_fe.create(t_single,0,-1);
   recorded_fi.create(t_single,0,-1);
   recorded_t.create(t_single,0,-1);
   TDBrecord('PG0.Exp_params').exp_type := 'tf_massive_TF' ;
end;


procedure Shuffle_Vector(var vec:Tvector);
var ii,i1,i2:integer; temp:real;
begin
    for ii:=0 to 10*vec.Iend do 
    begin
        i1:= Random(vec.Iend); i2:= Random(vec.Iend);
        temp:= vec[i1]; vec[i1]:=vec[i2]; vec[i2]:=temp;
    end;
end;

procedure gen_grid_frequency; // a bit complicated, but we want to increase the precision when the index (~time) raises
var vec_i1,vec_fe1,vec_fi1 : Tvector;
var vec_i2,vec_fe2,vec_fi2 : Tvector;
var vec_i3,vec_fe3,vec_fi3 : Tvector;
var vec_i4,vec_fe4,vec_fi4 : Tvector;
var fe0,dfe : Tvector ; n_grid : integer ;
var flag:Boolean; ee,ii:integer ; dfi : real ;
begin
    dfi := (fi_max-fi_min)/16 ;  
    dfe.create(t_single,0,16);  fe0.create(t_single,0,16); 
    for ii:=0 to 16 do dfe[ii]:=(fe_max0-fe_min0)/16 + ii*((fe_max1-fe_min1)/16-(fe_max0-fe_min0)/16)/16; 
    for ii:=0 to 16 do fe0[ii]:=fe_min0+ii/16*(fe_min1-fe_min0);
    vec_i1.create(t_smallint,0,8); 
    for ii:=0 to vec_i1.Iend do vec_i1[ii]:=ii;
    vec_fe1.create(t_smallint,0,-1);vec_fi1.create(t_single,0,-1);
    vec_i2.create(t_smallint,0,25-9-1);
    for ii:=0 to vec_i2.Iend do vec_i2[ii]:=ii;
    vec_fe2.create(t_single,0,-1);vec_fi2.create(t_single,0,-1);
    vec_i3.create(t_smallint,0,81-25-1);
    for ii:=0 to vec_i3.Iend do vec_i3[ii]:=ii;
    vec_fe3.create(t_single,0,-1);vec_fi3.create(t_single,0,-1);
    vec_i4.create(t_smallint,0,289-81-1);
    for ii:=0 to vec_i4.Iend do vec_i4[ii]:=ii;
    vec_fe4.create(t_single,0,-1);vec_fi4.create(t_single,0,-1);
    n_grid:=16 ;          
    for ee:=0 to n_grid do begin
      for ii:=0 to n_grid do begin 
        flag := True;              
        if ( ee Mod 8 = 0 ) then begin 
            if ( ii mod 8 = 0 ) then begin 
                vec_fe1.addToList(fe0[ii]+ee*dfe[ii]);
                vec_fi1.addToList(fi_min+dfi*ii);
                flag := False ; end; end ;   
        if (ee mod 4 = 0) and flag then begin
            if ( ii mod 4 = 0) then begin
                vec_fe2.addToList(fe0[ii]+ee*dfe[ii]);
                vec_fi2.addToList(fi_min+dfi*ii);
                flag := False ; end ; end ; 
        if (ee mod 2 = 0) and flag then begin 
            if (ii mod 2 = 0) then begin 
                vec_fe3.addToList(fe0[ii]+ee*dfe[ii]);
                vec_fi3.addToList(fi_min+dfi*ii);
                flag := False ;  end; end;  
        if (ee mod 1 = 0) and flag then begin 
            if (ii mod 1 = 0) then begin 
                vec_fe4.addToList(fe0[ii]+ee*dfe[ii]);
                vec_fi4.addToList(fi_min+dfi*ii);
                flag := False ; end ; end;    
      end;
   end;       
   Shuffle_Vector(vec_i1);
   for ii:=0 to vec_i1.Iend do 
   begin 
   ee := Round(vec_i1[ii]) ; 
   vec_fe_full.AddToList(vec_fe1[ee]);vec_fi_full.AddToList(vec_fi1[ee]);
   end;    
   Shuffle_Vector(vec_i2);
   for ii:=0 to vec_i2.Iend do 
   begin 
   ee := Round(vec_i2[ii]) ; 
   vec_fe_full.AddToList(vec_fe2[ee]);vec_fi_full.AddToList(vec_fi2[ee]);
   end;       
   Shuffle_Vector(vec_i3);
   for ii:=0 to vec_i3.Iend do 
   begin 
   ee := Round(vec_i3[ii]) ; 
   vec_fe_full.AddToList(vec_fe3[ee]);vec_fi_full.AddToList(vec_fi3[ee]);
   end;              
   Shuffle_Vector(vec_i4);     
   for ii:=0 to vec_i4.Iend do 
   begin 
   ee := Round(vec_i4[ii]) ; 
   vec_fe_full.AddToList(vec_fe4[ee]);vec_fi_full.AddToList(vec_fi4[ee]);
   end;                              
end;


procedure Init_single_exp(f_exc, f_inh:real; SEED:integer);
var fe_tot, fi_tot :  real;
begin         
   // writing the parameters to the ExpParams dict
   write_shotnoise_params;
   // configuring the excitatory presynaptic events
   RTneuron.execute('nsE.seed('+Rstr(SEED)+')');
   fe_tot := f_exc*Nexc; 
   if fe_tot<>0 then RTneuron.execute('nsE.interval = 1000/'+Rstr(fe_tot)) else RTneuron.execute('nsE.interval = 1e30');
   // configuring the inhibitory presynaptic events
   RTneuron.execute('nsI.seed('+Rstr(SEED*SEED+1)+')');
   fi_tot := f_inh*Ninh;
   if fi_tot<>0 then RTneuron.execute('nsI.interval = 1000/'+Rstr(fi_tot)) else RTneuron.execute('nsI.interval = 1e30');
   RTneuron.execute('finitialize()');
end;


procedure massive_nrn_init;
begin
   // NEURON initialization, need to initialize it only once...      
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim(.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.weight = 0.001*'+Rstr(Qe));
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('soma nsI = new NetStim(.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');                        
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.weight = -0.001*'+Rstr(Qi));
   RTneuron.execute('ncI.delay = 0');
   // parameters of the synapses
   RTneuron.execute('stim.tauE = '+Rstr(Te)); RTneuron.execute('stim.tauI = '+Rstr(Ti));
   RTneuron.execute('stim.Ee = '+Rstr(Ee)); RTneuron.execute('stim.Ei = '+Rstr(Ei));
   // then
   continu_flag :=True ;
end;


// ===================== Process functions ================== //


procedure check_for_stop_acq(n:integer);
begin
    if not continu_flag then acquisition.stop;
    if n>Round(max_authorized_time/CONTINUOUS_TIMER) then acquisition.stop ; // if bigger than 20s, we stop !
    if rest_flag and (n>1) then acquisition.stop ; // if REST then only one second of exp
    
end;

procedure massive_InitProcess; {executer avec acquisition.start, mais apres tout, ici tous les objets ont ete initialises, donc on peut les utiliser}
var 
threshold : real ;refrac : real ; yinit : real;
begin
   spiketimes.create(t_single,0,-1);
   threshold := -30.0 ; // threshold at : ... mV 
   refrac := 0.003 ; // at least ... s between two events
   yinit := -80.0 ;
   detector.create; // this one is foe the spikes
   detector.InitCrossings(v1,spiketimes,TRUE,FALSE,threshold,threshold,refrac,yinit,FALSE);
   detector.addevent(At_threshold_event,0);
   time_detector.create;
   time_detector.InitTimer(v1, CONTINUOUS_TIMER);
   time_detector.AddEvent(check_for_stop_acq, 0.);
end;



procedure write_freq_time_infos_as_txt;
var st : string; i : integer;
begin
   openText(1,acquisition.genericfilename+'_GRID.txt',false);
   for i:=recorded_fe.Istart to recorded_fe.Iend do
   begin
       st := Rstr(recorded_t[i], 1, 6)+Chr(9)+Rstr(recorded_fe[i], 1, 6)+Chr(9)+Rstr(recorded_fi[i], 1, 6);
       writelnText(1,st);   // the time is actually the end of the experiment !!
   end; 
   closeText(1);
end;


procedure massive_EndProcess; 
begin 
    set_dac_to_zero; // we set the stimulation variable in NEURON to 0 !
    if continu_flag=False then rest_flag:=False; // to be sure to cancel the stimulation
    if rest_flag and (global_step<vec_fe_full.Iend-1) then  // we are not in pause so we progress in the scan..
    begin 
      global_step := global_step+1 ;   
      freq_ge := vec_fe_full[global_step] ; freq_gi := vec_fi_full[global_step] ;
      rest_flag:=False;
    end
    else                              
    begin 
      freq_ge := 0 ; freq_gi := 0 ;
      Init_single_exp(freq_ge,freq_gi,SEED);
      rest_flag:=True;
    end;
    // then we reinit everything
    Init_single_exp(freq_ge,freq_gi,SEED+global_step); {not to have the same seed everytime !}
    acquisition.InstallProcess(nil, massive_initprocess, nil, massive_endprocess);
    recorded_fe.addtolist(freq_ge);recorded_fe.SaveAsObject(acquisition.genericfilename+'_fe') ;
    recorded_fi.addtolist(freq_gi);recorded_fi.SaveAsObject(acquisition.genericfilename+'_fi') ;
    recorded_t.addtolist(v1.Xend);recorded_t.SaveAsObject(acquisition.genericfilename+'_t') ;
    RTneuron.FadvanceON:=True;
 
    t0_trial := v1.Xend ;     // t0 setting
    TFdialog.update;TFdialog.updatevar;    
    if continu_flag then acquisition.startandsave(true) // we restart
    else begin save_metadata_as_txt; write_freq_time_infos_as_txt; end; // we write the txt file !
end;


procedure Run_MassiveTF;
begin 
   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time} 
   continu_flag := True ;
   freq_ge := vec_fe_full[global_step] ; freq_gi := vec_fi_full[global_step] ;
   Init_single_exp(freq_ge,freq_gi,SEED);
   // Elphy Params initialization
   acquisition.InstallProcess(my_initProcess0, massive_initprocess, nil, massive_endprocess); // initprocess0 for the first exp

   write_shotnoise_params; // writing parameters
   recorded_fe.create(t_single,0,-1);   recorded_fe.addtolist(freq_ge);
   recorded_fi.create(t_single,0,-1);   recorded_fi.addtolist(freq_gi);
   recorded_t.create(t_single,0,-1);   recorded_t.addtolist(0);
   acquisition.startandsave;
end;


procedure MassiveDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_MassiveTF;
     301 : begin SetRandSeed(grid_seed); gen_grid_frequency; InitializeChannels; massive_nrn_init;end;
     end;
     TFdialog.update;
end;  

procedure InitMassivedialog;
begin
   init_massivetf_const;
   with TFdialog do
   begin
      create;
      OnEvent:=MassiveDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText(' |  __---   Transfer Function Experiments   ---__  | ');
      setText('Conductance Shotnoise from a balanced Network');
      setText('______________________________________');
      getIntegerA('SEED (int)',grid_SEED,6,200);
      setText('o==> EXCITATION');
      getRealA(' fe_min (fi=fi_min)',fe_min0,10,3,200);
      getRealA(' fe_max (fi=fi_min)',fe_max0,10,3,200);
      getRealA(' fe_min (fi=fi_max)',fe_min1,10,3,200);
      getRealA(' fe_max (fi=fi_max)',fe_max1,10,3,200);
      setText('o==> INHIBITION');
      getRealA(' fi_min ',fi_min,10,3,200);
      getRealA(' fi_max ',fi_max,10,3,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run massive TF ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      getRealA(' current fe',freq_ge,10,3,200);
      getRealA(' current fi',freq_gi,10,3,200);
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Massive-TF';
      Show;
   end;
end;


{$EDIT Calculating parameters} 
{ ==============================================================================
---- WE WILL NEED THIS FUNCTION FOR ALL THE REMAINING PROTOCOLS
================================================================================ }

procedure params_variations_calc(muG, muV, sV, Ts, Ee, Ei, Rm, Cm, El : real ; var fe, fi, Q, Tv : real);
var Gl, A, B, num, denom, Tv2: real;
begin {function to change  fe, fi, Q, Ts}
   Gl := 1000/Rm; {1000/Mohm = nS}
   Tv:= Ts+Cm/muG ; {ms + pF/nS = ms}
   A:= (muG*muV-Gl*El)/(muG-Gl) ; {mV*nS / nS = mV}
   B:= (Ee-A)/(A-Ei) ; { mV/mV = [] }
   num:= ( (Ee-muV)*(Ee-muV) + B*(Ei-muV)*(Ei-muV) ) * (muG-Gl)*(muG-Gl) ; {mV**2 * nS**2}
   denom:= (1+B)*(1+B) * 2. * muG*muG * Tv * sV*sV ; {mV**2 * nS**2 * ms}
   if denom<=0 then MessageBox('muG, muV, sV, Ts'+Rstr(muG)+'  '+Rstr(muV)+'  '+Rstr(sV)+'  '+Rstr(Ts));
   fe:= num/denom ; { 1/ms = kHz}
   fi:= B*fe ; { 1/ms = kHz}
   Q:= (muG-Gl)/Ts/(fe+fi) ; {nS /ms /kHz = nS}

   {the the frequencies back to hertz !!}
   fe:= fe*1000; fi := fi*1000;
end;

{ we re-use some of the variables of the massive_TF_scan protocol : }
var vec_q, vec_fe, vec_fi, vec_Ts, vec_Tv, vec_muG, vec_muV, vec_sV : Tvector ; {the weights will have to be changed to maintain the pot and fluctuations fixed !}
var ratio_qi_qe, ratio_Ti_Te : real; {comodulation factor for the total conductance effect (G Total Effect, GTE)}
var Q, Ts, Tv, muG, muV, sV, shift_mean, clamp_mean, clamp_std, clamp_Tv, clamp_gtotN, clamp_Ts    : real ;
{you have the possibility to shift the mean of a shift produced by a constant current input (this allows to have lower weights) }
var recorded_index, recorded_Q,recorded_Tv,recorded_Ts, recorded_muG, recorded_muV, recorded_sV : Tvector ; {the one for fe and fi were created above !}
var point_number, REPETITION : integer; vec_i : Tvector ; 

{Then protocol specific variables}
var max_conductance_factor : real; {until how much gleak do we increase the conductance ?}
var DISCRET_SV, DISCRET_MV, DISCRET_MUG, DISCRET_TS : integer;
var min_sV, max_sV, min_muV, max_muV, min_muGn, max_muGn, min_sV2, max_sV2, min_Ts, max_Ts : real;


procedure write_fluct_Exp_params; {to be used by all subsequent protocols}
begin
    TDBrecord('PG0.Exp_params').Ee:=Ee ; 
    TDBrecord('PG0.Exp_params').seed_exc:=SEED ;
    TDBrecord('PG0.Exp_params').Ei:=Ei ; 
    TDBrecord('PG0.Exp_params').seed_inh:=SEED*SEED+1 ;
    TDBrecord('PG0.Exp_params').clamp_mean := clamp_mean;
    TDBrecord('PG0.Exp_params').clamp_std := clamp_std ;
    TDBrecord('PG0.Exp_params').clamp_Tv := clamp_Tv;
    TDBrecord('PG0.Exp_params').clamp_Ts := clamp_Ts;
    TDBrecord('PG0.Exp_params').clamp_gtotN := clamp_gtotN;
    TDBrecord('PG0.Exp_params').shift_mean_Vm := shift_mean ;
    TDBrecord('PG0.Exp_params').max_conductance_factor := max_conductance_factor;
    TDBrecord('PG0.Exp_params').ratio_qi_qe := ratio_qi_qe ;
    TDBrecord('PG0.Exp_params').ratio_Ti_Te := ratio_Ti_Te ;
    TDBrecord('PG0.Exp_params').point_number := point_number;
    TDBrecord('PG0.Exp_params').global_step_start := global_step;
    TDBrecord('PG0.Exp_params').REPETITION := REPETITION;
    TDBrecord('PG0.Exp_params').min_muV:=min_muV; 
    TDBrecord('PG0.Exp_params').max_muV:=max_muV; 
    TDBrecord('PG0.Exp_params').min_sV:=min_sV; 
    TDBrecord('PG0.Exp_params').max_sV:=max_sV; 
    TDBrecord('PG0.Exp_params').min_sV2:=min_sV2; 
    TDBrecord('PG0.Exp_params').max_sV2:=max_sV2; 
    TDBrecord('PG0.Exp_params').min_muGn:=min_muGn; 
    TDBrecord('PG0.Exp_params').max_muGn:=max_muGn; 
    TDBrecord('PG0.Exp_params').max_Ts:=max_Ts; 
    TDBrecord('PG0.Exp_params').DISCRET_SV := DISCRET_SV;
    TDBrecord('PG0.Exp_params').DISCRET_MV := DISCRET_MV;
    TDBrecord('PG0.Exp_params').DISCRET_MUG := DISCRET_MUG;
    TDBrecord('PG0.Exp_params').DISCRET_TS := DISCRET_TS;
end;

procedure basic_nrn_init;
begin
   // NEURON initialization, need to initialize it only once...      
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim(.5)');
   RTneuron.execute('nsE.start = 0'); RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('soma nsI = new NetStim(.5)');
   RTneuron.execute('nsI.start = 0'); RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');                        
   RTneuron.execute('ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.delay = 0');
   // then
   continu_flag :=True ;
end;

procedure Init_single_exp_fluct(f_exc, f_inh, Q, Ts : real; SEED:integer);
begin         
   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('nsE.seed('+Istr(SEED)+')');
   RTneuron.execute('nsI.seed('+Istr(SEED+1)+')');

   {synaptic weights}
   RTneuron.execute('ncE.weight = 0.001*'+Rstr(Q));
   RTneuron.execute('ncI.weight = -0.001*'+Rstr(Q*ratio_qi_qe)); {NEGATIVE FLAG !!!}
   
   {firing frequencies}
   if f_exc>0 then RTneuron.execute('nsE.interval = 1000/'+Rstr(f_exc)) else RTneuron.execute('nsE.interval = 1e30');
   if f_inh>0 then RTneuron.execute('nsI.interval = 1000/'+Rstr(f_inh)) else RTneuron.execute('nsI.interval = 1e30');

   {then synaptic times}
   RTneuron.execute('stim.tauE = '+Rstr(Ts));
   RTneuron.execute('stim.tauI = '+Rstr(Ts*ratio_Ti_Te));
   RTneuron.execute('finitialize()');
end;

procedure add_current_variables_to_vectors;
var ff : real;
begin
   recorded_fe.addtolist(freq_ge);   recorded_fi.addtolist(freq_gi);
   recorded_q.addtolist(Q);    recorded_ts.addtolist(Ts);
   recorded_sV.addtolist(sV);   recorded_muV.addtolist(muV);
   recorded_muG.addtolist(muG);  recorded_Tv.addtolist(Tv);
   ff:=spiketimes.Iend/(v1.Xend-recorded_t[recorded_t.Iend]);
   recorded_Fout.addtolist(ff);
   recorded_index.addtolist(vec_i[global_step]);
end;

procedure initialize_recording_vectors;
begin
   recorded_fe.create(t_single,0,-1); 
   recorded_fi.create(t_single,0,-1);
   recorded_Q.create(t_single,0,-1);
   recorded_ts.create(t_single,0,-1);   
   recorded_muV.create(t_single,0,-1); 
   recorded_sV.create(t_single,0,-1);
   recorded_muG.create(t_single,0,-1); 
   recorded_tv.create(t_single,0,-1);   
   recorded_t.create(t_single,0,-1);   
   recorded_Fout.create(t_single,0,-1);   
   recorded_index.create(t_single,0,-1);
   recorded_t.addtolist(0);
end;

procedure initialize_stimulation_vectors;
begin
   vec_fe.create(t_single,0,-1);  vec_fi.create(t_single,0,-1);
   vec_q.create(t_single,0,-1); vec_Ts.create(t_single,0,-1);
   vec_muG.create(t_single,0,-1); vec_muV.create(t_single,0,-1);
   vec_sV.create(t_single,0,-1); vec_Tv.create(t_single,0,-1);
end;

procedure write_massive_scan_infos_as_txt;
var st : string; i : integer;
begin
   openText(1,acquisition.genericfilename+'_GRID.txt',false);
   for i:=recorded_index.Istart to recorded_index.Iend do
   begin
       st := Rstr(recorded_index[i], 1, 6)
      +Chr(9)+Rstr(recorded_fe[i], 1, 6)+Chr(9)+Rstr(recorded_fi[i], 1, 6)
       +Chr(9)+Rstr(recorded_q[i], 1, 6)+Chr(9)+Rstr(recorded_Ts[i], 1, 6)
       +Chr(9)+Rstr(recorded_muV[i], 1, 6)+Chr(9)+Rstr(recorded_sV[i], 1, 6)
      +Chr(9)+Rstr(recorded_muG[i], 1, 6)+Chr(9)+Rstr(recorded_Tv[i], 1, 6)
      +Chr(9)+Rstr(recorded_Fout[i], 1, 6);
       writelnText(1,st);   
   end;
   closeText(1);
   openText(1,acquisition.genericfilename+'_t.txt',false);
   for i:=recorded_t.Istart to recorded_t.Iend do
   begin
       st := Rstr(recorded_t[i], 1, 6);
       writelnText(1,st);   
   end; {the times are longer so we just finish it}
   closeText(1);
end;

procedure put_the_values_into_stimulation_vectors(g_tot, muV,shift_mean, sV, Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv :real );
begin
   vec_muV.addtolist(muV);
   vec_sV.addtolist(sV);
   vec_Tv.addtolist(Ts+Cm/g_tot);
   vec_muG.addtolist(g_tot);
   vec_Q.addtolist(Q);
   vec_fe.addtolist(FE);
   vec_fi.addtolist(FI);
   vec_Ts.addtolist(Ts);
end;

procedure create_and_shuffle_the_index_vector(n_tot, REPETITION:integer );
var it,is,ig : integer;
begin
   vec_i.create(t_smallint,0,n_tot*REPETITION-1); 
   for it:=0 to n_tot-1 do 
      begin
	 for is:=1 to REPETITION do 
	    begin
	       ig := it+(is-1)*n_tot;
	       vec_i[ig]:=it;
	    end;
      end;
   shuffle_vector(vec_i);  {SHUFFLED !!!!!}
end;

procedure refill_the_fluct_variables(ii:integer);
begin
       freq_ge := vec_fe[ii] ; freq_gi := vec_fi[ii] ;
       Q := vec_q[ii] ;  Ts := vec_ts[ii] ; 
       muV := vec_muV[ii] ; sV := vec_sV[ii] ;
       muG := vec_muG[ii] ; Tv := vec_Tv[ii] ;  
end;

procedure Massive_scan_EndProcess; 
var i_rdm :  integer;
begin
   set_dac_to_zero; // we set the stimulation variable in NEURON to 0 !

   if continu_flag=False then rest_flag:=False; { to be sure to cancel the stimulation }

   if (rest_flag=True) and (global_step<vec_i.Iend)  then  { we are not in pause so we progress in the scan.. }
    begin 
       global_step := global_step+1 ;   
       i_rdm:=Round(vec_i[global_step]); {RANDOMIZATION !!!}
       refill_the_fluct_variables(i_rdm);
       rest_flag:=False;
    end
    else                              
    begin 
       {recording the previous episode quantities}
       add_current_variables_to_vectors;
       {then recordings of the future episode quantities}
      freq_ge := 0 ; freq_gi := 0 ; 
      rest_flag:=True;
      if global_step>=vec_i.Iend then continu_flag:=False;
    end;

   {t has to be recorded everytime !}
   recorded_t.addtolist(v1.Xend);


    // then we reinit everything
    Init_single_exp_fluct(freq_ge, freq_gi, Q, Ts, SEED+global_step); {not to have the same seed everytime !}


    acquisition.InstallProcess(nil, massive_InitProcess, nil, massive_scan_endprocess);

    RTneuron.FadvanceON:=True;
 
    t0_trial := v1.Xend ;     // t0 setting
    TFdialog.update;TFdialog.updatevar;    
    if continu_flag then acquisition.startandsave(true) // we restart
    else begin save_metadata_as_txt; write_massive_scan_infos_as_txt; end; // we write the txt file !
end;

procedure Run_massive_scan;
var i_rdm :  integer;
begin 
   DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time} 
   continu_flag := True ; rest_flag:=False;

   i_rdm:=Round(vec_i[global_step]);   {RANDOMIZATION}
   refill_the_fluct_variables(i_rdm);

   Init_single_exp_fluct(freq_ge,freq_gi, Q, Ts, SEED+global_step);
   // Elphy Params initialization
   acquisition.InstallProcess(my_initProcess0, massive_InitProcess, nil, massive_scan_endprocess); // initprocess0 for the first exp

   write_fluct_Exp_params; // writing parameters
   initialize_recording_vectors;

   acquisition.startandsave;
end;



{$EDIT G_mean_effect_on_spiking} 
{ ==============================================================================
---- How much does the mean somatic conductance might have an influence on the firing freq ---
================================================================================ }


procedure init_gtot_effect_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_Gtot_effect_on_spiking' ;
   clamp_mean := -60; clamp_std := 4 ;
   clamp_Tv := 8 ; {ms}
   shift_mean :=0 ;
   max_conductance_factor := 12;
   point_number := 10 ;
   REPETITION := 1; {REPEATING FOR DIFFERENT SEEDS}
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
end;


procedure gen_GTE_input; 
var ii,jj : integer ; FE, FI, g_tot, dg_tot, mu_g1, mu_g0, Gl : real;
begin
   initialize_stimulation_vectors;

   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}

   mu_g0 := Gl*(1.-(El-shift_mean-clamp_mean)/(Ee-shift_mean-clamp_mean));  {minimumm conductance level to achieve the mean, nS}
   mu_g1 := Cm/(clamp_Tv-1);  {minimumm conductance to achieve autocorrelation for a 1ms minimum time constant, pF/ms = nS}
   if mu_g1<mu_g0 then begin clamp_Tv:=Cm/mu_g0+1; mu_g1:=mu_g0; MessageBox('Tv too high, changed to Tv = '+Rstr(clamp_Tv)+'ms'); end;

   dg_tot := (Gl*max_conductance_factor-mu_g1)/(point_number-1) ;  // nS

   {actually the expression gives weird results for some this stimulation paradigm, so we restrict the input range to 
   the stable parameter space, this is the procedure to perform this :}

   for ii:=0 to point_number-1 do 
   begin
      g_tot := mu_g1+ii*dg_tot ; {in nanoSiemens}
      params_variations_calc(g_tot, clamp_mean+shift_mean, clamp_std, clamp_Tv-Cm/g_tot, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
      put_the_values_into_stimulation_vectors(g_tot, clamp_mean,shift_mean, clamp_std, clamp_Tv-Cm/g_tot, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

    end;

   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure GTEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_GTE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitGTEdialog;
begin
   init_gtot_effect_const;
   with TFdialog do
   begin
      create;
      OnEvent:=GTEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_mean,10,3,200);
      getRealA(' clamping the std dev. (mV)',clamp_std,10,3,200);
      getRealA(' clamping the Tv (ms)',clamp_Tv,10,3,200);
      getRealA(' Max. Conductance factor (*Gl)',max_conductance_factor,10,3,200);
      getRealA(' shift resting pot. (mV) (NT WKG)',shift_mean,10,3,200);
      getRealA(' ratio of Qi/Qe (NT WKG)',ratio_qi_qe,10,3,200);
      getRealA(' ratio of Ti/Te (NT WKG)',ratio_ti_te,10,3,200);
      setText('______________________________________');
      getIntegerA('Number of points ',point_number,6,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Input Conductance Effect';
      Show;
   end;
end;


{$EDIT T_autocorrel_on_spiking} 
{ ==============================================================================
---- How much does the mean somatic conductance might have an influence on the firing freq ---
================================================================================ }

procedure init_Tv_effect_const;	
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_Tv_effect_on_spiking' ;
   clamp_mean := -60; clamp_std := 4 ;
   clamp_gtotN := 4; {factor of gtot/gl}
   shift_mean :=0 ;
   ratio_qi_qe := 1 ; 
   point_number := 10 ;
   min_Ts :=1;
   max_Ts := 10;
   REPETITION := 1; {REPEATING FOR DIFFERENT SEEDS}
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
end;


procedure gen_TVE_input; 
var ii : integer ; FE, FI, g_tot, Gl, Dts : real;
begin
   initialize_stimulation_vectors;
    
   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}
   g_tot := Gl*clamp_gtotN;

   dTs := (max_Ts-min_Ts)/(point_number-1) ;  {ms}

   for ii:=0 to point_number-1 do 
   begin
      Ts := min_Ts+ii*dTs ; {in ms}

      params_variations_calc(g_tot, clamp_mean+shift_mean, clamp_std, Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
      put_the_values_into_stimulation_vectors(g_tot, clamp_mean, shift_mean, clamp_std, Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure TvEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_TvE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitTvEdialog;
begin
   init_Tv_effect_const;	
   with TFdialog do
   begin
      create;
      OnEvent:=TvEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Effect of the temporal fluctuations time scale on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_mean,10,3,200);
      getRealA(' clamping the std dev. (mV)',clamp_std,10,3,200);
      getRealA(' clamping the Gtot/gL ratio',clamp_gtotN,10,3,200);
      getRealA(' ratio of Qi/Qe ==NT WKG',ratio_qi_qe,10,3,200);
      getRealA(' shift resting pot. (mV) ==NT WKG',shift_mean,10,3,200);
      setText('______________________________________');
      getRealA(' Minimum synaptic time (ms)',min_Ts,10,3,200);
      getRealA(' Maximum synaptic time (ms)',max_Ts,10,3,200);
      setText('______________________________________');
      getIntegerA('Number of points ',point_number,6,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Autocorrelation time Impact';
      Show;
   end;
end;

{$EDIT Gtot_and_Tv_effect_on_spiking} 
{ ==============================================================================
---- How much does the mean somatic conductance might have an influence on the firing freq ---
================================================================================ }

procedure init_GTVE_effect_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_Gtot_and_TV_effect_on_spiking' ;
   clamp_mean := -60; clamp_std := 4 ; clamp_Ts := 3 ; {ms}
   shift_mean :=0 ;
   max_conductance_factor := 12;
   REPETITION := 1; {REPEATING FOR DIFFERENT SEEDS}
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
   point_number := 10 ;
end;



procedure gen_GTVE_input; 
var ii : integer ; FE, FI, g_tot, dg_tot, mu_g1, mu_g0, Gl : real;
begin

   initialize_stimulation_vectors;
    
   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}

   mu_g0 := Gl*(1.-(El-shift_mean-clamp_mean)/(Ee-shift_mean-clamp_mean));  {minimumm conductance level to achieve the mean, nS}

   dg_tot := (Gl*max_conductance_factor-mu_g0)/(point_number-1) ;  // nS

   for ii:=0 to point_number-1 do 
   begin
      g_tot := mu_g0+ii*dg_tot ; {in nanoSiemens,  shuffled through vec_i}

      params_variations_calc(g_tot, clamp_mean+shift_mean, clamp_std, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

      put_the_values_into_stimulation_vectors(g_tot, clamp_mean, shift_mean, clamp_std, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure GTVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_GTVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitGTVEdialog;
begin
   init_GTVE_effect_const;
   with TFdialog do
   begin
      create;
      OnEvent:=GTVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Effect of both Gtot and Tv on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_mean,10,3,200);
      getRealA(' clamping the std dev. (mV)',clamp_std,10,3,200);
      getRealA(' clamping the synaptic time (ms)',clamp_Ts,10,3,200);
      getRealA(' Max. Conductance factor (*Gl)',max_conductance_factor,10,3,200);
      getRealA(' shift resting pot. (mV) ==NT WKG',shift_mean,10,3,200);
      getRealA(' ratio of Qi/Qe ==NT WKG',ratio_qi_qe,10,3,200);
      setText('______________________________________');
      getIntegerA('Number of points ',point_number,6,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Gtot and Tv comod Effect';
      Show;
   end;
end;

{$EDIT muV_Effect} 

procedure init_muV_effect_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_muV_effect_on_spiking';
   clamp_Ts := 3; clamp_std := 4 ;
   clamp_gtotN := 8 ; {muG/Gl}
   shift_mean :=0 ;   ratio_qi_qe := 1 ;
   REPETITION := 1; {REPEATING FOR DIFFERENT SEEDS}
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
   point_number := 10 ;
   min_muV := -60;
   max_muV := -53 ;
end;

procedure gen_MUVE_input; 
var ii : integer ; FE, FI, g_tot, Gl, dv : real;
begin
   initialize_stimulation_vectors;
    
   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}

   g_tot := Gl*clamp_gtotN ;  // nS

   dv := (max_muV-min_muV)/(point_number-1) ; {mV}

   for ii:=0 to point_number-1 do 
   begin
      muV := min_muV+ii*dv ; {in mV,  shuffled through vec_i}
      params_variations_calc(g_tot, muV+shift_mean, clamp_std, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

      put_the_values_into_stimulation_vectors(g_tot, clamp_mean, shift_mean, clamp_std, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure MUVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_MUVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitMUVEdialog;
begin
   init_muV_effect_const;
   with TFdialog do
   begin
      create;
      OnEvent:=MUVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the std dev. (mV)',clamp_std,10,3,200);
      getRealA(' clamping the syn. time (ms)',clamp_Ts,10,3,200);
      getRealA(' clamping muG/Gl ([])',clamp_gtotN, 10,3,200);
      setText('______________________________________');
      getRealA(' Min. muV',min_muV,10,3,200);
      getRealA(' Max. muV',max_muV,10,3,200);
      setText('______________________________________');
      getRealA(' ratio of Qi/Qe (NT WKG)',ratio_qi_qe,10,3,200);
      getRealA(' shift resting pot. (mV) (NT WKG)',shift_mean,10,3,200);
      setText('______________________________________');
      getIntegerA('Number of points ',point_number,6,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Dependence on mean Vm';
      Show;
   end;
end;


{$EDIT sV_Effect} 

procedure init_sV_effect_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_SV_effect_on_spiking';
   clamp_Ts := 3; clamp_mean := -58 ;
   clamp_gtotN := 8 ; {muG/Gl}
   shift_mean :=0 ;   ratio_qi_qe := 1 ;
   REPETITION := 1; {REPEATING FOR DIFFERENT SEEDS}
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
   point_number := 10 ;
   min_sV := 3;   max_sV := 8 ;
end;

procedure gen_sVE_input; 
var ii : integer ; FE, FI, g_tot, Gl, dsv, sv1 : real;
begin
   initialize_stimulation_vectors;

   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}

   g_tot := Gl*clamp_gtotN ;  // nS

   dsv := (max_sV-min_sV)/(point_number-1) ; {mV}

   for ii:=0 to point_number-1 do 
   begin
      sV1 := min_sV+ii*dsv ; {in mV,  shuffled through vec_i}
      params_variations_calc(g_tot, clamp_mean+shift_mean, sV1, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
      put_the_values_into_stimulation_vectors(g_tot, clamp_mean, shift_mean, sV1, clamp_Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
    end;
   create_and_shuffle_the_index_vector(point_number, REPETITION);
end;


procedure SVEDialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_SVE_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure InitSVEdialog;
begin
   init_sV_effect_const;
   with TFdialog do
   begin
      create;
      OnEvent:=SVEDialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>Stimulation Parameters :');
      getRealA(' clamping the mean (mV)',clamp_mean,10,3,200);
      getRealA(' clamping the syn. time (ms)',clamp_Ts,10,3,200);
      getRealA(' clamping muG/Gl ([])',clamp_gtotN, 10,3,200);
      setText('______________________________________');
      getRealA(' Min. sV',min_sV,10,3,200);
      getRealA(' Max. sV',max_sV,10,3,200);
      setText('______________________________________');
      getRealA(' ratio of Qi/Qe (NT WKG)',ratio_qi_qe,10,3,200);
      getRealA(' shift resting pot. (mV) (NT WKG)',shift_mean,10,3,200);
      setText('______________________________________');
      getIntegerA('Number of points ',point_number,6,200);
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      setText('');
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      Caption:='Dependence on std Vm';
      Show;
   end;
end;

{$EDIT Massive_mV_sV_Tv_mG} 

{ ==============================================================================
--------------------------------- Scanning the mV_sV_Tv_mG space ---------------------------------------
================================================================================ }

procedure init_massive_scan_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_massive_mV_sV_Tv_mG';
   min_muV:=-65; max_muV:=-58;
   min_sV:=3; max_sV:=10;
   min_sV2:=0.5; max_sV2:=1.7;
   min_muGn:=2; max_muGn:=8;
   min_Ts:=4; max_Ts:=7;
   DISCRET_SV := 3;
   DISCRET_MV := 3;
   DISCRET_MUG:= 3 ;
   DISCRET_TS:= 1;
   shift_mean :=0 ; 
   REPETITION:=1;
   ratio_Qi_Qe:=1; ratio_Ti_Te:=1;
end;


procedure gen_massive_scan_input; 
var iv, is, it, ig, n_tot : integer ; 
fe, fi, q, muGn, DmuG, DmV, DsV, sV1_min, sv1_max, DTs, Gl, g_tot, compress : real; 
vec_ts1:Tvector;
begin
   n_tot := DISCRET_SV*DISCRET_MV*DISCRET_MUG*DISCRET_TS; {total number of points}
   initialize_stimulation_vectors;

   if Rm<>0 then Gl:=1000/Rm else MessageBox('Rm =0, no calculus possible !');  {nanoSiemens !!!}

   if DISCRET_MV>1 then DmV := (max_muV-min_muV)/(DISCRET_MV-1) else DmV:=1;
   if DISCRET_TS>1 then DTs := (max_Ts-min_Ts)/(DISCRET_TS-1) else DTs:=1;
   if DISCRET_MUG>1 then DmuG := (max_muGn-min_muGn)/(DISCRET_MUG-1) else DmuG:=1;

   for iv:=0 to DISCRET_MV-1 do 
   begin
      muV := min_muV + iv*DmV;
      {here we construct the triangle for the mean and variance}
      { sV1_min:= max_muV-muV+min_sV ;  sv1_max:=min_muV-muV+max_sV; }

      sv1_max:=max_sV+iv/DISCRET_MV*(max_sV2-max_sV);
      sv1_min:=min_sV+iv/DISCRET_MV*(min_sV2-min_sV);

      if DISCRET_SV>1 then DsV := (sV1_max-sV1_min)/(DISCRET_SV-1) else DsV:=1;
      for is:=0 to DISCRET_SV-1 do 
      begin 
	 sV := sv1_min + is*DsV;
	 for ig:=0 to DISCRET_MUG-1 do 
	 begin
	    muGn:=min_muGn +ig*DmuG;
	    g_tot := Gl*muGn;
	    for it:=0 to DISCRET_TS-1 do 
	    begin
	       Ts:=min_Ts +it*DTs;

	       params_variations_calc(g_tot, muV+shift_mean, sV, Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);

	       {NOW WE CAN APPEND THE VALUES TO THE VECTORS}
	       put_the_values_into_stimulation_vectors(g_tot, muV,shift_mean, sV, Ts, Ee, Ei, Rm, Cm, El, FE, FI, Q, Tv);
	    end;
	 end;
      end;
   end;
   create_and_shuffle_the_index_vector(n_tot, REPETITION);
end;


procedure massive_scan_DialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     201 : Run_massive_scan;
     301 : begin global_step:=0; gen_massive_scan_input; InitializeChannels; basic_nrn_init;end;
     end;
     TFdialog.update;
end;  


procedure Init_massive_scan_dialog;
begin
   init_massive_scan_const;
   with TFdialog do
   begin
      create;
      OnEvent:=massive_scan_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Investigating the effect of input conductance on spike triggering');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      getIntegerA('REPETITION of SEED (int)',REPETITION,6,200);
      setText('o==>GRID Parameters :');
      getIntegerA('=====> DISCRET. muV ',DISCRET_MV,6,200);
      getRealA(' Min. muV',min_muV,10,3,200);
      getRealA(' Max. muV',max_muV,10,3,200);
      getRealA(' shift resting pot. (mV) (NT WKG)',shift_mean,10,3,200);
      getIntegerA('=====> DISCRET. sV ',DISCRET_SV,6,200);
      getRealA(' Min. sV (at min. muV)',min_sV,10,3,200);
      getRealA(' Max. sV (at min. muV)',max_sV,10,3,200);
      getRealA(' Min. sV (at max. muV)',min_sV2,10,3,200);
      getRealA(' Max. sV (at max. muV)',max_sV2,10,3,200);
      getIntegerA('=====> DISCRET. muG ',DISCRET_MUG,6,200);
      getRealA(' Min. Gtot/Gl',min_muGn,10,3,200);
      getRealA(' Max. Gtot/Gl',max_muGn,10,3,200);
      getIntegerA('=====> DISCRET. Ts ',DISCRET_TS,6,200);
      getRealA(' Min. Ts',min_Ts,10,3,200);
      getRealA(' Max. Ts',max_Ts,10,3,200);
      { getRealA(' ratio of Qi/Qe (NT WKG)',ratio_qi_qe,10,3,200); }
      { getRealA(' ratio of Ti/Te (NT WKG)',ratio_qi_qe,10,3,200); }
      setText('');
      getIntegerA('MAX spikes number',max_spikes_number,6,200);
      getRealA('max_authorized_time)',max_authorized_time,10,3,200);
      setText('=======================================');
      setText('');
      getCommandA(' Generate and Shuffle the stim ',0,301); { OnEvent flag -> 201 }
      getCommandA(' Run ',0,201); { OnEvent flag -> 201 }
      getIntegerA('Current Step ',global_step,6,200);
      if location='Setup'then
      begin
      getRealA(' Current muV (mV)',muV,10,3,200);
      getRealA(' Current sV (mV)',sV,10,3,200);
      getRealA(' Current muG (nS)',muG,10,3,200);
      getRealA(' Current Ts (ms)',Ts,10,3,200);
      setText('');
      end;
      getboolean('Continue Running (stop asap...)',continu_flag);
      getboolean('jump to the next one',jump_to_next);
      Caption:='massive scan mV-sV-Tv-mG space';
      Show;
   end;
end;


{$EDIT Input_from_self_spikes} 
{ ==============================================================================
--- Response to a shotnoise generated by the output frequency of the neuron ------
================================================================================ }

var I0_iss, stopI:real; Ne, Ni, spike_number_for_update:integer;

procedure init_ISS_const;
begin                      
   TDBrecord('PG0.Exp_params').exp_type := 'tf_input_by_self_spikes' ;
   I0_iss := 0.05 ; {nA}
   stopI := 700 ; {ms}
   Ni:=50;Ne:=200;
   Qi:=100;Qe:=6;
   spike_number_for_update := 10;
end;


procedure write_ISS_params; {to be used by all subsequent protocols}
begin
    TDBrecord('PG0.Exp_params').Ee:=Ee ; 
    TDBrecord('PG0.Exp_params').Ei:=Ei ; 
    TDBrecord('PG0.Exp_params').Ne:=Ne ; 
    TDBrecord('PG0.Exp_params').Ni:=Ni ; 
    TDBrecord('PG0.Exp_params').seed_exc:=SEED ;
    TDBrecord('PG0.Exp_params').seed_inh:=SEED+1 ;
    TDBrecord('PG0.Exp_params').clamp_mean := clamp_mean;
    TDBrecord('PG0.Exp_params').max_conductance_factor := max_conductance_factor;
    TDBrecord('PG0.Exp_params').ratio_qi_qe := ratio_qi_qe ;
    TDBrecord('PG0.Exp_params').point_number := point_number;
    TDBrecord('PG0.Exp_params').global_step_start := global_step;
end;

procedure Init_single_exp_ISS(SEED:integer);
begin         
   RTneuron.execute('objref ncE, nsE, ncI, nsI');
   RTneuron.execute('soma nsE = new NetStim_from_self_spike(0.5)');
   RTneuron.execute('nsE.number = 1e30');
   RTneuron.execute('nsE.noise = 1'); // frequency and seed comes later !
   RTneuron.execute('soma ncE = new NetCon(nsE, stim)');
   RTneuron.execute('ncE.weight = 0.001*'+Rstr(Qe));
   RTneuron.execute('ncE.delay = 0');
   RTneuron.execute('nsE.synapses_number='+Istr(Ne));
   RTneuron.execute('soma nsI = new NetStim_from_self_spike(0.5)');
   RTneuron.execute('nsI.number = 1e30');
   RTneuron.execute('nsI.noise = 1');                        
   RTneuron.execute('soma ncI = new NetCon(nsI, stim)');
   RTneuron.execute('ncI.weight = -0.001*'+Rstr(Qi));  // NEGATIVE FLAG HERE !!!!
   RTneuron.execute('ncI.delay = 0');
   RTneuron.execute('nsI.synapses_number='+Istr(Ni));
   { // parameters of the synapses }
   RTneuron.execute('stim.tauE = '+Rstr(Te));
   RTneuron.execute('stim.tauI = '+Rstr(Ti));
   RTneuron.execute('stim.Ee = '+Rstr(Ee));
   RTneuron.execute('stim.Ei = '+Rstr(Ei));

   {configuring the seed of the excitatory presynaptic events}
   RTneuron.execute('nsE.seed('+Istr(SEED)+')');
   RTneuron.execute('nsI.seed('+Istr(SEED+1)+')');
   
   {Initial current input}
   RTneuron.execute('nsE.start = '+Rstr(stopI)); {feedback starts when current stops}
   RTneuron.execute('nsI.start = '+Rstr(stopI)); {feedback starts when current stops}
   RTneuron.execute('stim.stopI = '+Rstr(stopI)); {feedback starts when current stops}
   RTneuron.execute('stim.Icst = '+Rstr(I0_Iss)); {feedback starts when current stops}

   {synaptic weights}
   RTneuron.execute('ncE.weight = 0.001*'+Rstr(Qe));
   RTneuron.execute('ncI.weight = -0.001*'+Rstr(Qi)); {NEGATIVE FLAG !!!}
   
   RTneuron.execute('finitialize()');
end;


procedure ISS_DialogEvent(n:integer);
var is_already_inh : integer ; ii :integer ;
begin
   TFdialog.updatevar;
   case n of
     301 : begin InitializeChannels; Init_single_exp_ISS(SEED); end;
     end;
     TFdialog.update;
end;  


procedure Init_ISS_dialog;
begin
   init_ISS_const;
   with TFdialog do
   begin
      create;
      OnEvent:=ISS_DialogEvent;
      { !! Very Important : at every GUI event, we call this function}
      setText('Firing rate determines presynaptic stimulation');
      setText('______________________________________');
      getIntegerA('SEED (int)',SEED,6,200);
      setText('o==>GRID Parameters :');
      getRealA('initial current input (nA) ',I0_iss,10,3,200);
      getRealA('input duration (ms) ',stopI,10,3,200);
      getIntegerA('spike number for update ',spike_number_for_update,3,200);
      getRealA('max_authorized_time',max_authorized_time,10,3,200);
      setText('=======================================');
      getRealA('Qe (nS)',Qe,10,3,200);
      getRealA('Qi (nS)',Qi,10,3,200);
      getRealA('Te (nS)',Te,10,3,200);
      getRealA('Ti (nS)',Ti,10,3,200);
      getRealA(' ratio of Qi/Qe (NT WKG)',ratio_qi_qe,10,3,200);
      getRealA(' shift resting pot. (mV) (NT WKG)',shift_mean,10,3,200);
      setText('______________________________________');
      setText('');
      getCommandA(' Initialize the stim ',0,301); { OnEvent flag -> 201 }
      setText('');
      Caption:='Input by self spikes';
      Show;
   end;
end;



{$EDIT Main_dialog}
{ ==============================================================================
--------- BUILDING THE MAIN DIALOG  --------------------------------------------
================================================================================ }

procedure MainDialog_update(n:integer); 
var amplifier : string ;
begin { Main dialog, fot the choice of the protocol, the start/stop and saving of the acquisition}     
  if acquisition.IsRunning then acquisition.stop; 
  MainDialog.updatevar;
  TDBrecord('PG0.global').Gain1_int:=gain1_int;
  TDBrecord('PG0.global').Gain2_int:=gain2_int;
  TDBrecord('PG0.global').clamp_int := clamp_int; 
  TDBrecord('PG0.global').f_acq := f_acq; 
  case n of
    101: begin 
              case protocol_choice of
                       1 : InitTFdialog; 
                       2 : InitMassivedialog;
                       3 : InitGTEdialog;                
                       4 : InitTvEdialog;                
                       5 : InitGTVEdialog;                
                       6 : InitMUVEdialog;                
                       7 : InitSVEdialog;                
                       8 : Init_massive_scan_dialog;
                       9 : Init_ISS_dialog;
              end; 
         end;
    111 : begin SetGain1; end;
    112 : begin SetGain2; end;
    200 : if SAVING then acquisition.startandsave else acquisition.start;
    201 : acquisition.stop ;
    301 : comments := '';
    281 : RTneuron.Execute(dll_load);
    282 : RTneuron.Restart;
  end;
  gain1:=TDBrecord('PG0.global').Gain1;
  gain2:=TDBrecord('PG0.global').Gain2;    
  clamp_int:=TDBrecord('PG0.global').clamp_int ;      
  f_acq := TDBrecord('PG0.global').f_acq ; 
  MainDialog.update;
end;    


procedure Init_Main_Dialog; {we call this procedure when we load the main program, (else values are 0 -> dangerous for division, e.g. freq) }
var amplifier : string ;
begin
DB.create;
dll_load := TDBrecord('PG0.global').loadnrnpath ;
dll_load := 'nrn_load_dll("'+dll_load+'nrnmech.dll")';
PathOfTheDay := TDBrecord('PG0.global').PathOfTheDay ; // data path
amplifier := TDBrecord('PG0.global').amplifier ;
protocol_choice := 0;
//------------
   with MainDialog do
   begin
      create;
      getRealA('Acquisition freq. (kHz)',f_acq,3,2,785);
      setText('|=== Recording Parameters ===|');
      getRealA('Rs -- Access resistance (MO)',Bridge,4,2,785);
      getRealA('Rm -- Input resistance (MO)',Rm,4,2,785);
      getRealA('Cm -- Membrane capacitance (pF)',Cm,4,2,785);
      getRealA('El -- Resting potential (mV)',El,4,2,785);
      getRealA('Ih -- Holding current (pA)',Holding,4,2,785);
      setText('Last measured at : '+Istr(Hour)+'h '+Istr(Minute)+'m '+Istr(Second)+'s');
      setText('|--------------------------------------------------------|');
      setText('');
      OnEvent := MainDialog_update;
   
      getCommandA(' restart NEURON ',0,282);
      getCommandA(' load NEURON mech ',0,281);
      //getCommandA(' load NEURON model ',0,280); 

      setText(' ================================= ');
      setText(' ---------------< Protocol Selection >----------------- ');
      setText('');
      getStringList('  PROTOCOL  ',ProtoNames,Protonum,protocol_choice,101);  { Onevent flag ->199}
   setText(' ================================= ');
   setText('');
   if amplifier='multiclamp' then 
     begin 
        setText(' ==<| GAIN  |>== ');
        getStringListA('Primary Output  ','1 | 2 | 5 | 10 | 20 | 50 | 100 | 200 | 500 | 1000 | 2000',Gain1_int,111);
        getStringListA('Secondary Output ','1 | 2 | 5 | 10 | 20 | 50 | 100',Gain2_int,112);
        setText('');
     end;
   getBoolean(' saving ? ',SAVING);
   getCommandA(' => Start ...           ',0,200);
   getCommandA(' Stop the Acquisition ',0,201);
   setText('');
   getMemo(' Comments ',comments,15,4,1,300);
   getCommandA(' reset comments ',0,301);
   Caption:='Main Dialog';
  end;
Maindialog.show;
end;


{$EDIT init_from_file}
{-------------------------------------------------------------------------------
-------------------- initialisation from file ----------------------------------
-------------------------------------------------------------------------------}

var 
    already_initiated : boolean ; // to know if we need to reinitialize the TDBrecord
    global, Exp_params : TDBrecord ;
    vec_params : Tvector ;

procedure read_params;
var size : integer ;  filename : string;
begin
     vec_params.create;
     filename :=TDBrecord('PG0.global').PathOfTheDay+'cell_params';
     if FileExists(filename) then 
     begin
     vec_params.LoadObject(filename);
     f_acq:= vec_params[0]; 
     Rm :=vec_params[1] ;  Cm :=vec_params[2] ; 
     El :=vec_params[3] ;  Bridge :=vec_params[4] ;  Holding:=vec_params[5]; 
     gain1_int:=Round(vec_params[6]) ;   gain1:=vec_params[7] ;
     gain2_int := Round(vec_params[8]) ; gain2:=vec_params[9] ;
     // now the time at which they have been calculated !
     Hour:=Round(vec_params[10]); Minute:=Round(vec_params[11]) ; Second:=Round(vec_params[11]) ; 
     end else begin
     MessageBox('no parameters loaded !!!');
     Rm :=400;Cm:=50;Bridge:=15;El:=-70;f_acq:=10;Holding:=0;
     gain1_int:=1;gain1:=1;gain2_int:=1;gain2:=1;
     end; 
     TDBrecord('PG0.global').f_acq := f_acq ; TDBrecord('PG0.global').Rm := Rm ;
     TDBrecord('PG0.global').Cm := Cm ; TDBrecord('PG0.global').El := El ;  
     TDBrecord('PG0.global').Bridge := Bridge ;  TDBrecord('PG0.global').Holding := Holding ; 
     TDBrecord('PG0.global').gain1 := gain1 ;  TDBrecord('PG0.global').gain2 := gain2 ;
end;

procedure global_init;
var PathOfTheDay : string ;
begin

RTneuron.resetParams;
DecodeDateTime(Now,Year,Month,Day,Hour,Minute,Second,MilliSecond); {function to fetch date and time}
time_detector.create ; detector.create ;

global.create; Exp_Params.create;
 

/// ---- CASE ON LAPTOP
if location='Notebook'then
begin
TDBrecord('PG0.global').amplifier:='nrn_simulation'; // choice of the amplifier
PathOfTheDay := 'C:\Users\yann\Documents\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ;
TDBrecord('PG0.global').loadnrnPath := 'D:/home/yann/work/elphy_code/nrn_files/' ; 
end;
if location='Setup'then
begin
/// ---- CASE ON MULTICLAMP
TDBrecord('PG0.global').amplifier:='multiclamp';
PathOfTheDay := 'D:\Yann\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
TDBrecord('PG0.global').loadnrnPath := 'D:/Yann/elphy_code/nrn_files/' ; 
end;
if location='Linux' then
begin
/// ---- CASE ON LINUX MACHINE
TDBrecord('PG0.global').amplifier:='nrn_simulation';
PathOfTheDay := 'Z:\home\yann\Documents\DATA\'+Istr(Year)+'_'+Istr(Month)+'_'+Istr(Day)+'\' ; 
TDBrecord('PG0.global').loadnrnPath := 'Z:/home/yann/work/elphy_code/nrn_files/' ; 
end;

if DirectoryExists(PathOfTheDay)=False then CreateDir(PathOfTheDay);
TDBrecord('PG0.global').PathOfTheDay := PathOfTheDay ;


// those 3 parameters are obvious, we just keep them for compatibility with the other conventions
TDBrecord('PG0.global').clamp_int := 1; // integer that code for 1:IC, 2: VC
TDBrecord('PG0.global').cont_choice := True; // if True -> continus mode, else episode
TDBrecord('PG0.global').stim := False;  // if True acquisition.Fstimulate := True


TDBrecord('PG0.global').main_protocol:='';
TDBrecord('PG0.global').protocol:='transfer_functions';
TDBrecord('PG0.global').saving := True ;


TDBrecord('PG0.global').FadvanceON := True ;  
   
InsertPage(1,'fake');DeleteAllPages('fake');InsertPage(1,'default');DeleteAllPages('default');
Color := cl_gray ;
end;


{
program set_to_zero
Rtneuron.DacChan[0].HoldingValue:=0;
Rtneuron.DacChan[0].UseHoldingValue:=True;    
}

program Launch
global_init ;
read_params;
SetProtocolNames;
init_windows;
Init_Main_Dialog;
initTFparameters;
init_massivetf_const;

